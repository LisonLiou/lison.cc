{"meta":{"title":"LISON","subtitle":"吾等采石之人, 当心怀大教堂之愿景.","description":"I was a naughty child. When darkness coming I can’t find the way home. 自称是个废物","author":"Lison Liou","url":"https://lison.cc","root":"/"},"pages":[],"posts":[{"title":"邪恶C++之设置成员变量的坑","slug":"cpp-evil-set-a-member-variable","date":"2025-09-08T02:43:54.000Z","updated":"2025-09-08T02:57:33.076Z","comments":true,"path":"cpp-evil-set-a-member-variable/","link":"","permalink":"https://lison.cc/cpp-evil-set-a-member-variable/","excerpt":"","text":"有这样的代码： 123456789101112131415class Thread_Video : public QObject &#123; Q_OBJECTpublic: explicit Thread_Video(QObject *parent = nullptr); ~Thread_Video(); void setSelectedROI(cv::Rect selectedROI)&#123; this-&gt;selectedROI = selectedROI; &#125;private: cv::Rect selectedROI; &#125; 主要是设置成员变量的方法: setSelectedROI，看起来没问题，但是实际运行的时候发现，如果有多个Thread_Video对象，使用setSelectedROI进行私有变量selectedROI设置的时候，只有第一个Thread_Video对象的selectROI对象被设置成功了，其他的Thread_Video对象的selectedROI私有变量的值都是0。 才疏学浅只找到了解决方法， 但是不知道原因。 解决方法，形参不要和私有变量名字重复，不清楚是变量拷贝问题还是作用域问题： 123void setSelectedROI(cv::Rect roi)&#123; this-&gt;selectedROI = roi;&#125; 血泪的两小时教训。。。","categories":[],"tags":[],"author":"Lison"},{"title":"Qt历史数据使用线性回归算法预测未来数据趋势","slug":"qt-chart-linear-regression","date":"2025-03-19T03:02:29.000Z","updated":"2025-03-19T03:16:06.569Z","comments":true,"path":"qt-chart-linear-regression/","link":"","permalink":"https://lison.cc/qt-chart-linear-regression/","excerpt":"工作中写的一个线性回归的图表demo，马上就删了，做一下记录；使用随机生成的数据，添加趋势线与预测数据","text":"工作中写的一个线性回归的图表demo，马上就删了，做一下记录；使用随机生成的数据，添加趋势线与预测数据 .h代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;QWidget&gt;#include &lt;QtCharts&gt;QT_CHARTS_USE_NAMESPACEnamespace Ui &#123;class WindowTrend_INS;&#125;class WindowTrend_INS : public QWidget&#123; Q_OBJECTpublic: explicit WindowTrend_INS(QWidget *parent = nullptr); ~WindowTrend_INS();private slots: void on_pushButton_eva_trend_clicked();private: Ui::WindowTrend_INS *ui; QSplineSeries *historicSeries,*predictSeries; QLineSeries *trendSeries; QChart *chart; QDateTimeAxis * axisX; QValueAxis * axisY; QDateTime datetimeNow,datetimeFuture30Days; QList&lt;QPointF&gt; listHistoric,listPredict; void initData(); // 计算线性回归的趋势线 QLineSeries* calculateTrendLine(const QList&lt;QPointF&gt;&amp; dataPoints,double &amp;slope,double &amp;intercept) &#123; QLineSeries *trendLineSeries = new QLineSeries(); trendLineSeries-&gt;setName(&quot;趋势&quot;); if (dataPoints.isEmpty()) &#123; return trendLineSeries; &#125; // 计算线性回归的斜率和截距 double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0; int n = dataPoints.size(); for (const QPointF&amp; point : dataPoints) &#123; sumX += point.x(); sumY += point.y(); sumXY += point.x() * point.y(); sumX2 += point.x() * point.x(); &#125; slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX); // 斜率 intercept = (sumY - slope * sumX) / n; // 截距 // 生成趋势线的起点和终点 double x1 = dataPoints.first().x(); double y1 = slope * x1 + intercept; double x2 = dataPoints.last().x(); double y2 = slope * x2 + intercept; *trendLineSeries &lt;&lt; QPointF(x1, y1) &lt;&lt; QPointF(x2, y2); return trendLineSeries; &#125;&#125;; .cpp代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &quot;WindowTrend_INS.h&quot;#include &quot;ui_WindowTrend_INS.h&quot;WindowTrend_INS::WindowTrend_INS(QWidget *parent) : QWidget(parent), ui(new Ui::WindowTrend_INS)&#123; ui-&gt;setupUi(this); initData();&#125;WindowTrend_INS::~WindowTrend_INS()&#123; delete ui;&#125;void WindowTrend_INS::initData()&#123; datetimeNow = QDateTime::currentDateTime(); datetimeFuture30Days = datetimeNow.addDays(30); ui-&gt;timefrom-&gt;setDateTime(datetimeNow); ui-&gt;timeto-&gt;setDateTime(datetimeFuture30Days); chart = new QChart(); ui-&gt;chart_trend-&gt;setRenderHint(QPainter::Antialiasing); // 创建历史数据曲线 historicSeries = new QSplineSeries(); historicSeries-&gt;setName(&quot;历史数据&quot;); // historicSeries-&gt;setPointLabelsVisible(true); // 显示标签 // historicSeries-&gt;setPointLabelsFormat(&quot;(@xPoint, @yPoint)&quot;); // 设置标签格式 // historicSeries-&gt;setPointLabelsColor(Qt::blue); // 设置标签颜色 // historicSeries-&gt;setPointLabelsFont(QFont(&quot;Arial&quot;, 10)); // 设置标签字体 // 创建图表 chart-&gt;addSeries(historicSeries); chart-&gt;setTitle(&quot;惯性元件性能预测&quot;); chart-&gt;setTitleFont(QFont(&quot;黑体&quot;,14)); // 设置X轴和Y轴的范围 axisX = new QDateTimeAxis(this); axisX -&gt; setTitleText(&quot;预测时间&quot;); //设置轴的标题 axisX -&gt; setRange(datetimeNow,datetimeFuture30Days); //设置时间轴的范围,参数是两个时期时间QDateTime axisX -&gt; setFormat(&quot;MM-dd HH:mm&quot;); //设置刻度值的格式，和格式化时间字符串一样 axisX -&gt; setLabelsAngle(15); chart -&gt; addAxis(axisX, Qt::AlignBottom); //添加轴 axisY = new QValueAxis(this); axisY-&gt;setMin(-1); axisY-&gt;setMax(1); axisY-&gt;setRange(-0.1, 0.1); axisY-&gt;setTickAnchor(0.1); axisY-&gt;setTickInterval(0.01); axisY-&gt;setTickType(QValueAxis::TicksDynamic); axisY-&gt;setTitleText(&quot;误差值&quot;); chart-&gt;addAxis(axisY, Qt::AlignLeft); historicSeries-&gt;attachAxis(axisX); historicSeries-&gt;attachAxis(axisY); ui-&gt;chart_trend-&gt;setChart(chart); //生成默认数据，将从数据库提取 listHistoric.clear(); for(int i=1;i&lt;30;i++)&#123; // 生成 [0, 1) 范围内的随机数 double randomValue = QRandomGenerator::global()-&gt;generateDouble()*0.05-0.01; listHistoric.append(QPointF(QDateTime::currentDateTime().addDays(i).toMSecsSinceEpoch(), randomValue)); &#125; historicSeries-&gt;clear(); historicSeries-&gt;append(listHistoric);&#125;void WindowTrend_INS::on_pushButton_eva_trend_clicked()&#123; // 计算趋势线 if(!chart-&gt;series().contains(trendSeries))&#123; double slope,intercept; trendSeries = calculateTrendLine(listHistoric,slope,intercept); trendSeries-&gt;setPen(QPen(QBrush(Qt::red),2,Qt::DotLine)); trendSeries-&gt;setName(&quot;趋势&quot;); trendSeries-&gt;setPointLabelsVisible(true); chart-&gt;addSeries(trendSeries); trendSeries-&gt;attachAxis(axisX); trendSeries-&gt;attachAxis(axisY); &#125; //计算预测数据 if(!chart-&gt;series().contains(predictSeries))&#123; predictSeries = new QSplineSeries(); predictSeries-&gt;setPen(QPen(QBrush(Qt::green),2,Qt::DashDotDotLine)); predictSeries-&gt;setName(&quot;预测数据&quot;); predictSeries-&gt;setPointLabelsVisible(true); chart-&gt;addSeries(predictSeries); predictSeries-&gt;attachAxis(axisX); predictSeries-&gt;attachAxis(axisY); //强调一下连接点joint listPredict.append(listHistoric.last()); listPredict.append(listHistoric.last()); listPredict.append(listHistoric.last()); listPredict.append(listHistoric.last()); listPredict.append(listHistoric.last()); for(int i=1;i&lt;30;i++)&#123; // 生成 [0, 1) 范围内的随机数 double randomValue = QRandomGenerator::global()-&gt;generateDouble()*0.05-0.01; // listPredict.append(QPointF(QDateTime::currentDateTime().addDays(i).toMSecsSinceEpoch(), randomValue)); QPointF p = QPointF(QDateTime::fromMSecsSinceEpoch(listHistoric.last().x()).addDays(i).toMSecsSinceEpoch(), randomValue); qDebug()&lt;&lt;&quot;&quot;&lt;&lt; p; listPredict.append(p); &#125; predictSeries-&gt;clear(); predictSeries-&gt;append(listPredict); //延长x轴 datetimeFuture30Days = datetimeFuture30Days.addDays(30); axisX -&gt; setRange(datetimeNow,datetimeFuture30Days); //设置时间轴的范围,参数是两个时期时间QDateTime &#125;&#125; .ui文件不贴了，只有一个QChartView。注意pro文件对应增加 : 1QT += charts","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[],"author":"Lison"},{"title":"top5-ideas-in-the-world","slug":"top5-ideas-in-the-world","date":"2024-09-14T08:31:28.000Z","updated":"2024-09-14T09:38:33.850Z","comments":true,"path":"top5-ideas-in-the-world/","link":"","permalink":"https://lison.cc/top5-ideas-in-the-world/","excerpt":"","text":"TOP 5 IDEAS IN THE WORLD. MURPHY’S LAWTHE MORE YOU FEAR SOMETHING, THE MORE IT WILL HAPPEN. KIDLIN’S LAWIF YOU CAN WRITE THE PROBLEM DOWN CLEARLY, THEN THE MATTERS IS HALF SOLVED. GIBERT’S LAWTHE BIGGEST PROBLEM AT WORK IS THAT NO ONE TELLS YOU WHAT TO DO. WALSON’S LAWIF YOU PUT INFORMATION AND INTELLEGENCE FIRST AT ALL THE TIMES, THEN THE MONEY KEEPS COMING IN. FALKLAND’S LAWWHEN YOU DON’T HAVE TO MAKE A DESICION, THEN DON’T MAKE A DECISION.","categories":[],"tags":[],"author":"Lison"},{"title":"我们自顾自的卖弄，是多么可笑","slug":"human-nature-selfish","date":"2024-09-02T07:49:31.000Z","updated":"2024-09-02T08:43:14.267Z","comments":true,"path":"human-nature-selfish/","link":"","permalink":"https://lison.cc/human-nature-selfish/","excerpt":"How SELFISH we are. How VAIN we are. The worldview values that a person develops at the age of 17 or 18 will almost undeniably carry through the code of conduct that guides him throughout his life. Whether that principle is correct or wrong. The parties will try to foreshadow and brainwash, understand and interpret the people and things they encounter. Because this is what he knows what he believes. It is nothing to do with right or wrong. Something beyond his cognition? Denied. The idea that there is almost no way to self-correct and identify with others is truly a tragedy. He can only see what he can see.","text":"How SELFISH we are. How VAIN we are. The worldview values that a person develops at the age of 17 or 18 will almost undeniably carry through the code of conduct that guides him throughout his life. Whether that principle is correct or wrong. The parties will try to foreshadow and brainwash, understand and interpret the people and things they encounter. Because this is what he knows what he believes. It is nothing to do with right or wrong. Something beyond his cognition? Denied. The idea that there is almost no way to self-correct and identify with others is truly a tragedy. He can only see what he can see. DO NOT ATEEMPT TO CHANGE PEOPLE OTHERS.That could be interpreted as a sign of danger or being controled.If you must change someone, change your-self is better idea. 1人有多自私 人有多虚荣 一个人在十七八岁形成的世界观价值观几乎不可否认的会贯穿指导他一生的行为准则 无论这种准则是好是坏 当事人都会试图对其遇到的人和事进行铺垫与洗脑，理解和阐释， 因为这是他的认知范围 这是他所相信的东西 正确与否不重要 超出认知之外的事物 一律加以远离与否定 几乎没有办法进行自我纠正与他人认同 这种思想真的是一种悲剧 你只能看到手电筒照到的地方 和夏天没有冰的地方 不要试图改变别人 这会被解读成危险或者控制的信号 改变自己就好了 我们自顾自的卖弄 是那么可笑","categories":[{"name":"人性","slug":"人性","permalink":"https://lison.cc/categories/%E4%BA%BA%E6%80%A7/"}],"tags":[{"name":"自私","slug":"自私","permalink":"https://lison.cc/tags/%E8%87%AA%E7%A7%81/"},{"name":"虚荣","slug":"虚荣","permalink":"https://lison.cc/tags/%E8%99%9A%E8%8D%A3/"}],"author":"Lison"},{"title":"AOSP 编译 - 默认开启无线调试并连接默认WiFi","slug":"aosp-wifi-debug-wireless-debug","date":"2024-09-02T07:08:54.000Z","updated":"2024-09-02T08:47:05.853Z","comments":true,"path":"aosp-wifi-debug-wireless-debug/","link":"","permalink":"https://lison.cc/aosp-wifi-debug-wireless-debug/","excerpt":"使用Android 5.1 AOSP系统源码，达成目标： 开机连接指定WiFi(比如Wifi名digitech，密码11111117)，这样只要周围有热点为括号中的名称与密码的网络，设备将自动连接这个wifi。 默认启用无线调试，启用无线调试后，调试人员可以在第1步完成后直接1adb connect xxx.xxx.xxx.xxx:5555 连接到设备进行调试","text":"使用Android 5.1 AOSP系统源码，达成目标： 开机连接指定WiFi(比如Wifi名digitech，密码11111117)，这样只要周围有热点为括号中的名称与密码的网络，设备将自动连接这个wifi。 默认启用无线调试，启用无线调试后，调试人员可以在第1步完成后直接1adb connect xxx.xxx.xxx.xxx:5555 连接到设备进行调试 开机连接指定WiFi 我们的手机,Pad，手表等安卓设备在我们手动连接了某个WiFi后，第二次再接近这个WiFi后会自动连接，其WiFi信息保存在/data/misc/wifi/wpa_supplicant.conf，这个是用户的数据，设备重启后此信息是不会重置的。 而系统默认的WiFi信息保存在: /system/etc/wifi/wpa_supplicant.conf，好像这里的信息在每次设备重启后都会还原 了解上述内容后，就可以着手修改aosp源码。在我们第一次成功编译安卓镜像后，直接修改如下文件： 1vim ./out/target/product/rk3288_box/system/etc/wifi/wpa_supplicant.conf 加入以下WiFi配置内容： 1234567network=&#123; ssid=&quot;digitech&quot; psk=&quot;11111117&quot; key_mgmt=WPA-PSK priority=613 &#125; 这一步完成了默认WiFi的配置，还有一个是安卓系统在设置界面中默认的WiFi按钮是关闭的，默认开启需要修改以下文件 1vim frameworks/base/packages/SettingsProvider/res/values/defaults.xml 将 1&lt;bool name=&quot;def_wifi_on&quot;&gt;false&lt;/bool&gt; 改为 12&lt;bool name=&quot;def_wifi_on&quot;&gt;true&lt;/bool&gt; 完成后编译&amp;烧录，然后查看/data/misc/wifi/wpa_supplicant.conf是否已经有了刚才预置的内容。 默认启用无线调试如果不通过修改aosp源码的方式，我们启用WiFi Debug的步骤一般是这样的： 1234su mount -o rw,remount /echo service.adb.tcp.port=5555 &gt;&gt; /system/build.prop 随后重启系统，连接到WiFi就可以进行无线调试了。 可以看到关键点在于/system/build.prop这个文件，如何将service.adb.tcp.port=5555在编译阶段就预置进去。 如下： 1vim build/tools/buildinfo.sh 在 1echo &quot;# end build properties&quot; 之前增加 1echo &quot;service.adb.tcp.port=5555&quot; 即可。 最后再记录一下编译安卓固件流程1234. build/envsetup.shlunch./make_script.sh","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://lison.cc/categories/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://lison.cc/tags/AOSP/"}],"author":"Lison"},{"title":"Ubuntu 20.04设置虚拟内存","slug":"ubuntu-extend-memory-swapfile","date":"2024-04-03T02:33:48.000Z","updated":"2024-04-03T05:22:51.448Z","comments":true,"path":"ubuntu-extend-memory-swapfile/","link":"","permalink":"https://lison.cc/ubuntu-extend-memory-swapfile/","excerpt":"编译鸿蒙4.0源码，16G内存吸干，不增加硬件的前提下，试下扩展虚拟内存。","text":"编译鸿蒙4.0源码，16G内存吸干，不增加硬件的前提下，试下扩展虚拟内存。 1. 首先保证拥有足够的磁盘空间，虚拟内存不就是交换的磁盘空间，牺牲时间换取空间（打工不就是人肉换猪肉，我对这片土地没有任何感情）1df -h #查看你的分区有足够的空间 2. 查看现有的虚拟内存1free -h 3. 创建虚拟内存配置文件12345678910111213141516mkdir swap &amp;&amp; cd swap# bs为块的大小, count为创建多少个块（我扩展了16G 16*1024）sudo dd if=/dev/zero of=swapfile bs=1M count=16384# 修改权限sudo chmod 0600 swapfile# 把生成的文件转换成swap文件sudo mkswap swapfile# 激活文件sudo swapon swapfile# 释放文件（如果需要的话）sudo swapoff swapfile 4. 完成后再次查看虚拟内存1free -h 5. 开机自动挂载虚拟内存123456sudo vim /etc/fstab# 增加如下 [虚拟内存文件路径] swap swap defaults 0 0# 比如我的路径/home/lison/swap/swapfile swap swap defaults 0 0 6. 完成","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lison.cc/categories/Linux/"}],"tags":[{"name":"虚拟内存","slug":"虚拟内存","permalink":"https://lison.cc/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"}],"author":"Lison"},{"title":"Linux Shell 使用一条命令批量重命名文件","slug":"linux-shell-ls-xargs","date":"2024-03-27T09:45:07.000Z","updated":"2024-03-28T01:17:15.509Z","comments":true,"path":"linux-shell-ls-xargs/","link":"","permalink":"https://lison.cc/linux-shell-ls-xargs/","excerpt":"","text":"假如一个文件夹中有这样的文件 123451.patch2.patch3.patch...n.patch 需要将他们命名为 123451.patch.bak2.patch.bak3.patch.bak...n.patch.bak 你不会想写个for循环什么的吧。。。用下面这条xargs组合靓命令即可解决 1ls *.patch | xargs -I &#123;&#125; mv &#123;&#125; &#123;&#125;.bak xargs会取ls的每一个输出，并将其替换为{}，然后执行后面的命令。这样，每个文件都会被单独处理。 如果你想批量为他们修改权限，则可以这样写(只是举个栗子) 1ls *.patch | xargs -I &#123;&#125; chmod 644 &#123;&#125;","categories":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"https://lison.cc/categories/Linux-Shell/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://lison.cc/tags/bash/"}],"author":"Lison"},{"title":"LOOK BACK in 2023","slug":"look-back-in-2023","date":"2023-12-06T09:51:13.000Z","updated":"2023-12-07T02:23:13.131Z","comments":true,"path":"look-back-in-2023/","link":"","permalink":"https://lison.cc/look-back-in-2023/","excerpt":"","text":"2023 This year what have I done Make the new record that change my job from 3 company in one year Got my baby daughter born Have flied my RC-plane by more than 5 times and crashed and fixed and on Known Hiba :) 2024 What I would do Passing the internship period of new company Have a successful take off and landing of my RC-plane with no crash Attend my friends wedding ceremony if he would marry","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://lison.cc/tags/%E5%9B%9E%E9%A1%BE/"}],"author":"Lison"},{"title":"OpenHarmony鸿蒙系统移植rk3288过程记录","slug":"harmony-porting-digitech-board","date":"2023-11-16T06:54:26.000Z","updated":"2024-03-27T09:44:33.478Z","comments":true,"path":"harmony-porting-digitech-board/","link":"","permalink":"https://lison.cc/harmony-porting-digitech-board/","excerpt":"我的熟悉路径(粗粮版) 能够编译linux4.19内核，生成img文件，并在虚拟机上更新（如何） 能够编译安卓系统，并能够刷在手机上（红米6） 能够编译鸿蒙系统，移植在rk3288芯片上","text":"我的熟悉路径(粗粮版) 能够编译linux4.19内核，生成img文件，并在虚拟机上更新（如何） 能够编译安卓系统，并能够刷在手机上（红米6） 能够编译鸿蒙系统，移植在rk3288芯片上 todo 目前首先需要编译linux4.19内核 似乎进行到：F:\\rk3288\\软件开发文档\\RockChip_Uboot开发文档V1.0.pdf 其中的编译步骤 似乎又进行到：F:\\rk3288\\DLT-RK3288B_V03用户手册.pdf 其中的4.1 编译 Android 5.1 源码。dtb文件报语法错误，猜测需要重新生成设备树文件？ [keystone] - 将上述编译之前的编译调通即可得到.bin和uboot.img文件 进行到 大骆驼的源码使用的linux kernel是3.x版本；而caesar wang 源码仓库中rk3288适配的是4.19.x版本， 尝试单独使用rockchip-kernel4.4.x编译boot.img, 然后与大骆驼生成的img合并，再尝试刷机。。 使用OpenHarmony4.0Release版本源码配合官网步骤进行，尝试编源代码(https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-pkg-sourcecode.md/) 同步使用github中的Rockchip-kernel4.4版本（含rk3288芯片支持）linux内核源码，尝试编译boot.img(https://github.com/rockchip-linux/kernel/tree/develop-4.4) 使用caesar wang的linux kernel4.19(https://gitee.com/caesar-wang/openharmony-rockchip/issues/I45DEB) 编译内核，修正dts设备目录树错误 9.0 首先下载对应的arm交叉编译工具链，目前我用的是arm-eabi- 9.1 make mrproper 9.2 alias mgcc2=’make CROSS_COMPILE=arm-eabi-‘ 9.3 mgcc2 ARCH=arm rockchip_linux_defconfig 9.4 mgcc2 ARCH=arm digitech-rk3288.img -j$(nproc) 9.5 mgcc2 ARCH=arm digitech-rk3288.img -j$(nproc) uImage 生成uImage，编译成功后会在arch/arm/boot/下生成uImage文件,这就是我们需要的内核Image文件 完成第9步即可在根路径下生成boot.img, kernel.img, resource.img, zboot.img，如图: 引用 Linux 内核下载 Linux 内核动手编译实用指南 Linux 内核编译与安装（完整过程） OpenHarmony鸿蒙内核Liteos-a最小系统移植教程(IMX6ULL开发板) OpenHarmony教程 Rockchip快速上手OpenHarmony L2 caesar wang / kernel-4.19 Rockchip Kernel4.19的开发，目前主要支持 RK3566/RK3568/RV1126/1109/RK3399/RK3326/rk3288/PX30/RK3399Pro等芯片 Linux内核映像vmlinux、Image、zImage、uImage区别 什么是uboot？uboot有什么用？ 嵌入式Linux移植和Uboot（一）：Bootloader介绍，U-boot介绍（特点，目录结构） Google官方编译安卓系统的准备工作 Google官方搭建编译环境 ARM-Linux 交叉编译工具链安装 瑞芯微芯片 RK3036, RK3066, RK312X, RK3188, RK322X,RK3288, RK3328, RK3368, RK3399, PX30使用的linux kernel官方编译手册及代码仓库 内核移植开发板通用流程 - 移植Linux 6.3.5系统到imx6ull开发板 arm 交叉编译器各种gcc 傻傻分不清楚：gnueabi,gnueabhf,none-eaib ARM工具链选择参考 嵌入式Linux系统移植的四大步骤 详解三大编译器：gcc、llvm 和 clang ohos内核,initrd,设备树启动说明 Linux kernel 编译方法大全记录","categories":[{"name":"linux操作系统编译移植","slug":"linux操作系统编译移植","permalink":"https://lison.cc/categories/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/"}],"tags":[{"name":"linux kernel 编译","slug":"linux-kernel-编译","permalink":"https://lison.cc/tags/linux-kernel-%E7%BC%96%E8%AF%91/"},{"name":"鸿蒙系统移植","slug":"鸿蒙系统移植","permalink":"https://lison.cc/tags/%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"}],"author":"Lison"},{"title":"给他完整的一生之 • 那年的笔记本键盘","slug":"assemble-old-keyboard-with-fpc-26p-n-monkey-drive","date":"2023-06-04T07:51:15.000Z","updated":"2023-11-16T06:15:51.537Z","comments":true,"path":"assemble-old-keyboard-with-fpc-26p-n-monkey-drive/","link":"","permalink":"https://lison.cc/assemble-old-keyboard-with-fpc-26p-n-monkey-drive/","excerpt":"陪伴你多年的退役笔记本还在吃灰吗，还是被你拿去换不锈钢盆了呢。今天我要把我的这一款坏掉笔记本的键盘拆解，重新组装，给他完整的一生。","text":"陪伴你多年的退役笔记本还在吃灰吗，还是被你拿去换不锈钢盆了呢。今天我要把我的这一款坏掉笔记本的键盘拆解，重新组装，给他完整的一生。 准备材料 废旧笔记本键盘一块 FPC-26P 转接板一块 键盘改装主控板 monkey USB V1.0","categories":[],"tags":[],"author":"Lison"},{"title":"记一次失败经历 Arduino UNO 使用 L298N 驱动直流电机","slug":"arduino-l298n-drive-dc-motor","date":"2023-05-14T06:59:29.000Z","updated":"2023-11-16T06:15:51.531Z","comments":true,"path":"arduino-l298n-drive-dc-motor/","link":"","permalink":"https://lison.cc/arduino-l298n-drive-dc-motor/","excerpt":"打算是要给多年前的遥控玩具车完整的一生，尸体只保留了车架子跟两个马达，后驱的车轴部分跟轮胎都找不到了，先上一段失败的成品演示。","text":"打算是要给多年前的遥控玩具车完整的一生，尸体只保留了车架子跟两个马达，后驱的车轴部分跟轮胎都找不到了，先上一段失败的成品演示。 需求 使用已经吃灰的一个电视盒子遥控器发射红外信号（NEC协议） 接收到红外指令后可以完成前后左右四个方向动作 配件 Arduino Uno L298N驱动板 两个直流小马达 红外接收头1838一只（从吃灰的DVD上拆的。。） 某支持NEC协议的红外遥控器一个 杜邦线 接线图 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/* * SimpleReceiver.cpp * * Demonstrates receiving NEC IR codes with IRremote * * This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote. * ************************************************************************************ * MIT License * * Copyright (c) 2020-2022 Armin Joachimsmeyer * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the &quot;Software&quot;), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished * to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * ************************************************************************************ *//* * Specify which protocol(s) should be used for decoding. * If no protocol is defined, all protocols (except Bang&amp;Olufsen) are active. * This must be done before the #include &lt;IRremote.hpp&gt; *///#define DECODE_DENON // Includes Sharp//#define DECODE_JVC//#define DECODE_KASEIKYO//#define DECODE_PANASONIC // alias for DECODE_KASEIKYO//#define DECODE_LG#define DECODE_NEC // Includes Apple and Onkyo//#define DECODE_SAMSUNG//#define DECODE_SONY//#define DECODE_RC5//#define DECODE_RC6//#define DECODE_BOSEWAVE//#define DECODE_LEGO_PF//#define DECODE_MAGIQUEST//#define DECODE_WHYNTER//#define DECODE_FAST//#define DECODE_DISTANCE_WIDTH // Universal decoder for pulse distance width protocols//#define DECODE_HASH // special decoder for all protocols//#define DECODE_BEO // This protocol must always be enabled manually, i.e. it is NOT enabled if no protocol is defined. It prevents decoding of SONY!//#define DEBUG // Activate this for lots of lovely debug output from the decoders.//#define RAW_BUFFER_LENGTH 180 // Default is 112 if DECODE_MAGIQUEST is enabled, otherwise 100.#include &lt;Arduino.h&gt;#include &quot;PinDefinitionsAndMore.h&quot; // Define macros for input and output pin etc.#include &lt;IRremote.hpp&gt;//todo 控制直流电机 https://blog.csdn.net/ling3ye/article/details/51351115int input1 = 5; // 定义uno的pin 5 向 input1 输出 int input2 = 6; // 定义uno的pin 6 向 input2 输出int input3 = 9; // 定义uno的pin 9 向 input3 输出int input4 = 10; // 定义uno的pin 10 向 input4 输出 void setup() &#123; Serial.begin(9600); // Just to know which program is running on my Arduino Serial.println(F(&quot;START &quot; __FILE__ &quot; from &quot; __DATE__ &quot;\\r\\nUsing library version &quot; VERSION_IRREMOTE)); // Start the receiver and if not 3. parameter specified, take LED_BUILTIN pin from the internal boards definition as default feedback LED IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK); Serial.print(F(&quot;Ready to receive IR signals of protocols: &quot;)); printActiveIRProtocols(&amp;Serial); Serial.println(F(&quot;at pin &quot; STR(IR_RECEIVE_PIN))); pinMode(input1,OUTPUT); pinMode(input2,OUTPUT); pinMode(input3,OUTPUT); pinMode(input4,OUTPUT);&#125;void loop() &#123; /* * Check if received data is available and if yes, try to decode it. * Decoded result is in the IrReceiver.decodedIRData structure. * * E.g. command is in IrReceiver.decodedIRData.command * address is in command is in IrReceiver.decodedIRData.address * and up to 32 bit raw data in IrReceiver.decodedIRData.decodedRawData */ if (IrReceiver.decode()) &#123; /* * Print a short summary of received data */ IrReceiver.printIRResultShort(&amp;Serial); IrReceiver.printIRSendUsage(&amp;Serial); if (IrReceiver.decodedIRData.protocol == UNKNOWN) &#123; Serial.println(F(&quot;Received noise or an unknown (or not yet enabled) protocol&quot;)); // We have an unknown protocol here, print more info IrReceiver.printIRResultRawFormatted(&amp;Serial, true); &#125; Serial.println(); /* * Finally, check the received data and perform actions according to the received command */ if (IrReceiver.decodedIRData.command == 0x11) &#123; // do something Serial.println(&quot;left&quot;); digitalWrite(input3,HIGH); //给高电平 digitalWrite(input4,LOW); //给低电平 &#125; else if (IrReceiver.decodedIRData.command == 0x12) &#123; // do something else Serial.println(&quot;right&quot;); digitalWrite(input3,LOW); //给高电平 digitalWrite(input4,HIGH); //给低电平 &#125; else if (IrReceiver.decodedIRData.command == 0x13) &#123; // do something else Serial.println(&quot;up&quot;); digitalWrite(input1,LOW); digitalWrite(input2,HIGH); &#125; else if (IrReceiver.decodedIRData.command == 0x14) &#123; // do something else Serial.println(&quot;down&quot;); //forward 向前转 digitalWrite(input1,HIGH); //给高电平 digitalWrite(input2,LOW); //给低电平 &#125;else&#123; Serial.println(&quot;...&quot;); delay(200); digitalWrite(input1,LOW); digitalWrite(input2,LOW); digitalWrite(input3,LOW); digitalWrite(input4,LOW); &#125; /* * !!!Important!!! Enable receiving of the next value, * since receiving has stopped after the end of the current received data packet. */ IrReceiver.resume(); // Enable receiving of the next value &#125;&#125; PinDefinitionsAndMore.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323/* * PinDefinitionsAndMore.h * * Contains pin definitions for IRremote examples for various platforms * as well as definitions for feedback LED and tone() and includes * * Copyright (C) 2021-2022 Armin Joachimsmeyer * armin.joachimsmeyer@gmail.com * * This file is part of IRremote https://github.com/Arduino-IRremote/Arduino-IRremote. * * Arduino-IRremote is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program. If not, see &lt;http://www.gnu.org/licenses/gpl.html&gt;. * *//* * Pin mapping table for different platforms * * Platform IR input IR output Tone Core/Pin schema * -------------------------------------------------------------- * DEFAULT/AVR 2 3 4 Arduino * ATtinyX5 0|PB0 4|PB4 3|PB3 ATTinyCore * ATtiny167 3|PA3 2|PA2 7|PA7 ATTinyCore * ATtiny167 9|PA3 8|PA2 5|PA7 Digispark pro * ATtiny3217 18|PA1 19|PA2 20|PA3 MegaTinyCore * ATtiny1604 2 3|PA5 % * ATtiny816 14|PA1 16|PA3 1|PA5 MegaTinyCore * ATtiny1614 8|PA1 10|PA3 1|PA5 MegaTinyCore * SAMD21 3 4 5 * ESP8266 14|D5 12|D6 % * ESP32 15 4 27 * BluePill PA6 PA7 PA3 * APOLLO3 11 12 5 * RP2040 3|GPIO15 4|GPIO16 5|GPIO17 *///#define _IR_MEASURE_TIMING // For debugging purposes.#if defined(__AVR__)#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__) // Digispark board#include &quot;ATtinySerialOut.hpp&quot; // TX is at pin 2 - Available as Arduino library &quot;ATtinySerialOut&quot;. Saves 700 bytes program memory and 70 bytes RAM for ATtinyCore#define IR_RECEIVE_PIN 0#define IR_SEND_PIN 4 // Pin 2 is serial output with ATtinySerialOut. Pin 1 is internal LED and Pin3 is USB+ with pullup on Digispark board.#define TONE_PIN 3#define _IR_TIMING_TEST_PIN 3# elif defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__) // Digispark pro board#include &quot;ATtinySerialOut.hpp&quot; // Available as Arduino library &quot;ATtinySerialOut&quot;// For ATtiny167 Pins PB6 and PA3 are usable as interrupt source.# if defined(ARDUINO_AVR_DIGISPARKPRO)#define IR_RECEIVE_PIN 9 // PA3 - on Digispark board labeled as pin 9//#define IR_RECEIVE_PIN 14 // PB6 / INT0 is connected to USB+ on DigisparkPro boards#define IR_SEND_PIN 8 // PA2 - on Digispark board labeled as pin 8#define TONE_PIN 5 // PA7 - on Digispark board labeled as pin 5#define _IR_TIMING_TEST_PIN 10 // PA4# else#define IR_RECEIVE_PIN 3 // PA3 - on Digispark board labeled as pin 9#define IR_SEND_PIN 2 // PA2 - on Digispark board labeled as pin 8#define TONE_PIN 7 // PA7 - on Digispark board labeled as pin 5# endif# elif defined(__AVR_ATtiny88__) // MH-ET Tiny88 board#include &quot;ATtinySerialOut.hpp&quot; // Available as Arduino library &quot;ATtinySerialOut&quot;. Saves 128 bytes program memory// Pin 6 is TX pin 7 is RX#define IR_RECEIVE_PIN 3 // INT1#define IR_SEND_PIN 4#define TONE_PIN 9#define _IR_TIMING_TEST_PIN 8# elif defined(__AVR_ATtiny1616__) || defined(__AVR_ATtiny3216__) || defined(__AVR_ATtiny3217__) // Tiny Core Dev board#define IR_RECEIVE_PIN 18#define IR_SEND_PIN 19#define TONE_PIN 20#define APPLICATION_PIN 0 // PA4#undef LED_BUILTIN // No LED available on the TinyCore 32 board, take the one on the programming board which is connected to the DAC output#define LED_BUILTIN 2 // PA6# elif defined(__AVR_ATtiny816__) // Tiny Core Micro#define IR_RECEIVE_PIN 14 // PA1#define IR_SEND_PIN 16 // PA3#define TONE_PIN 1 // PA5#define APPLICATION_PIN 0 // PA4#undef LED_BUILTIN // No LED available, take the one which is connected to the DAC output#define LED_BUILTIN 4 // PB5# elif defined(__AVR_ATtiny1614__)#define IR_RECEIVE_PIN 8 // PA1#define IR_SEND_PIN 10 // PA3#define TONE_PIN 1 // PA5#define APPLICATION_PIN 0 // PA4# elif defined(__AVR_ATtiny1604__)#define IR_RECEIVE_PIN 2 // To be compatible with interrupt example, pin 2 is chosen here.#define IR_SEND_PIN 3#define APPLICATION_PIN 5#define tone(...) void() // Define as void, since TCB0_INT_vect is also used by tone()#define noTone(a) void()#define TONE_PIN 42 // Dummy for examples using it# elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) \\|| defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \\|| defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \\|| defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \\|| defined(__AVR_ATmega164P__) || defined(__AVR_ATmega32__) \\|| defined(__AVR_ATmega16__) || defined(__AVR_ATmega8535__) \\|| defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) \\|| defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__) \\|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__)#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 13#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7# else // Default as for ATmega328 like on Uno, Nano, Leonardo, Teensy 2.0 etc.#define IR_RECEIVE_PIN 2 // To be compatible with interrupt example, pin 2 is chosen here.#define IR_SEND_PIN 3#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7# if defined(ARDUINO_AVR_PROMICRO) // Sparkfun Pro Micro is __AVR_ATmega32U4__ but has different external circuit// We have no built in LED at pin 13 -&gt; reuse RX LED#undef LED_BUILTIN#define LED_BUILTIN LED_BUILTIN_RX# endif# endif // defined(__AVR_ATtiny25__)...#elif defined(ESP8266)#define FEEDBACK_LED_IS_ACTIVE_LOW // The LED on my board (D4) is active LOW#define IR_RECEIVE_PIN 14 // D5#define IR_SEND_PIN 12 // D6 - D4/pin 2 is internal LED#define _IR_TIMING_TEST_PIN 2 // D4#define APPLICATION_PIN 13 // D7#define tone(...) void() // tone() inhibits receive timer#define noTone(a) void()#define TONE_PIN 42 // Dummy for examples using it#elif defined(CONFIG_IDF_TARGET_ESP32C3)#define IR_INPUT_PIN 8#define IR_SEND_PIN 9#define TONE_PIN 10 // ADC2_0#define APPLICATION_PIN 11#elif defined(ESP32)#include &lt;Arduino.h&gt;// tone() is included in ESP32 core since 2.0.2#if !defined(ESP_ARDUINO_VERSION_VAL)#define ESP_ARDUINO_VERSION_VAL(major, minor, patch) 12345678#endif#if ESP_ARDUINO_VERSION &lt;= ESP_ARDUINO_VERSION_VAL(2, 0, 2)#define TONE_LEDC_CHANNEL 1 // Using channel 1 makes tone() independent of receiving timer -&gt; No need to stop receiving timer.void tone(uint8_t aPinNumber, unsigned int aFrequency)&#123; ledcAttachPin(aPinNumber, TONE_LEDC_CHANNEL); ledcWriteTone(TONE_LEDC_CHANNEL, aFrequency);&#125;void tone(uint8_t aPinNumber, unsigned int aFrequency, unsigned long aDuration)&#123; ledcAttachPin(aPinNumber, TONE_LEDC_CHANNEL); ledcWriteTone(TONE_LEDC_CHANNEL, aFrequency); delay(aDuration); ledcWriteTone(TONE_LEDC_CHANNEL, 0);&#125;void noTone(uint8_t aPinNumber)&#123; ledcWriteTone(TONE_LEDC_CHANNEL, 0);&#125;#endif // ESP_ARDUINO_VERSION &lt;= ESP_ARDUINO_VERSION_VAL(2, 0, 2)#define IR_RECEIVE_PIN 15 // D15#define IR_SEND_PIN 4 // D4#define TONE_PIN 27 // D27 25 &amp; 26 are DAC0 and 1#define APPLICATION_PIN 16 // RX2 pin#elif defined(ARDUINO_ARCH_STM32) || defined(ARDUINO_ARCH_STM32F1) // BluePill// Timer 3 blocks PA6, PA7, PB0, PB1 for use by Servo or tone()#define IR_RECEIVE_PIN PA6#define IR_RECEIVE_PIN_STRING &quot;PA6&quot;#define IR_SEND_PIN PA7#define IR_SEND_PIN_STRING &quot;PA7&quot;#define TONE_PIN PA3#define _IR_TIMING_TEST_PIN PA5#define APPLICATION_PIN PA2#define APPLICATION_PIN_STRING &quot;PA2&quot;# if defined(ARDUINO_GENERIC_STM32F103C) || defined(ARDUINO_BLUEPILL_F103C8)// BluePill LED is active low#define FEEDBACK_LED_IS_ACTIVE_LOW# endif#elif defined(ARDUINO_ARCH_APOLLO3) // Sparkfun Apollo boards#define IR_RECEIVE_PIN 11#define IR_SEND_PIN 12#define TONE_PIN 5#elif defined(ARDUINO_ARCH_MBED) &amp;&amp; defined(ARDUINO_ARCH_MBED_NANO) // Arduino Nano 33 BLE#define IR_RECEIVE_PIN 3 // GPIO15 Start with pin 3 since pin 2|GPIO25 is connected to LED on Pi pico#define IR_SEND_PIN 4 // GPIO16#define TONE_PIN 5#define APPLICATION_PIN 6#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 7 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 8#elif defined(ARDUINO_ARCH_RP2040) // Arduino Nano Connect, Pi Pico with arduino-pico core https://github.com/earlephilhower/arduino-pico#define IR_RECEIVE_PIN 15 // GPIO15 to be compatible with the Arduino Nano RP2040 Connect (pin3)#define IR_SEND_PIN 16 // GPIO16#define TONE_PIN 17#define APPLICATION_PIN 18#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 19 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 20// If you program the Nano RP2040 Connect with this core, then you must redefine LED_BUILTIN// and use the external reset with 1 kOhm to ground to enter UF2 mode#undef LED_BUILTIN#define LED_BUILTIN 6#elif defined(PARTICLE) // !!!UNTESTED!!!#define IR_RECEIVE_PIN A4#define IR_SEND_PIN A5 // Particle supports multiple pins#define LED_BUILTIN D7/* * 4 times the same (default) layout for easy adaption in the future */#elif defined(TEENSYDUINO) // Teensy 2.0 is handled at default for ATmega328 like on Uno, Nano, Leonardo etc.#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 3#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7#elif defined(ARDUINO_ARCH_MBED) // Arduino Nano 33 BLE#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 3#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7#elif defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_SAM)#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 3#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7#if !defined(ARDUINO_SAMD_ADAFRUIT)// On the Zero and others we switch explicitly to SerialUSB#define Serial SerialUSB#endif// Definitions for the Chinese SAMD21 M0-Mini clone, which has no led connected to D13/PA17.// Attention!!! D2 and D4 are swapped on these boards!!!// If you connect the LED, it is on pin 24/PB11. In this case activate the next two lines.//#undef LED_BUILTIN//#define LED_BUILTIN 24 // PB11// As an alternative you can choose pin 25, it is the RX-LED pin (PB03), but active low.In this case activate the next 3 lines.//#undef LED_BUILTIN//#define LED_BUILTIN 25 // PB03//#define FEEDBACK_LED_IS_ACTIVE_LOW // The RX LED on the M0-Mini is active LOW#elif defined (NRF51) // BBC micro:bit#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 3#define APPLICATION_PIN 1#define _IR_TIMING_TEST_PIN 4#define tone(...) void() // no tone() available#define noTone(a) void()#define TONE_PIN 42 // Dummy for examples using it#else#warning Board / CPU is not detected using pre-processor symbols -&gt; using default values, which may not fit. Please extend PinDefinitionsAndMore.h.// Default valued for unidentified boards#define IR_RECEIVE_PIN 2#define IR_SEND_PIN 3#define TONE_PIN 4#define APPLICATION_PIN 5#define ALTERNATIVE_IR_FEEDBACK_LED_PIN 6 // E.g. used for examples which use LED_BUILDIN for example output.#define _IR_TIMING_TEST_PIN 7#endif // defined(ESP8266)#if defined(ESP32) || defined(ARDUINO_ARCH_RP2040) || defined(PARTICLE) || defined(ARDUINO_ARCH_MBED)#define SEND_PWM_BY_TIMER // We do not have pin restrictions for this CPU&#x27;s, so lets use the hardware PWM for send carrier signal generation#else# if defined(SEND_PWM_BY_TIMER)#undef IR_SEND_PIN // SendPin is determined by timer! This avoids warning in IRTimer.hpp# endif#endif#if !defined (FLASHEND)#define FLASHEND 0xFFFF // Dummy value for platforms where FLASHEND is not defined#endif#if !defined (RAMEND)#define RAMEND 0xFFFF // Dummy value for platforms where RAMEND is not defined#endif#if !defined (RAMSIZE)#define RAMSIZE 0xFFFF // Dummy value for platforms where RAMSIZE is not defined#endif/* * Helper macro for getting a macro definition as string */#if !defined(STR_HELPER)#define STR_HELPER(x) #x#define STR(x) STR_HELPER(x)#endif 测试红外程序运行后，对着红外接收头按下遥控器，Arduino 串口监视器会打印到下图的信息： 12345678910Protocol=NEC Address=0xBF00 Command=0x12 Raw-Data=0xED12BF00 32 bits LSB firstSend with: IrSender.sendNEC(0xBF00, 0x12, &lt;numberOfRepeats&gt;);rightProtocol=NEC Address=0xBF00 Command=0x11 Raw-Data=0xEE11BF00 32 bits LSB firstSend with: IrSender.sendNEC(0xBF00, 0x11, &lt;numberOfRepeats&gt;);leftProtocol=NEC Address=0xBF00 Command=0x12 Raw-Data=0xED12BF00 32 bits LSB firstSend with: IrSender.sendNEC(0xBF00, 0x12, &lt;numberOfRepeats&gt;); 只需根据 1IrReceiver.decodedIRData.command 来判断按下的是哪个键，然后对直流电机进行控制。 最后小车没有跑起来，虽然方向与前进后退都可以控制，可能是齿轮配比或者摩擦系数问题。原先的小车进行左右拐弯之后还有一个机械装置自动回正方向，时间长了这个部件也丢了。就是一次学习的经历了。","categories":[{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/categories/arduino/"}],"tags":[{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/tags/arduino/"}],"author":"Lison"},{"title":"树莓派4B驱动喂鱼器","slug":"raspberry-pi-drive-fishfeeder","date":"2023-04-07T08:51:27.000Z","updated":"2023-11-16T06:15:51.668Z","comments":true,"path":"raspberry-pi-drive-fishfeeder/","link":"","permalink":"https://lison.cc/raspberry-pi-drive-fishfeeder/","excerpt":"记得之前有前辈搞过这个项目，隐约记得是用不带WIFI的喂鱼器进行硬件hack，文章找不到了。刚好我也养鱼，刚好我也玩树莓派，刚好把这个过程记录下来。","text":"记得之前有前辈搞过这个项目，隐约记得是用不带WIFI的喂鱼器进行硬件hack，文章找不到了。刚好我也养鱼，刚好我也玩树莓派，刚好把这个过程记录下来。 1. 准备清单 树莓派4B 艾隆达鱼缸喂食器无WIFI款（按一下喂一次） 杜邦线两根 2. Hack喂鱼器123买回来的喂鱼器是两节1.5v电源供电，一个按钮，一个旋转马达加一个鱼食仓，按一下按钮旋转一次，好像也可以长按设置24小时喂食一次或者12小时一次，这些不重要，我要的功能是程序执行一次，即喂食一次的效果 喂鱼器长这样，已经拆掉了鱼食仓 从这个开关引出两条线 像这样 红色与棕色就是引出的两条线，这两条要接到树莓派的引脚上。 2. 接线表 **树莓派针脚** **说明** **喂鱼器** GPIO 26 电源+ GND 电源- 就这两根线，也可以用其他的针脚，看你 3. Python编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import RPi.GPIO as GPIOimport timeimport sysdef feed(): pin = 26 try: args = sys.argv if(len(args)&gt;=2): pin=int(args[1]) except: pass print(&quot;GPIO: &quot; + str(pin)) GPIO.setmode(GPIO.BCM) GPIO.setup(pin, GPIO.OUT) GPIO.output(pin, GPIO.HIGH) time.sleep(0.2) GPIO.output(pin, GPIO.LOW) time.sleep(0.2) GPIO.cleanup() #记录执行次数 filename=time.strftime(&quot;%Y%m%d&quot;) with open(filename,&#x27;a+&#x27;)as f: f.seek(0) line = f.readline() print(line) #清空文件内容 f.seek(0) f.truncate() times = 0 if(len(line)==0): times=1 else: times= int(line) + 1 f.write(str(times)) print(&quot;Times: &quot;+str(times)) 123程序默认使用26针脚，执行一次将在当前路径创建20230403的文件，文件内容记录次数1；如果文件已存在，则将记录次数+1sudo python fishfeeder.py 4. 显示结果上面的程序记录了每天的运行次数，然后用LCD 1602a给显示出来，像这样。 5. TODO 既然程序可控，那我想要远程控制；将程序做成web服务暴露到外网 开一个直播给这个鱼缸，可以看到鱼、喂鱼器的动作以及LCD屏幕显示的信息 收到点赞或者刷礼物或者什么的时候LCD显示关联信息，并执行一次喂鱼，让互动看得见 鱼脸识别？领养？再说吧~","categories":[{"name":"loT","slug":"loT","permalink":"https://lison.cc/categories/loT/"}],"tags":[{"name":"RPi","slug":"RPi","permalink":"https://lison.cc/tags/RPi/"},{"name":"物联网","slug":"物联网","permalink":"https://lison.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}],"author":"Lison"},{"title":"树莓派4B直插LCD 1602a实践","slug":"raspberry-pi-drive-lcd1602a","date":"2023-04-02T01:48:07.000Z","updated":"2023-11-16T06:15:51.671Z","comments":true,"path":"raspberry-pi-drive-lcd1602a/","link":"","permalink":"https://lison.cc/raspberry-pi-drive-lcd1602a/","excerpt":"找出来吃灰多年的 LCD 1602a 液晶屏，记得之前用树莓派 3B 驱动过，那时没做记录全都忘记了，今天用树莓派 4B 直插 LCD 1602a 看看效果。网上的资料很多都是使用 I2C 方式驱动，需要 I2C 模块，好处是接线与配置都简单，而我穷的没有。。。","text":"找出来吃灰多年的 LCD 1602a 液晶屏，记得之前用树莓派 3B 驱动过，那时没做记录全都忘记了，今天用树莓派 4B 直插 LCD 1602a 看看效果。网上的资料很多都是使用 I2C 方式驱动，需要 I2C 模块，好处是接线与配置都简单，而我穷的没有。。。 12LCD 1602a 拥有单行显示 16 个字符，总共两行显示空间（所以叫 1602），在一些显示规格要求不高的场景应用还是很多的。 1. 准备清单 树莓派 4B LCD 1602a 面包板 杜邦线几根 2. 人家的接线方式 **LCD 针脚** **说明** **接线** **树莓派针脚** 01 VSS (GND) Breadboard GND（面包板接地） 02 VDD (+5v) Breadboard +5v（面包板5V） 03 VO (Contrast，显示对比度调整) Middle Pin Trimmer（接电位器中间线） 04 RS GPIO7 26 05 RW Breadboard GND 06 E GPIO8 24 07 D0 08 D1 09 D2 10 D3 11 D4 GPIO25 22 12 D5 GPIO24 18 13 D6 GPIO23 16 14 D7 GPIO18 12 15 A (+5V) Breadboard +5v 16 K (GND) Breadboard GND 参考的接线图 3. 我的接线方式 既然提到了电位器，我依然没有，但是电位器不就是可调电阻吗，资料上说接5V然后调整，那我直接供3.3V行不行呢？ 这是我的接线图 **LCD 针脚** **说明** **接线** **树莓派针脚** 01 VSS (GND) Breadboard GND（面包板接地） 02 VDD (+5v) Breadboard +3.3V（面包板3.3V） 03 VO (Contrast) Breadboard GND（面包板接地，与3.3V） 04 RS GPIO7 26 05 RW Breadboard GND 06 E GPIO8 24 07 D0 08 D1 09 D2 10 D3 11 D4 GPIO25 22 12 D5 GPIO24 18 13 D6 GPIO23 16 14 D7 GPIO18 12 15 A (+5V) Breadboard +5v 16 K (GND) Breadboard GND 12本来想用Fritzing画一下我的接线方式，怎知Fritzing元件库里竟然没有树莓派4B。。那就只好来个凌乱一点的手机照了 123123就对应的VSS VDD VO，接到了3.3v与GND，其他都一样，是为了控制显示对比度，调太高的话看不清，太低的话看不清，那我这里直接给个固定值 4. Python 编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325# MBTechWorks.com 2016# Control an LCD 1602 display from Raspberry Pi with Python programming#!/usr/bin/python# Pinout of the LCD:# 1 : GND# 2 : 5V power# 3 : Display contrast - Connect to middle pin potentiometer # 4 : RS (Register Select)# 5 : R/W (Read Write) - Ground this pin (important)# 6 : Enable or Strobe# 7 : Data Bit 0 - data pin 0, 1, 2, 3 are not used# 8 : Data Bit 1 - # 9 : Data Bit 2 - # 10: Data Bit 3 - # 11: Data Bit 4# 12: Data Bit 5# 13: Data Bit 6# 14: Data Bit 7# 15: LCD Backlight +5V# 16: LCD Backlight GNDimport RPi.GPIO as GPIOimport time# GPIO to LCD mappingLCD_RS = 7 # Pi pin 26LCD_E = 8 # Pi pin 24LCD_D4 = 25 # Pi pin 22LCD_D5 = 24 # Pi pin 18LCD_D6 = 23 # Pi pin 16LCD_D7 = 18 # Pi pin 12# Device constantsLCD_CHR = True # Character modeLCD_CMD = False # Command modeLCD_CHARS = 16 # Characters per line (16 max)LCD_LINE_1 = 0x80 # LCD memory location for 1st lineLCD_LINE_2 = 0xC0 # LCD memory location 2nd line# Define main program codedef main(): GPIO.setwarnings(False) GPIO.setmode(GPIO.BCM) # Use BCM GPIO numbers GPIO.setup(LCD_E, GPIO.OUT) # Set GPIO&#x27;s to output mode GPIO.setup(LCD_RS, GPIO.OUT) GPIO.setup(LCD_D4, GPIO.OUT) GPIO.setup(LCD_D5, GPIO.OUT) GPIO.setup(LCD_D6, GPIO.OUT) GPIO.setup(LCD_D7, GPIO.OUT)# Initialize display lcd_init()# Loop - send text and sleep 3 seconds between texts# Change text to anything you wish, but must be 16 characters or less while True: lcd_text(&quot;Hello World!&quot;,LCD_LINE_1) lcd_text(&quot;&quot;,LCD_LINE_2) lcd_text(&quot;Rasbperry Pi&quot;,LCD_LINE_1) lcd_text(&quot;16x2 LCD Display&quot;,LCD_LINE_2) time.sleep(2) # 3 second delay lcd_text(&quot;ABCDEFGHIJKLMNOP&quot;,LCD_LINE_1) lcd_text(&quot;1234567890123456&quot;,LCD_LINE_2) time.sleep(2) # 3 second delay lcd_text(&quot;I love my&quot;,LCD_LINE_1) lcd_text(&quot;Raspberry Pi!&quot;,LCD_LINE_2) time.sleep(2) lcd_text(&quot;lison.cc&quot;,LCD_LINE_1) lcd_text(&quot;For more R Pi&quot;,LCD_LINE_2) time.sleep(2)# End of main program code# Initialize and clear displaydef lcd_init(): lcd_write(0x33,LCD_CMD) # Initialize lcd_write(0x32,LCD_CMD) # Set to 4-bit mode lcd_write(0x06,LCD_CMD) # Cursor move direction lcd_write(0x0C,LCD_CMD) # Turn cursor off lcd_write(0x28,LCD_CMD) # 2 line display lcd_write(0x01,LCD_CMD) # Clear display time.sleep(0.0005) # Delay to allow commands to processdef lcd_write(bits, mode):# High bits GPIO.output(LCD_RS, mode) # RS GPIO.output(LCD_D4, False) GPIO.output(LCD_D5, False) GPIO.output(LCD_D6, False) GPIO.output(LCD_D7, False) if bits&amp;0x10==0x10: GPIO.output(LCD_D4, True) if bits&amp;0x20==0x20: GPIO.output(LCD_D5, True) if bits&amp;0x40==0x40: GPIO.output(LCD_D6, True) if bits&amp;0x80==0x80: GPIO.output(LCD_D7, True)# Toggle &#x27;Enable&#x27; pin lcd_toggle_enable()# Low bits GPIO.output(LCD_D4, False) GPIO.output(LCD_D5, False) GPIO.output(LCD_D6, False) GPIO.output(LCD_D7, False) if bits&amp;0x01==0x01: GPIO.output(LCD_D4, True) if bits&amp;0x02==0x02: GPIO.output(LCD_D5, True) if bits&amp;0x04==0x04: GPIO.output(LCD_D6, True) if bits&amp;0x08==0x08: GPIO.output(LCD_D7, True)# Toggle &#x27;Enable&#x27; pin lcd_toggle_enable()def lcd_toggle_enable(): time.sleep(0.0005) GPIO.output(LCD_E, True) time.sleep(0.0005) GPIO.output(LCD_E, False) time.sleep(0.0005)def lcd_text(message,line): # Send text to display message = message.ljust(LCD_CHARS,&quot; &quot;) lcd_write(line, LCD_CMD) for i in range(LCD_CHARS): lcd_write(ord(message[i]),LCD_CHR)#Begin programtry: main() except KeyboardInterrupt: pass finally: lcd_write(0x01, LCD_CMD) lcd_text(&quot;So long!&quot;,LCD_LINE_1) lcd_text(&quot;lison.cc&quot;,LCD_LINE_2) GPIO.cleanup()# MBTechWorks.com 2016# Control an LCD 1602 display from Raspberry Pi with Python programming#!/usr/bin/python# Pinout of the LCD:# 1 : GND# 2 : 5V power# 3 : Display contrast - Connect to middle pin potentiometer # 4 : RS (Register Select)# 5 : R/W (Read Write) - Ground this pin (important)# 6 : Enable or Strobe# 7 : Data Bit 0 - data pin 0, 1, 2, 3 are not used# 8 : Data Bit 1 - # 9 : Data Bit 2 - # 10: Data Bit 3 - # 11: Data Bit 4# 12: Data Bit 5# 13: Data Bit 6# 14: Data Bit 7# 15: LCD Backlight +5V# 16: LCD Backlight GNDimport RPi.GPIO as GPIOimport time# GPIO to LCD mappingLCD_RS = 7 # Pi pin 26LCD_E = 8 # Pi pin 24LCD_D4 = 25 # Pi pin 22LCD_D5 = 24 # Pi pin 18LCD_D6 = 23 # Pi pin 16LCD_D7 = 18 # Pi pin 12# Device constantsLCD_CHR = True # Character modeLCD_CMD = False # Command modeLCD_CHARS = 16 # Characters per line (16 max)LCD_LINE_1 = 0x80 # LCD memory location for 1st lineLCD_LINE_2 = 0xC0 # LCD memory location 2nd line# Define main program codedef main(): GPIO.setwarnings(False) GPIO.setmode(GPIO.BCM) # Use BCM GPIO numbers GPIO.setup(LCD_E, GPIO.OUT) # Set GPIO&#x27;s to output mode GPIO.setup(LCD_RS, GPIO.OUT) GPIO.setup(LCD_D4, GPIO.OUT) GPIO.setup(LCD_D5, GPIO.OUT) GPIO.setup(LCD_D6, GPIO.OUT) GPIO.setup(LCD_D7, GPIO.OUT)# Initialize display lcd_init()# Loop - send text and sleep 3 seconds between texts# Change text to anything you wish, but must be 16 characters or less while True: lcd_text(&quot;Hello World!&quot;,LCD_LINE_1) lcd_text(&quot;&quot;,LCD_LINE_2) lcd_text(&quot;Rasbperry Pi&quot;,LCD_LINE_1) lcd_text(&quot;16x2 LCD Display&quot;,LCD_LINE_2) time.sleep(3) # 3 second delay lcd_text(&quot;ABCDEFGHIJKLMNOP&quot;,LCD_LINE_1) lcd_text(&quot;1234567890123456&quot;,LCD_LINE_2) time.sleep(3) # 3 second delay lcd_text(&quot;I love my&quot;,LCD_LINE_1) lcd_text(&quot;Raspberry Pi!&quot;,LCD_LINE_2) time.sleep(3) lcd_text(&quot;lison.cc&quot;,LCD_LINE_1) lcd_text(&quot;For more R Pi&quot;,LCD_LINE_2) time.sleep(3)# End of main program code# Initialize and clear displaydef lcd_init(): lcd_write(0x33,LCD_CMD) # Initialize lcd_write(0x32,LCD_CMD) # Set to 4-bit mode lcd_write(0x06,LCD_CMD) # Cursor move direction lcd_write(0x0C,LCD_CMD) # Turn cursor off lcd_write(0x28,LCD_CMD) # 2 line display lcd_write(0x01,LCD_CMD) # Clear display time.sleep(0.0005) # Delay to allow commands to processdef lcd_write(bits, mode):# High bits GPIO.output(LCD_RS, mode) # RS GPIO.output(LCD_D4, False) GPIO.output(LCD_D5, False) GPIO.output(LCD_D6, False) GPIO.output(LCD_D7, False) if bits&amp;0x10==0x10: GPIO.output(LCD_D4, True) if bits&amp;0x20==0x20: GPIO.output(LCD_D5, True) if bits&amp;0x40==0x40: GPIO.output(LCD_D6, True) if bits&amp;0x80==0x80: GPIO.output(LCD_D7, True)# Toggle &#x27;Enable&#x27; pin lcd_toggle_enable()# Low bits GPIO.output(LCD_D4, False) GPIO.output(LCD_D5, False) GPIO.output(LCD_D6, False) GPIO.output(LCD_D7, False) if bits&amp;0x01==0x01: GPIO.output(LCD_D4, True) if bits&amp;0x02==0x02: GPIO.output(LCD_D5, True) if bits&amp;0x04==0x04: GPIO.output(LCD_D6, True) if bits&amp;0x08==0x08: GPIO.output(LCD_D7, True)# Toggle &#x27;Enable&#x27; pin lcd_toggle_enable()def lcd_toggle_enable(): time.sleep(0.0005) GPIO.output(LCD_E, True) time.sleep(0.0005) GPIO.output(LCD_E, False) time.sleep(0.0005)def lcd_text(message,line): # Send text to display message = message.ljust(LCD_CHARS,&quot; &quot;) lcd_write(line, LCD_CMD) for i in range(LCD_CHARS): lcd_write(ord(message[i]),LCD_CHR)#Begin programtry: main() except KeyboardInterrupt: pass finally: lcd_write(0x01, LCD_CMD) lcd_text(&quot;So long!&quot;,LCD_LINE_1) lcd_text(&quot;lison.cc&quot;,LCD_LINE_2) GPIO.cleanup() 5. 另外1如何查看自己的树莓派pin与gpio对应关系，终端输入pinout，打印如下图 参考资料 Raspberry Pi Documentation - Raspberry Pi hardware 树莓派通过 I2C 驱动 LCD1602 液晶屏 Drive an LCD 16x2 display with Raspberry Pi","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"RPi","slug":"RPi","permalink":"https://lison.cc/tags/RPi/"},{"name":"LCD 1602a","slug":"LCD-1602a","permalink":"https://lison.cc/tags/LCD-1602a/"}],"author":"Lison"},{"title":"我个人的一部分特点","slug":"about-chinese","date":"2022-12-21T11:39:11.000Z","updated":"2023-11-16T06:15:51.350Z","comments":true,"path":"about-chinese/","link":"","permalink":"https://lison.cc/about-chinese/","excerpt":"","text":"书 买了 = 看了 = 用了 = 都记住理解了 = 有效果了 需要付出努力的 一律点赞收藏 或者热血三分钟 之后大脑给与反馈记忆 “嗯，你已经很努力了，真棒”。自我欺骗成功 人家敲88黑白键的你们觉得优雅，俺们敲101键的就不优？","categories":[],"tags":[],"author":"Lison"},{"title":"QT解决疑难杂症之打包项目运行出现\"QMYSQL driver not loaded\"错误","slug":"qt-fix-qmysql-driver-not-loaded","date":"2022-11-16T11:13:04.000Z","updated":"2023-11-16T06:15:51.649Z","comments":true,"path":"qt-fix-qmysql-driver-not-loaded/","link":"","permalink":"https://lison.cc/qt-fix-qmysql-driver-not-loaded/","excerpt":"出现的问题 本文只讨论打包之后的项目运行时遇到的找不到驱动情况，也就是在客户机上没有Qt开发环境的机器。 即：QSqlDatabase: QMYSQL driver not loaded 但：QSqlDatabase: available drivers: QSQLITE QMARIADB QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL7你说气人不？ 在开发机上遇到的上述错误解决之后，使用windeployqt打包之后放到没有Qt环境的客户机出现又上述错误，明明数据库也安装成功了。 编译环境 msvc2019(32bit) MySQL Server 8.0 (C:\\Program Files\\MySQL\\MySQL Server 8.0) MySQL Connector C 6.1 (注意这是32位的驱动，如果安装MySQL Server之后没有这个驱动，需要自行去官网下载并安装 C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1) 解决方法： 确定使用的libmysql.dll与libmysql.lib是来自驱动文件夹。 确保将驱动路径(C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\lib)下的libmysql.dll与libmysql.lib拷贝至exe同级路径。 编译qsqlmysql.dll与qsqlmysql.lib确保引入的内容来自驱动路径 什么是驱动路径：假如安装的是MySql Server 8.0，那么在编译qsqlmysql.dll与qsqlmysql.lib时，项目的pro文件中确保引用的是驱动路径下的include与lib路径： 12INCLUDEPATH += &quot;C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\include&quot;LIBS += &quot;C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\lib\\libmysql.lib&quot; 解决SSL​“SSL connection error: unknown error number 上述问题都解决之后，不再出现driver not loaded错误，而出现了ssl connection error，打开msql敲入 1show variables like&#x27;%ssl%&#x27; 看到have_openssl和have_ssl都是YES。 找到my.ini，在[mysqld]下加入 skip_ssl。 如果在MySQL Server路径下找不到my.ini，可以尝试去ProgramData\\MySQL路径寻找，或者直接查看MySQL Client cmd的属性也会找到对应的启动参数。 最后~甲板风很大，回船舱吧。","text":"出现的问题 本文只讨论打包之后的项目运行时遇到的找不到驱动情况，也就是在客户机上没有Qt开发环境的机器。 即：QSqlDatabase: QMYSQL driver not loaded 但：QSqlDatabase: available drivers: QSQLITE QMARIADB QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL7你说气人不？ 在开发机上遇到的上述错误解决之后，使用windeployqt打包之后放到没有Qt环境的客户机出现又上述错误，明明数据库也安装成功了。 编译环境 msvc2019(32bit) MySQL Server 8.0 (C:\\Program Files\\MySQL\\MySQL Server 8.0) MySQL Connector C 6.1 (注意这是32位的驱动，如果安装MySQL Server之后没有这个驱动，需要自行去官网下载并安装 C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1) 解决方法： 确定使用的libmysql.dll与libmysql.lib是来自驱动文件夹。 确保将驱动路径(C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\lib)下的libmysql.dll与libmysql.lib拷贝至exe同级路径。 编译qsqlmysql.dll与qsqlmysql.lib确保引入的内容来自驱动路径 什么是驱动路径：假如安装的是MySql Server 8.0，那么在编译qsqlmysql.dll与qsqlmysql.lib时，项目的pro文件中确保引用的是驱动路径下的include与lib路径： 12INCLUDEPATH += &quot;C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\include&quot;LIBS += &quot;C:\\Program Files (x86)\\MySQL\\MySQL Connector C 6.1\\lib\\libmysql.lib&quot; 解决SSL​“SSL connection error: unknown error number 上述问题都解决之后，不再出现driver not loaded错误，而出现了ssl connection error，打开msql敲入 1show variables like&#x27;%ssl%&#x27; 看到have_openssl和have_ssl都是YES。 找到my.ini，在[mysqld]下加入 skip_ssl。 如果在MySQL Server路径下找不到my.ini，可以尝试去ProgramData\\MySQL路径寻找，或者直接查看MySQL Client cmd的属性也会找到对应的启动参数。 最后~甲板风很大，回船舱吧。","categories":[{"name":"QT","slug":"QT","permalink":"https://lison.cc/categories/QT/"}],"tags":[],"author":"Lison"},{"title":"QT打包解决 module QtQuick.Extras is not installed 问题","slug":"qt-fix-module-QtQuick-Extras-is-not-installed","date":"2022-11-02T02:41:53.000Z","updated":"2023-11-16T06:15:51.648Z","comments":true,"path":"qt-fix-module-QtQuick-Extras-is-not-installed/","link":"","permalink":"https://lison.cc/qt-fix-module-QtQuick-Extras-is-not-installed/","excerpt":"","text":"1. 运行时好好的，打包时日志报错12qrc:/qml/Ammeter.qml:3:1: module &quot;QtQuick.Extras&quot; is not installed import QtQuick.Extras 1.4 日志报错是一方面，界面表现来讲可能有些qml控件显示成一块白色区域。而且观察你的打包路径，一定没有QtQuick.dll这样的路径或者文件夹 2. Qt官方论坛说 QtQuick.Extras is deprecated (removed) in Qt6 但我用的是Qt5版本，这不对，又没说怎么解决 3. 民间高手的说法环境变量设置的有问题，根据1点er执着大神的说法，是找错了路径，本来应该找Qt5的的东西，结果去Qt6的路径去寻找，需要添加以下环境变量。 QML2_IMPORT_PATH1 这看起来像是linux下的设置环境变量的方法吧，而我用的是window。 记不记得Qt Creator里项目设置的地方也有环境变量的设置？ 就是这里，红线位置表示你目前使用的build平台，不会选错吧，就酱吧。 引用 Qt Forum -module “QtQuick.Extras” is not installed 博客园 - module “QtQuick” is not installed","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[],"author":"Lison"},{"title":"西门子PLC S7-200 Smart 两种定时亮灭的电路记录","slug":"plc-siemens-s7200-smart-on-off-period","date":"2022-09-01T05:34:26.000Z","updated":"2023-11-16T06:15:51.645Z","comments":true,"path":"plc-siemens-s7200-smart-on-off-period/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-on-off-period/","excerpt":"","text":"实现效果 控制要求 要求输出点周期性的出现点亮/熄灭的变化 程序1 使用两个TON; 亮与灭的时间各使用一个TON计时 程序2 使用TON+比较器","categories":[{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"}],"tags":[],"author":"Lison"},{"title":"西门子PLC S7-200 Smart 电动机Y-三角降压启动电路记录","slug":"plc-siemens-s7200-smart-Y-start-with-delay","date":"2022-09-01T02:48:58.000Z","updated":"2023-11-16T06:15:51.643Z","comments":true,"path":"plc-siemens-s7200-smart-Y-start-with-delay/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-Y-start-with-delay/","excerpt":"","text":"控制要求 当按下启动按钮时，电动机绕组Y连接降压启动，20S后电动机绕组自动转为三角连接全压运转。 当按下停止按钮时，电动机断电停止。 I/O端口分配表 输入端口 输出端口 输入点 输入器件 作用 输出点 输出器件 作用 I0.0 SB1常开触点 启动按钮 Q0.0 自锁 I0.1 SB2常闭触点 停止按钮 Q0.1 KM1 三角全压 Q0.2 KM2 电动机绕组Y降压 程序 运行视频","categories":[{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"}],"tags":[],"author":"Lison"},{"title":"HEX助手16进制加法与格式化小工具","slug":"qt-toolkit-hex-adder","date":"2022-08-02T06:41:15.000Z","updated":"2023-11-16T06:15:51.654Z","comments":true,"path":"qt-toolkit-hex-adder/","link":"","permalink":"https://lison.cc/qt-toolkit-hex-adder/","excerpt":"","text":"软件功能 把输入的16进制数组给求和 16进制数组简单格式化，去除换行符\\r\\n 将求和结果附加到格式化字符串后面，如果需要则前面补0 下载地址链接: https://pan.baidu.com/s/1VWgDS-BxLK8O7VbQatmO3A?pwd=tu12 提取码: tu12 仓库地址https://github.com/LisonLiou/hex-adder","categories":[{"name":"qt","slug":"qt","permalink":"https://lison.cc/categories/qt/"}],"tags":[{"name":"16进制","slug":"16进制","permalink":"https://lison.cc/tags/16%E8%BF%9B%E5%88%B6/"}],"author":"Lison"},{"title":"西门子PLC S7-200 Smart一键启停电路记录","slug":"plc-siemens-s7200-smart-start-and-stop-with-one-button","date":"2022-07-25T10:10:49.000Z","updated":"2023-11-16T06:15:51.646Z","comments":true,"path":"plc-siemens-s7200-smart-start-and-stop-with-one-button/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-start-and-stop-with-one-button/","excerpt":"","text":"控制要求 一个按钮，按一下启动，再按一下停止 注意 不要忘记加上升沿扫描周期，否则继电器会咔咔咔咔咔咔，接负载的话估计会损坏，CPU扫描周期太快 M0.0和M0.1加上监控也几乎看不到，周期太快，偶尔会看到能流变化 程序 运行效果","categories":[{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"}],"tags":[],"author":"Lison"},{"title":"西门子PLC S7-200 Smart电机顺序启动逆序停止电路记录","slug":"plc-siemens-s7200-smart-motor-start-asc-stop-desc","date":"2022-07-25T08:27:43.000Z","updated":"2023-11-16T06:15:51.645Z","comments":true,"path":"plc-siemens-s7200-smart-motor-start-asc-stop-desc/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-motor-start-asc-stop-desc/","excerpt":"","text":"控制要求 第一台电动机起动后，第二台电动机才能启动 第二台电动机停止后，第一台电动机才能停止 I/O端口分配表 输入端口 输出端口 输入点 输入器件 作用 输出点 输出器件 作用 I0.0 SB1常开触点 M1启动按钮 Q0.0 KM1 电动机M1 I0.1 SB2常闭触点 M1停止按钮 I0.2 SB3常开触点 M2启动按钮 Q0.1 KM2 电动机M2 I0.3 SB4常闭触点 M2停止按钮 程序 使用置位与复位方式实现的程序 运行视频","categories":[{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"}],"tags":[],"author":"Lison"},{"title":"西门子PLC S7-200 Smart互锁电路记录","slug":"plc-siemens-s7200-smart-q-mutex","date":"2022-07-25T03:42:56.000Z","updated":"2023-11-16T06:15:51.646Z","comments":true,"path":"plc-siemens-s7200-smart-q-mutex/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-q-mutex/","excerpt":"","text":"用途 三个按钮 一个开一个关一个开 开启1后不能开启2 必须先按关闭再开启2 反之亦然 用于电机正反转控制，正转中的电机不能直接使其反转，会对其产生损坏，要使其反转必须先按下停止（应该过一段时间使其完全停止）再进行反转操作 材料 SIEMENS S7-200 Smart SIEMENS SIMATIC PM207 3A 电源模块 200V转24V OMRON MY2N-J 24VDC继电器*2 PB1-F-C10 按钮三个绿红绿 一开一关一开 注意 输出继电器线路不要接错，不然输出很奇怪，这是小事，关键是不要对负载造成伤害 运行图 运行视频","categories":[{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"}],"tags":[],"author":"Lison"},{"title":"西门子PLC S7-200 Smart启保停电路记录","slug":"plc-siemens-s7200-smart-helloworld","date":"2022-07-22T13:21:18.000Z","updated":"2023-11-16T06:15:51.644Z","comments":true,"path":"plc-siemens-s7200-smart-helloworld/","link":"","permalink":"https://lison.cc/plc-siemens-s7200-smart-helloworld/","excerpt":"","text":"材料 SIEMENS S7-200 Smart SIEMENS SIMATIC PM207 3A 电源模块 200V转24V OMRON MY2N-J 24VDC继电器 PB1-F-C10 按钮两个绿红一开一关 注意 220V的零地火线接之前一定用万用表测量区分一下，否则可能短路整栋楼跳闸 接线图 软件运行图 运行视频","categories":[{"name":"PLC","slug":"PLC","permalink":"https://lison.cc/categories/PLC/"}],"tags":[],"author":"Lison"},{"title":"南海航行日记_周三_20220713","slug":"south-sea-voyage-diary-20220713","date":"2022-07-13T13:40:35.000Z","updated":"2023-11-16T06:15:51.851Z","comments":true,"path":"south-sea-voyage-diary-20220713/","link":"","permalink":"https://lison.cc/south-sea-voyage-diary-20220713/","excerpt":"","text":"是的 没网络我又开始写航海日记了 7月13号 周三晴 早上开舱门 远处两艘军舰 视线里有一艘邮轮 手机无信号 昨晚上看船长钓鱼 大假鱼饵 不用铅坠和浮漂 钓组很简单 70米水深到底 间断往上收线 半个多小时没有鱼获 整套装备目测接近10k 昨晚加班作业测试 见到了水底的发光乌贼 跟着摄像头很美丽 午夜入睡 没有宵夜 船长脾气很大 音量高 40大几岁 短头发金链子手链不抽烟 个头不高 不工作时候声音正常 很多时候晚上一个人钓鱼 我猜些许他孤独 当你只面对天空和深蓝还有摇摆 似乎什么都不在重要 脑袋空 船员大概20几号人 除了我们好像没有北方口音 工作之外说说笑笑 昨晚开始还是头晕 但明显好过之前 今天没有吃晕船药没有上晕船贴 感觉摇摆已经与船体接近同步 昨晚航行七级海风 没有太大感觉 现在可以在甲板手机写日记 以后可以出海当渔民或者观摩一下DPOperator的考试时间了 晚上准备洗衣服 工作服至今没换 都臭了 汗水雨水海水烟味混淆的味道 船体位置位置 应该在第一作业段附近 三亚东南二十几度位置 距离海岸未知 水深93米好像上螃蟹窝 不知道这里离比基尼海滩有多远 海绵宝宝应该也上班了 所有消息发布出去受不进来 就此失联 船上往外看就是海平面的巨大弧线 果然是圆的 温带赶到热带 对面就是越南 看不见也游不过去 上午最后一次下水测试完毕 取下设备上的深海硅藻泥 任务宣告失败 明后天准备回归 我在想 等上岸之后 会不会怀念这种感觉 这个未知的地方 下午间隙开始海钓 下钩两分钟以为拖底 提上来一条石斑 喜","categories":[{"name":"航海日记","slug":"航海日记","permalink":"https://lison.cc/categories/%E8%88%AA%E6%B5%B7%E6%97%A5%E8%AE%B0/"}],"tags":[],"author":"Lison"},{"title":"南海航行日记_周日_20220710","slug":"south-sea-voyage-diary-20220710","date":"2022-07-10T09:11:22.000Z","updated":"2023-11-16T06:15:51.691Z","comments":true,"path":"south-sea-voyage-diary-20220710/","link":"","permalink":"https://lison.cc/south-sea-voyage-diary-20220710/","excerpt":"昨晚湛江湾港外停泊，下午四点半左右开始加油至晚上九点左右，之后起航东行经广州湾出海口进入南海，夜里12点后入睡，船身开始摇晃。早上起床后手机无信号，出房间登甲板陆续恢复，海水蓝。 航行的第二天，下午7:21，房间里没有信号，GPS找不到位置，最后的印象在海南岛东南角，下午四点半收到过万宁市政府发来的短信，应该已经过了万宁，湛江湾航向三亚，速度应该保持在8节，风速6级左右，浪高超过1.5m，船身左右倾斜可能超过10度，船头船尾上下颠簸摇摆，已经下班，头在房间里晕的厉害，写日记更加晕。今天吃了晕船药，不知道有效果还是离开了甲板中间位置，只是晕暂时没有想吐，吃饭没影响到。回到房间洗身上的油污，厕所里边洗边摇晃，走到哪里都是摇晃。扶梯，甲板，船尾，墙上挂的衣服。 船头左侧海景很棒，早上起由蓝色变为些许绿再转入现在的深蓝，深蓝是深海的颜色，也是蓝星的颜色。像染缸，也像钢笔墨水，混合激起的水沫浪花，层层的渐变，随机，清澈到让人想跳下去。 这里可以解释很多东西。 深海、深蓝 什么叫一望无际 什么叫乘风破浪 《浮世绘》到底是什么意思 人类有多么渺小 我们应该爱蓝星 这里的景象没有办法用语言形容，只有切身领会，才会敬畏自然。","text":"昨晚湛江湾港外停泊，下午四点半左右开始加油至晚上九点左右，之后起航东行经广州湾出海口进入南海，夜里12点后入睡，船身开始摇晃。早上起床后手机无信号，出房间登甲板陆续恢复，海水蓝。 航行的第二天，下午7:21，房间里没有信号，GPS找不到位置，最后的印象在海南岛东南角，下午四点半收到过万宁市政府发来的短信，应该已经过了万宁，湛江湾航向三亚，速度应该保持在8节，风速6级左右，浪高超过1.5m，船身左右倾斜可能超过10度，船头船尾上下颠簸摇摆，已经下班，头在房间里晕的厉害，写日记更加晕。今天吃了晕船药，不知道有效果还是离开了甲板中间位置，只是晕暂时没有想吐，吃饭没影响到。回到房间洗身上的油污，厕所里边洗边摇晃，走到哪里都是摇晃。扶梯，甲板，船尾，墙上挂的衣服。 船头左侧海景很棒，早上起由蓝色变为些许绿再转入现在的深蓝，深蓝是深海的颜色，也是蓝星的颜色。像染缸，也像钢笔墨水，混合激起的水沫浪花，层层的渐变，随机，清澈到让人想跳下去。 这里可以解释很多东西。 深海、深蓝 什么叫一望无际 什么叫乘风破浪 《浮世绘》到底是什么意思 人类有多么渺小 我们应该爱蓝星 这里的景象没有办法用语言形容，只有切身领会，才会敬畏自然。","categories":[{"name":"航海日记","slug":"航海日记","permalink":"https://lison.cc/categories/%E8%88%AA%E6%B5%B7%E6%97%A5%E8%AE%B0/"}],"tags":[],"author":"Lison"},{"title":"Qt使用QQueue的contains方法的正确知识","slug":"qt-qqueue-contains","date":"2022-06-14T05:50:21.000Z","updated":"2023-11-16T06:15:51.652Z","comments":true,"path":"qt-qqueue-contains/","link":"","permalink":"https://lison.cc/qt-qqueue-contains/","excerpt":"从一段报错开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qlist.h:1090: error: C2678: 二进制“==”: 没有找到接受“T”类型的左操作数的运算符(或没有可接受的转换) with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmetaobject.h(200): note: 可能是“bool operator ==(const QMetaMethod &amp;,const QMetaMethod &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(876): note: 或 “bool operator ==(QPointingDeviceUniqueId,QPointingDeviceUniqueId) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(842): note: 或 “bool operator ==(QKeySequence::StandardKey,QKeyEvent *)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(841): note: 或 “bool operator ==(QKeyEvent *,QKeySequence::StandardKey)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector2d.h(211): note: 或 “bool operator ==(const QVector2D &amp;,const QVector2D &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qsurfaceformat.h(165): note: 或 “bool operator ==(const QSurfaceFormat &amp;,const QSurfaceFormat &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qquaternion.h(185): note: 或 “bool operator ==(const QQuaternion &amp;,const QQuaternion &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector4d.h(236): note: 或 “bool operator ==(const QVector4D &amp;,const QVector4D &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector3d.h(236): note: 或 “bool operator ==(const QVector3D &amp;,const QVector3D &amp;)”C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.19041.0\\shared\\guiddef.h(192): note: 或 “bool operator ==(const GUID &amp;,const GUID &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qcursor.h(124): note: 或 “bool operator ==(const QCursor &amp;,const QCursor &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qrect.h(860): note: 或 “bool operator ==(const QRectF &amp;,const QRectF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qrect.h(454): note: 或 “bool operator ==(const QRect &amp;,const QRect &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qsize.h(350): note: 或 “bool operator ==(const QSizeF &amp;,const QSizeF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qsize.h(175): note: 或 “bool operator ==(const QSize &amp;,const QSize &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmargins.h(372): note: 或 “bool operator ==(const QMarginsF &amp;,const QMarginsF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmargins.h(135): note: 或 “bool operator ==(const QMargins &amp;,const QMargins &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(279): note: 或 “bool operator ==(int,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(279): note: 或 “bool operator ==(qfloat16,int) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(268): note: 或 “bool operator ==(float,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(268): note: 或 “bool operator ==(qfloat16,float) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(267): note: 或 “bool operator ==(double,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(267): note: 或 “bool operator ==(qfloat16,double) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(266): note: 或 “bool operator ==(long double,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(266): note: 或 “bool operator ==(qfloat16,long double) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(253): note: 或 “bool operator ==(qfloat16,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtNetwork/qhostaddress.h(165): note: 或 “bool operator ==(QHostAddress::SpecialAddress,const QHostAddress &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qvariant.h(611): note: 或 “bool operator ==(const QVariant &amp;,const QVariantComparisonHelper &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qhash.h(139): note: 或 “bool operator ==(const QHashDummyValue &amp;,const QHashDummyValue &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qpoint.h(357): note: 或 “bool operator ==(const QPointF &amp;,const QPointF &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qpoint.h(165): note: 或 “bool operator ==(const QPoint &amp;,const QPoint &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1983): note: 或 “bool operator ==(const QByteArray &amp;,const QStringRef &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1976): note: 或 “bool operator ==(const QStringRef &amp;,const QByteArray &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1967): note: 或 “bool operator ==(QLatin1String,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1960): note: 或 “bool operator ==(QStringView,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1952): note: 或 “bool operator ==(QChar,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1945): note: 或 “bool operator ==(QStringView,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1937): note: 或 “bool operator ==(QStringView,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1929): note: 或 “bool operator ==(QLatin1String,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1910): note: 或 “bool operator ==(const QStringRef &amp;,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1891): note: 或 “bool operator ==(const QString &amp;,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1872): note: 或 “bool operator ==(const QStringRef &amp;,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1865): note: 或 “bool operator ==(QLatin1String,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1836): note: 或 “bool operator ==(const QStringRef &amp;,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1829): note: 或 “bool operator ==(const QString &amp;,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1817): note: 或 “bool operator ==(const QStringRef &amp;,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1439): note: 或 “bool operator ==(const char *,QLatin1String)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1382): note: 或 “bool operator ==(QLatin1String,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1374): note: 或 “bool operator ==(const QString &amp;,QString::Null)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1372): note: 或 “bool operator ==(QString::Null,const QString &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1370): note: 或 “bool operator ==(QString::Null,QString::Null)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1918): note: 或 “bool operator ==(QChar,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1899): note: 或 “bool operator ==(QChar,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1880): note: 或 “bool operator ==(QChar,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(2004): note: 或 “bool operator ==(const char *,const QStringRef &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1426): note: 或 “bool operator ==(const char *,const QString &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(806): note: 或 “bool operator ==(const QString &amp;,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(800): note: 或 “bool operator ==(const QByteArray::FromBase64Result &amp;,const QByteArray::FromBase64Result &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(688): note: 或 “bool operator ==(const char *,const QByteArray &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(686): note: 或 “bool operator ==(const QByteArray &amp;,const char *) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(684): note: 或 “bool operator ==(const QByteArray &amp;,const QByteArray &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(648): note: 或 “bool operator ==(std::nullptr_t,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(646): note: 或 “bool operator ==(QChar,std::nullptr_t) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(637): note: 或 “bool operator ==(QChar,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(68): note: 或 “bool operator ==(QLatin1Char,char) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(61): note: 或 “bool operator ==(char,QLatin1Char) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1090): note: 尝试匹配参数列表“(T, const T)”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1086): note: 在编译 类 模板 成员函数“bool QList&lt;T&gt;::contains_impl(const T &amp;,QListData::NotArrayCompatibleLayout) const”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1081): note: 查看对正在编译的函数 模板 实例化“bool QList&lt;T&gt;::contains_impl(const T &amp;,QListData::NotArrayCompatibleLayout) const”的引用 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(872): note: 在编译 类 模板 成员函数“QList&lt;T&gt;::~QList(void)”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qqueue.h(63): note: 查看对正在编译的函数 模板 实例化“QList&lt;T&gt;::~QList(void)”的引用 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qqueue.h(50): note: 查看对正在编译的 类 模板 实例化“QList&lt;T&gt;”的引用 with [ T=Msg ]D:\\repos\\qt\\SCLIOS_ZCHG9_GLSBLJZ\\Form_GuLunShiBuLanJiZu.h(172): note: 查看对正在编译的 类 模板 实例化“QQueue&lt;Msg&gt;”的引用","text":"从一段报错开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qlist.h:1090: error: C2678: 二进制“==”: 没有找到接受“T”类型的左操作数的运算符(或没有可接受的转换) with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmetaobject.h(200): note: 可能是“bool operator ==(const QMetaMethod &amp;,const QMetaMethod &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(876): note: 或 “bool operator ==(QPointingDeviceUniqueId,QPointingDeviceUniqueId) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(842): note: 或 “bool operator ==(QKeySequence::StandardKey,QKeyEvent *)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qevent.h(841): note: 或 “bool operator ==(QKeyEvent *,QKeySequence::StandardKey)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector2d.h(211): note: 或 “bool operator ==(const QVector2D &amp;,const QVector2D &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qsurfaceformat.h(165): note: 或 “bool operator ==(const QSurfaceFormat &amp;,const QSurfaceFormat &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qquaternion.h(185): note: 或 “bool operator ==(const QQuaternion &amp;,const QQuaternion &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector4d.h(236): note: 或 “bool operator ==(const QVector4D &amp;,const QVector4D &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qvector3d.h(236): note: 或 “bool operator ==(const QVector3D &amp;,const QVector3D &amp;)”C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.19041.0\\shared\\guiddef.h(192): note: 或 “bool operator ==(const GUID &amp;,const GUID &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtGui/qcursor.h(124): note: 或 “bool operator ==(const QCursor &amp;,const QCursor &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qrect.h(860): note: 或 “bool operator ==(const QRectF &amp;,const QRectF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qrect.h(454): note: 或 “bool operator ==(const QRect &amp;,const QRect &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qsize.h(350): note: 或 “bool operator ==(const QSizeF &amp;,const QSizeF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qsize.h(175): note: 或 “bool operator ==(const QSize &amp;,const QSize &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmargins.h(372): note: 或 “bool operator ==(const QMarginsF &amp;,const QMarginsF &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qmargins.h(135): note: 或 “bool operator ==(const QMargins &amp;,const QMargins &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(279): note: 或 “bool operator ==(int,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(279): note: 或 “bool operator ==(qfloat16,int) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(268): note: 或 “bool operator ==(float,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(268): note: 或 “bool operator ==(qfloat16,float) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(267): note: 或 “bool operator ==(double,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(267): note: 或 “bool operator ==(qfloat16,double) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(266): note: 或 “bool operator ==(long double,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(266): note: 或 “bool operator ==(qfloat16,long double) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qfloat16.h(253): note: 或 “bool operator ==(qfloat16,qfloat16) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtNetwork/qhostaddress.h(165): note: 或 “bool operator ==(QHostAddress::SpecialAddress,const QHostAddress &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qvariant.h(611): note: 或 “bool operator ==(const QVariant &amp;,const QVariantComparisonHelper &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qhash.h(139): note: 或 “bool operator ==(const QHashDummyValue &amp;,const QHashDummyValue &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qpoint.h(357): note: 或 “bool operator ==(const QPointF &amp;,const QPointF &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qpoint.h(165): note: 或 “bool operator ==(const QPoint &amp;,const QPoint &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1983): note: 或 “bool operator ==(const QByteArray &amp;,const QStringRef &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1976): note: 或 “bool operator ==(const QStringRef &amp;,const QByteArray &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1967): note: 或 “bool operator ==(QLatin1String,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1960): note: 或 “bool operator ==(QStringView,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1952): note: 或 “bool operator ==(QChar,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1945): note: 或 “bool operator ==(QStringView,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1937): note: 或 “bool operator ==(QStringView,QStringView) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1929): note: 或 “bool operator ==(QLatin1String,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1910): note: 或 “bool operator ==(const QStringRef &amp;,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1891): note: 或 “bool operator ==(const QString &amp;,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1872): note: 或 “bool operator ==(const QStringRef &amp;,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1865): note: 或 “bool operator ==(QLatin1String,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1836): note: 或 “bool operator ==(const QStringRef &amp;,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1829): note: 或 “bool operator ==(const QString &amp;,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1817): note: 或 “bool operator ==(const QStringRef &amp;,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1439): note: 或 “bool operator ==(const char *,QLatin1String)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1382): note: 或 “bool operator ==(QLatin1String,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1374): note: 或 “bool operator ==(const QString &amp;,QString::Null)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1372): note: 或 “bool operator ==(QString::Null,const QString &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1370): note: 或 “bool operator ==(QString::Null,QString::Null)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1918): note: 或 “bool operator ==(QChar,QLatin1String) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1899): note: 或 “bool operator ==(QChar,const QStringRef &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1880): note: 或 “bool operator ==(QChar,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(2004): note: 或 “bool operator ==(const char *,const QStringRef &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(1426): note: 或 “bool operator ==(const char *,const QString &amp;)”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qstring.h(806): note: 或 “bool operator ==(const QString &amp;,const QString &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(800): note: 或 “bool operator ==(const QByteArray::FromBase64Result &amp;,const QByteArray::FromBase64Result &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(688): note: 或 “bool operator ==(const char *,const QByteArray &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(686): note: 或 “bool operator ==(const QByteArray &amp;,const char *) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qbytearray.h(684): note: 或 “bool operator ==(const QByteArray &amp;,const QByteArray &amp;) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(648): note: 或 “bool operator ==(std::nullptr_t,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(646): note: 或 “bool operator ==(QChar,std::nullptr_t) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(637): note: 或 “bool operator ==(QChar,QChar) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(68): note: 或 “bool operator ==(QLatin1Char,char) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qchar.h(61): note: 或 “bool operator ==(char,QLatin1Char) noexcept”D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1090): note: 尝试匹配参数列表“(T, const T)”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1086): note: 在编译 类 模板 成员函数“bool QList&lt;T&gt;::contains_impl(const T &amp;,QListData::NotArrayCompatibleLayout) const”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(1081): note: 查看对正在编译的函数 模板 实例化“bool QList&lt;T&gt;::contains_impl(const T &amp;,QListData::NotArrayCompatibleLayout) const”的引用 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore/qlist.h(872): note: 在编译 类 模板 成员函数“QList&lt;T&gt;::~QList(void)”时 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qqueue.h(63): note: 查看对正在编译的函数 模板 实例化“QList&lt;T&gt;::~QList(void)”的引用 with [ T=Msg ]D:\\Qt\\5.15.2\\msvc2019\\include\\QtCore\\qqueue.h(50): note: 查看对正在编译的 类 模板 实例化“QList&lt;T&gt;”的引用 with [ T=Msg ]D:\\repos\\qt\\SCLIOS_ZCHG9_GLSBLJZ\\Form_GuLunShiBuLanJiZu.h(172): note: 查看对正在编译的 类 模板 实例化“QQueue&lt;Msg&gt;”的引用 报错位置代码行1QQueue&lt;Msg&gt; msgQueue; 瞪大眼睛看了又看，就这一行声明，能有什么错？开玩笑。。。 Msg代码12345typedef struct Message&#123; unsigned int Id; QString MsgContent; MsgType MsgType;&#125;Msg; 瞪大眼睛看了又看，就这几行结构体声明，能有什么错？还开玩笑。。。 扩大范围，使用Msg的地方12345if(msgQueue.contains(msg)) return;msgQueue.enqueue(msg);emit signal_msg_got(); if处使用了contains判断，contains根据什么判断？详情请按F1得到的答复如下，原文地址 1234bool QList::contains(const T &amp;value) constReturns true if the list contains an occurrence of value; otherwise returns false.This function requires the value type to have an implementation of operator==(). 人家说了contains得使用==双等号操作符进行判断，那么修改之后的Msg结构如下 123456789typedef struct Message&#123; unsigned int Id; QString MsgContent; MsgType MsgType; bool operator==(const Message &amp;m)&#123; //用于contains比较 return m.Id==Id&amp;&amp;m.MsgContent==MsgContent&amp;&amp;m.MsgType==MsgType; &#125;&#125;Msg; 再点小锤子，不报错了吧。为什么要用小锤子呢，之前是铁匠吗？？恰西的铁锤？","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[{"name":"容器类","slug":"容器类","permalink":"https://lison.cc/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"}],"author":"Lison"},{"title":"Qt-Windows系统进程间通信实践 – CPU相关性","slug":"qt-windows-CPU-Affinity","date":"2022-06-09T06:11:45.000Z","updated":"2023-11-16T06:15:51.655Z","comments":true,"path":"qt-windows-CPU-Affinity/","link":"","permalink":"https://lison.cc/qt-windows-CPU-Affinity/","excerpt":"前言本文是《Qt-Windows系统进程间通信实践 - 进程优先级》的扩展部分，程序修改部分为在原有程序的基础上，为各个udp客户端的返回数据中加入本进程的PID，并在主控端对指定的PID进行操作，文章略有重复，仅作折腾记录。运行界面如下","text":"前言本文是《Qt-Windows系统进程间通信实践 - 进程优先级》的扩展部分，程序修改部分为在原有程序的基础上，为各个udp客户端的返回数据中加入本进程的PID，并在主控端对指定的PID进行操作，文章略有重复，仅作折腾记录。运行界面如下 实现功能（黄色为新增） 主控端可选择能够进行相互连接的子程序 子程序可由主控端进行踢出或者设置CPU运行优先级 可选择是否在所有子程序退出后主控端一同退出 可选择是否在任何一个子程序退出后所有其他子程序与主控端全部退出 所有子程序均可根据运行时传入端口号参数决定是否加入udp监听 子程序端口号根据主控端监听端口自动加1 可对选取的目标进程进行CPU核心相关性（亲和性）设置，可单个可组合。 运行流程1． 程序启动后，可手动添加支持udp连接的客户端子程序2． 添加成功后客户端会发送一条启动的udp消息，服务端收到并展示。3． 服务端对客户端的“移除”与变更进程优先级操作均通过udp包发送给客户端，udp包中包含有目标程序所包含的端口号（简单起见以此来区分哪个客户端应该对此包做出回应）与当前进程的PID。4． 客户端主动退出后会给服务端发送指定格式udp包，服务端收到后根据配置决定单独退出此程序或者全部退出。5. 控制端（服务端）对指定的PID进行CPU相关性操作将直接进行系统调用（System Call） UDP数据包格式分隔符为###示例1：SERVERMSG###TERMINATE###[MSGCONTENT]SERVERMSG: 服务端发往客户端的信息TERMINATE: 表示执行关闭程序操作MSGCONTENT: 表示此次操作需携带的数据（可空） 示例2：SERVERMSG###PRIORITY###2SERVERMSG: 服务端发往客户端的信息PRIORITY: 表示设置客户端进程的优先级2: 设置优先级为2（HIGH_PRIORITY_CLASS：High，高优先级类） 示例3：CLIENTMSG###CopyCoinFlip:9001 started###PIDCLIENTMSG: 客户端发往服务端的信息CopyCoinFlip:9001 started: 通知型信息，消息主体为监听9001端口的程序CopyCoinFlip启动了PID: 当前进程的PID 程序逻辑验证方法 在服务端对指定进程右键设置CPU相关性之后，可根据进程PID在windows的资源管理器中进行查看，在CommandDashBoard中设置的CPU相关性会在windows资源管理中得到体现，反之在windows资源管理器中进行了CPU亲和性设置之后在CommandDashboard中也会得到展示，两边的状态显示与操作都是互通的，如图 可以看到两边同为7576的PID显示的CPU相关性相同，对其中任何一个进行设置之后都会同步在对方的状态显示中。 无限循环测试。 新增一个名为CommandDashboard-TestClient1的程序，其内容为两个按钮触发无限循环。第一个按钮直接无线循环并更新UI，显然界面会假死；第二个按钮为在独立线程中执行上述操作，界面会过一段时间假死，过一段时间恢复，下图 上述两个按钮的目的在于，使用CommandDashboard控制端对其进行CPU亲和度设置时观察CPU核心的负载状态，得到结论如下： CPU核心绑定进程时，无限循环中观察到每个核心的负载初期差别不大，1-2分钟后负载明显，如图 CPU核心绑定到线程时，无限循环中可以明显观察到负载均衡的差别，如下图 可以明显观察到CPU3的负载比其他核心高。 关于本程序的局限性 系统调用平台关联性强，目前只支持windows平台 只在单处理器多核心场景验证过(Intel I3 4核心)，不支持多处理器多核心 与本文相关的项目及源程序 CommandDashboard 负责添加配套的udp客户端，可对其进行运行优先级调整，关闭等操作 CommandDashboard-TestClient1 udp客户端程序，模拟进程循环和线程循环用于观察CPU核心的负载变化 MyDockButtonDemo、CopyCoinFlip 均为CommandDashboard的udp客户端 项目下载地址https://pan.baidu.com/s/1MJ08H7TBHRgd8AsaVDxtAg?pwd=8xjn 参考资料 windows 系统资源获取的c++ 方法_bruce_wang_janet的博客-CSDN博客 C++ (Cpp) GetProcessAffinityMask示例 - HotExamples SetThreadAffinityMask function (winbase.h) - Win32 apps | Microsoft Docs windows下绑定线程（进程）到指定的CPU核心 - Avatarx - 博客园 (cnblogs.com) 用SetProcessAffinityMask为进程指定CPU_zdleek的博客-CSDN博客 windows下设置线程亲和性（支持大于64核）_百里杨的博客-CSDN博客_线程亲和性","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://lison.cc/tags/CPU/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lison.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"Lison"},{"title":"Qt-Windows系统进程间通信实践 - 进程优先级","slug":"qt-windows-IPC","date":"2022-06-09T05:31:10.000Z","updated":"2023-11-16T06:15:51.656Z","comments":true,"path":"qt-windows-IPC/","link":"","permalink":"https://lison.cc/qt-windows-IPC/","excerpt":"前言本文记录Qt应用程序使用QProcess配合udp通信协议实现进程间通信IPC实践。程序运行界面如下","text":"前言本文记录Qt应用程序使用QProcess配合udp通信协议实现进程间通信IPC实践。程序运行界面如下 实现功能 主控端可选择能够进行相互连接的子程序 子程序可由主控端进行踢出或者设置CPU运行优先级 可选择是否在所有子程序退出后主控端一同退出 可选择是否在任何一个子程序退出后所有其他子程序与主控端全部退出 所有子程序均可根据运行时传入端口号参数决定是否加入udp监听 子程序端口号根据主控端监听端口自动加1 运行流程 程序启动后，可手动添加支持udp连接的客户端子程序 添加成功后客户端会发送一条启动的udp消息，服务端收到并展示。 服务端对客户端的“移除”与变更进程优先级操作均通过udp包发送给客户端，udp包中包含有目标程序所包含的端口号（简单起见以此来区分哪个客户端应该对此包做出回应）。 客户端主动退出后会给服务端发送指定格式udp包，服务端收到后根据配置决定单独退出此程序或者全部退出。 UDP数据包格式分隔符为###示例1：SERVERMSG###TERMINATE###[MSGCONTENT]SERVERMSG: 服务端发往客户端的信息TERMINATE: 表示执行关闭程序操作MSGCONTENT: 表示此次操作需携带的数据（可空） 示例2：SERVERMSG###PRIORITY###2SERVERMSG: 服务端发往客户端的信息PRIORITY: 表示设置客户端进程的优先级2: 设置优先级为2（HIGH_PRIORITY_CLASS：High，高优先级类） 示例3：CLIENTMSG###CopyCoinFlip:9001 startedCLIENTMSG: 客户端发往服务端的信息CopyCoinFlip:9001 started: 通知型信息，消息主体为监听9001端口的程序CopyCoinFlip启动了 可以看到DebugView中捕获了win32程序的调试信息 第二行setPriority 2为设置的优先级代码，1为SetPriorityClass执行的布尔型返回值。对应源码为 对应任务管理器也可以显示到相同的结果 压缩包中只包含两个支持本udp通信协议的客户端子程序，分别为CopyCoinFlip.exe 和 MyDockButtonDemo.exe 。 这两个exe可单独运行，也可由CommandDashBoard经过添加程序进行启动，经由CommandDashboard启动的应用会接收到由Qprocess启动追加的端口参数，客户端在识别到参数后启动自身的udp连接。 启动udp后还需要实现udp客户端的其他功能，例如发送数据、处理服务端发送消息、重写关闭窗体事件等，如下 项目源码《Qt-Windows系统进程间通信实践.7z》 提取码：fpqj 理论上，所有实现了上述方法的客户端都可以作为CommandDashboard的子程序运行。","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[{"name":"IPC","slug":"IPC","permalink":"https://lison.cc/tags/IPC/"}],"author":"Lison"},{"title":"QT应用程序内存泄漏问题排查方式","slug":"qt-how-to-find-memoryleak","date":"2022-06-08T05:38:29.000Z","updated":"2023-11-16T06:15:51.650Z","comments":true,"path":"qt-how-to-find-memoryleak/","link":"","permalink":"https://lison.cc/qt-how-to-find-memoryleak/","excerpt":"","text":"1. 良好的编程习惯程序员在开发过程中由于项目时间紧、压力大或编程习惯等原因，经常提交一些“坏味道”的代码；有些代码可以在编程期间得到开发工具的warning提示，但通常都会被我们忽略掉，只要不是error就好；更糟糕的是我们编写出来的逻辑似乎总是运行的没有异常，但会变得越来越慢；或者程序似乎会在某个特定的条件下崩溃，而且没有任何日志。 C++不像jvm和.net clr运行库拥有GC机制，所有手动申请的内存及new出来的对象都需要在特定的逻辑中对其进行释放，不然程序所占的内存会越来越多，最后影响正常运行，所以C++在编程方面对开发人员的编程技能有着更高的要求。 最难捕获的就是编译期间一切正常，运行一段时间后出现问题。此处以程序运行中出现的内存泄漏，内存溢出问题对良好的编程习惯进行讨论。 1.1 使用new关键字创建的对象是在内存堆上创建的指针对象C++没有托管堆的概念，需要在析构函数或者自定义的程序逻辑中对其进行释放。如下： 1234567int* p = new int[3];p[0] = 12;p[1] = 20;p[2] = 30;delete [] p; 1.2 使用malloc申请的内存空间与free释放问题此种方式较多出现在C语言代码程序中，C++程序对象多继承自QObject，可由构造函数传入parent父指针对象，这个QObject对象会自动添加到其父对象的children()列表。利用qt的对象树管理机制，当父对象析构的时候，这个列表中的所有对象也会被析构。 1.3 Qt的内存半自动管理 QObject及其派生类的对象，如果其parent非0，那么其parent析构时会析构该对象。 QWidget及其派生类的对象，可以设置 Qt::WA_DeleteOnClose 标志位(当close时会析构该对象)。 QAbstractAnimation派生类的对象，可以设置QAbstractAnimation::DeleteWhenStopped。 QRunnable::setAutoDelete()、MediaSource::setAutoDelete()。 2. 静态代码质量分析工具CppCheckCppcheck 是一种 C/C++ 代码缺陷静态检查工具。不同于 C/C++ 编译器及很多其它分析工具，它不检查代码中的语法错误。Cppcheck 只检查编译器检查不出来的 bug 类型，其目的是检查代码中真正的错误。 对如下代码进行分析： 1234567891011121314151617181920212223242526272829303132333435void f1(struct fred_t *p)&#123; // dereference p and then check if it&#x27;s NULL int x = p-&gt;x; if (p) do_something(x);&#125;void f2()&#123; const char *p = NULL; for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; if (str[i] == &#x27; &#x27;) &#123; p = str + i; break; &#125; &#125; // p is NULL if str doesn&#x27;t have a space. If str always has a // a space then the condition (str[i] != &#x27;\\0&#x27;) would be redundant return p[1];&#125;void f3(int a)&#123; struct fred_t *p = NULL; if (a == 1) p = fred1; // if a is not 1 then p is NULL p-&gt;x = 0;&#125; 得到结果： 提示可能的空指针警告。另外CppCheck也支持作为Visual Studio IDE的插件进行配合使用。 同样使用SonarQube也可以提供静态代码分析功能，gitee.com中提供此类型收费服务，可以直接分析已经提交到仓库中的项目代码。 3.针对怀疑内存泄漏的代码段进行植入式逻辑的排查方式可以采用在文件头定义宏的方式，将分配内存与释放两个成对的操作定义为宏，实现如下： 123456789101112void *_malloc(size_t size, const char *file, int line) &#123; void* p = malloc(size); printf(&quot;malloc[+] %p,%s:%d\\n&quot;,p,file,line); return p;&#125;void _free(void* p, const char *file,int line) &#123; free(p); printf(&quot;free[-] %p,%s:%d\\n&quot;,p,file,line);&#125;#define malloc(size) _malloc(size,__FILE__,__LINE__);#define free(p) _free(p,__FILE__,__LINE__); 调用方式： 123456int* p1 = (int*)malloc(20);int* p2 = (int*)malloc(20);int* p3 = (int*)malloc(20);free(p1);free(p2); 输出结果： 可以明显看到指针地址为：0000026BBC3FA130的对象只有申请，并未释放。因windows平台无法使用mcheck.h头文件，所以只能采取类似mtrace的内存分配与释放配对排查方式。 对上述实现宏逻辑部分的改进，直接将未释放的对象写入到文件，在怀疑有内存泄漏的代码中将特定的宏开关打开，则运行申请内存与释放内存的逻辑的代码时，若不存在配对现象，则运行时在离开代码上下文时，可以在对应的路径中找到没有释放的内存对象所在的代码文件及具体的行数。完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void *_malloc(size_t size, const char *file, int line) &#123; void* p = malloc(size); //printf(&quot;malloc[+] %p,%s:%d\\n&quot;,p,file,line); char buff[128] = &#123; 0 &#125;; sprintf(buff, &quot;%p.mem&quot;, p); FILE* fp = fopen(buff, &quot;w&quot;); fprintf(fp, &quot;[+%s:%d] --&gt; addr: %p, size: %ld\\n&quot;, file, line, p, size); fflush(fp); fclose(fp); return p;&#125;void _free(void* p, const char* file, int line) &#123; char buff[128] = &#123; 0 &#125;; sprintf(buff, &quot;%p.mem&quot;, p); if (unlink(buff) &lt; 0) &#123; printf(&quot;double free: %p\\n&quot;, p); return; &#125; free(p); //printf(&quot;free[-] %p,%s:%d\\n&quot;,p,file,line);&#125;#define malloc(size) _malloc(size,__FILE__,__LINE__);#define free(p) _free(p,__FILE__,__LINE__);void func() &#123; int* p1 = (int*)malloc(20); int* p2 = (int*)malloc(20); int* p3 = (int*)malloc(20); free(p1); free(p2);&#125;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); func(); return a.exec();&#125; 运行后如果存在申请对象并未释放的情形，则会在当前路径打印.mem结尾的文件，可以通过文件内容定位到具体的问题代码行。 现有QT编程中已很少使用C语言的malloc方式，转而使用new与delete配对申请与释放资源的方式，上述方法是做一个指引，可以在怀疑有内存泄漏的代码逻辑中重写operator new操作符，同样达到上述目的，做法如下： 首先定义一个分配指标的结构AllocationMetrics12345678910111213141516171819202122232425262728struct AllocationMetrics &#123; int TotalAllocated = 0; int TotalFreed = 0; int CurrentUsage() &#123; return TotalAllocated - TotalFreed; &#125; static AllocationMetrics&amp; instance() &#123; static AllocationMetrics instance_; return instance_; &#125; AllocationMetrics(const AllocationMetrics&amp;) = delete; // no copy AllocationMetrics&amp; operator=(const AllocationMetrics&amp;) = delete; // no assignment void PrintUsage() &#123; int usage = CurrentUsage(); qDebug() &lt;&lt; &quot;Memory Usage: &quot; &lt;&lt; QString::number(usage); &#125;private: AllocationMetrics() &#123;&#125;;&#125;; 此结构的的目的是分别记录对象使用new与delete操作申请与释放的内存大小，可以在申请内存之前和释放之后分别进行打印，如果释放之后打印的数字为0，则代表对象正常被释放掉，不会有内存泄漏问题。2. 重载怀疑有内存泄漏问题的对象的new与delete操作符 1234567891011121314151617181920212223242526272829Person::Person(QObject *parent) : QObject(parent)&#123;&#125;Person::~Person()&#123;&#125;void Person::clean() &#123; if (name != NULL) &#123; free(name); &#125;&#125;void* operator new(size_t size) &#123; //cout &lt;&lt; &quot;Allcating&quot; &lt;&lt; size &lt;&lt; &quot; bytes\\n&quot;; AllocationMetrics::instance().TotalAllocated += size; return malloc(size);&#125;void operator delete(void* memory, size_t size) &#123; //cout &lt;&lt; &quot;Allcating&quot; &lt;&lt; size &lt;&lt; &quot; bytes\\n&quot;; AllocationMetrics::instance().TotalFreed += size; free(memory);&#125; 在new与delete操作中分别对AllocationMetrics结构的TotalAllocated与TotalFreed进行了相应的增加。3. 使用方法 123456789101112131415int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); AllocationMetrics::instance().PrintUsage(); Person *p = new Person; p-&gt;name = (char*)malloc(strlen(&quot;malloc&quot;)); p-&gt;age = 30; p-&gt;sex = &quot;Male&quot;; AllocationMetrics::instance().PrintUsage(); return a.exec();&#125; 上述代码中只new了指针p，并没有做释放操作，则前后的Usage分别打印为： 可以看到堆中有未释放的bytes。 完整逻辑见《Qt_MemoryLeakTest》 4. 使用crtdbg工具植入代码排查1#include &lt;crtdbg.h&gt; //设置宏 详见“引用3”。实际测试代码如下： 双击泄漏提示即可跳转到具体代码行。如果取消注释上图中的delete p，则不会有70行泄漏的打印。 引用 总结一下Qt内存泄漏检测与处理策略 Track MEMORY ALLOCATIONS the Easy Way in C++ C++内存泄漏检测工具","categories":[{"name":"qt","slug":"qt","permalink":"https://lison.cc/categories/qt/"}],"tags":[{"name":"内存泄漏","slug":"内存泄漏","permalink":"https://lison.cc/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}],"author":"Lison"},{"title":"Qt、C++与C#动态调用C语言封装的dll","slug":"c-dll-for-qt-N-cpp","date":"2022-06-06T12:12:13.000Z","updated":"2023-11-16T06:15:51.590Z","comments":true,"path":"c-dll-for-qt-N-cpp/","link":"","permalink":"https://lison.cc/c-dll-for-qt-N-cpp/","excerpt":"RT本文记录使用C封装动态库dll，并使用C++、Qt及C#进行dll库的显式调用方式。C语言封装dll与C++有不同，只做记录。文章包含dll项目源码与C++调用方式及Qt调用方式。本文项目使用VS2019编译。项目地址：https://github.com/LisonLiou/dll_master","text":"RT本文记录使用C封装动态库dll，并使用C++、Qt及C#进行dll库的显式调用方式。C语言封装dll与C++有不同，只做记录。文章包含dll项目源码与C++调用方式及Qt调用方式。本文项目使用VS2019编译。项目地址：https://github.com/LisonLiou/dll_master 1. C语言dll项目master.h与master.c文件123456789101112131415161718192021// master.h#ifndef MASTER_H#define MASTER_H#define MASTER_API __declspec(dllexport)#ifdef __cplusplusextern &quot;C&quot;&#123;#endif // __cplusplusMASTER_API int divide(int param);#ifdef __cplusplus&#125;#endif // __cplusplus#endif // ! 12345678// master.c#include &quot;master.h&quot;int divide(int param)&#123; return param / 2;&#125; 2. C++调用方式1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;cdll/master.h&quot;typedef int __declspec(dllimport)(*FUNC_divide)(int arg);int main()&#123; HINSTANCE hDll = LoadLibrary(L&quot;cdll\\\\Dll_Master.dll&quot;); if (hDll == NULL) &#123; std::cout &lt;&lt; &quot;dll load failed &quot; &lt;&lt; GetLastError(); &#125; else &#123; FUNC_divide eval; eval = (FUNC_divide)GetProcAddress(hDll, &quot;divide&quot;); int ret = eval(13); std::cout &lt;&lt; &quot;Hello World! &quot; &lt;&lt; ret &lt;&lt; &quot;\\n&quot;; FreeLibrary(hDll); &#125;&#125; 3. Qt调用方式123456789101112131415161718192021222324252627#include &lt;QtCore/QCoreApplication&gt;#include &lt;QDebug&gt;#include &lt;QLibrary&gt;typedef int (*FUNC_divide)(int arg);int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); QString pathDll = &quot;cdll/Dll_Master.dll&quot;; QLibrary master(pathDll); if (master.load()) &#123; qDebug() &lt;&lt; &quot;ffffffffff&quot;; FUNC_divide divide = (FUNC_divide)master.resolve(&quot;divide&quot;); qDebug() &lt;&lt; &quot;Hello world &quot;&lt;&lt;divide(19); master.unload(); &#125; else &#123; qDebug() &lt;&lt; &quot;dll load failed&quot;; &#125; return a.exec();&#125; 4. C#调用方式1234567891011121314151617181920212223242526272829303132333435[DllImport(&quot;kernel32.dll&quot;)]private extern static IntPtr LoadLibrary(String path);//path 就是dll路径 返回结果为0表示失败。[DllImport(&quot;kernel32.dll&quot;)]private extern static IntPtr GetProcAddress(IntPtr lib, String funcName);//lib是LoadLibrary返回的句柄，funcName 是函数名称 返回结果为0标识失败。[DllImport(&quot;kernel32.dll&quot;)]private extern static bool FreeLibrary(IntPtr lib);//声明委托//[UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)][UnmanagedFunctionPointerAttribute(CallingConvention.StdCall)]delegate int divide(int arg);static void Main(string[] args)&#123; string dllPath = Environment.CurrentDirectory + &quot;\\\\cdll\\\\Dll_Master.dll&quot;; IntPtr hLib = LoadLibrary(dllPath);//加载函数 IntPtr apiFunction1 = GetProcAddress(hLib, &quot;divide&quot;);//获取函数地址 int i = Marshal.GetLastWin32Error(); if (apiFunction1.ToInt32() == 0)//0表示函数没找到 return; //获取函数接口，相当于函数指针 divide div = Marshal.GetDelegateForFunctionPointer(apiFunction1, typeof(divide)) as divide; Console.WriteLine(div(22)); // //释放句柄 FreeLibrary(hLib); Console.Read();&#125; 5. dll项目生成事件之后的宏示例用于在dll编译成功后将文件拷贝到引用dll的项目的输出路径，具体可根据情况自行编写自定义build步骤bash 12345xcopy $(LocalDebuggerWorkingDirectory)master.h D:\\repos\\c\\Dll_Master_Test\\cdll /e/h/y/f &amp;&amp; xcopy $(TargetPath) D:\\repos\\c\\Dll_Master_Test\\cdll /e/h/y/f &amp;&amp; xcopy $(TargetPath) D:\\repos\\c\\Dll_Master_TestQt\\cdll /e/h/y/f &amp;&amp; xcopy $(TargetPath) D:\\repos\\c\\Dll_Master_TestCSharp\\cdll /e/h/y/f 注意事项: dll文件存放位置需与调用方可执行文件在相同路径，具体看代码 System.BadImageFormatException:“试图加载格式不正确的程序的解决办法 因dll是32位程序，C#调用方可能默认为x64，需要将生成的目标平台改为x86，与dll的目标平台保持一致","categories":[{"name":"CPP","slug":"CPP","permalink":"https://lison.cc/categories/CPP/"}],"tags":[{"name":"动态库dll","slug":"动态库dll","permalink":"https://lison.cc/tags/%E5%8A%A8%E6%80%81%E5%BA%93dll/"}],"author":"Lison"},{"title":"Log4Qt的配置及使用方法","slug":"qt-log4qt","date":"2022-05-16T08:52:31.000Z","updated":"2023-11-16T06:15:51.651Z","comments":true,"path":"qt-log4qt/","link":"","permalink":"https://lison.cc/qt-log4qt/","excerpt":"","text":"1. 下载Log4Qt项目源码下载长期支持版本的Log4Qt项目源码 1git clone git@github.com:MEONMedical/Log4Qt.git 2. 添加子项目并构建项目将项目源码拷贝至项目跟路径，修改项目pro文件，追加：QT += concurrent，启用Log4Qt的多线程支持。然后将Log4Qt项目作为当前项目的子项目配置为： 12345678910111213# 定义 Log4Qt 源码根目录LOG4QT_PATH = $$PWD/Log4Qt# 定义所需的宏DEFINES += LOG4QT_LIBRARY# 指定编译项目时应该被搜索的 #include 目录INCLUDEPATH += $$LOG4QT_PATH/src \\ $$LOG4QT_PATH/src/log4qt \\ $$LOG4QT_PATH/include \\ $$LOG4QT_PATH/include/log4qt# 将 Log4Qt 源代码添加至项目中include($$LOG4QT_PATH/src/log4qt/log4qt.pri)include($$LOG4QT_PATH/build.pri)include($$LOG4QT_PATH/g++.pri) 执行qmake，完成后项目结构如下： 至此项目配置工作完成。 3. Log4Qt配置本节目的为将Log4Qt配置为 满足项目对日志功能的使用需求：在指定路径生成日志文件*.log 可配置日志文件的最大大小 日志文件个数可配置，超出后重新开始记录；例如配置最多10个，则文件增长到三个之后，若要增加第四个，则第四个会覆盖原有第一个文件，原有第一个编号置为第二个，以此类推，最后一个会被删除。达到日志文件的滚动备份。 配置ConsoleAppender，将日志输出至控制台，方便调试 123456789101112131415161718192021222324252627// Create a console appender Log4Qt::ConsoleAppender *consoleAppender = new Log4Qt::ConsoleAppender(layout, Log4Qt::ConsoleAppender::STDOUT_TARGET); consoleAppender-&gt;setName(QStringLiteral(&quot;My Appender&quot;)); consoleAppender-&gt;activateOptions(); // Add appender on root logger logger-&gt;addAppender(consoleAppender); Log4Qt::RollingFileAppender *appender = new Log4Qt::RollingFileAppender; // 设置输出目的地为应用程序所在目录下的logFile.log appender-&gt;setFile(&quot;A.log&quot;); // 设置日志为追加方式写入输出文件 appender-&gt;setAppendFile(true); // 设置备份文件的最大数量为10个 appender-&gt;setMaxBackupIndex(2); // 设置输出文件的最大值为1KB appender-&gt;setMaxFileSize(&quot;1KB&quot;); appender-&gt;setLayout(layout); // 设置编码 appender-&gt;setEncoding(QTextCodec::codecForName(&quot;UTF-8&quot;)); appender-&gt;setImmediateFlush(true); // 设置阈值级别为INFO appender-&gt;setThreshold(Log4Qt::Level::ALL_INT); // 激活选项 appender-&gt;activateOptions(); logger-&gt;addAppender(appender); 项目运行后，可以观察到项目的Shadow Build路径中，三个日志文件在大小、时间与内容的来回变化。 完整内容见：https://gitee.com/lison/sample_log4qt ###4. 关于Sample_log4qt 项目以调用封装后的系统的ping功能为例，演示在配置了log4qt日志功能后，使用Log4Qt的日志输出功能与使用系统本身的qDebug()功能都能很好的重定向到配置的日志文件中的功能示例。 引用 Log4Qt快速入门——Log4Qt日志输出重定向源码解析 Log4Qt详细文档 MEONMedical/Log4Qt: Log4Qt - Logging for the Qt cross-platform application framework (github.com)","categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"}],"tags":[{"name":"Log4Qt","slug":"Log4Qt","permalink":"https://lison.cc/tags/Log4Qt/"}],"author":"Lison"},{"title":"C#内存泄漏问题排查案例实践","slug":"csharp-how-to-find-memoryleak","date":"2022-05-11T00:26:21.000Z","updated":"2023-11-16T06:15:51.591Z","comments":true,"path":"csharp-how-to-find-memoryleak/","link":"","permalink":"https://lison.cc/csharp-how-to-find-memoryleak/","excerpt":"","text":"使用程序逻辑排查 - 白盒方式适用于排查过程中能够随时查看并修改程序源码的场景。是使用程序代码排查的方式确定关于程序编写过程中存在的对象引用链问题、资源释放问题。并对问题代码进行修复并观察后续运行状态的方法。 针对已发布版本程序的运行中状态排查 - 黑盒方式。适用于程序已经运行于生产环境，不能随时停止且没有指定版本源码的场景。可通过附加调试进程，获取现场堆场景对程序运行状态做分析。 准备工具 Procdump dotMemory .NET Memory Profile 目标调试可执行文件 C# 与 C++的内存释放模式对比C++的内存释放模式，使用引用计数器。 1234567&#123; //作用域开始 MyClass myClass1; //使用对象&#125; // 作用域结束，C++调用对象的析构函数MyClass* myClass2 = new MyClass();delete myClass2; //回收对象，调用析构函数 而在.NET编程中，退出作用域并不销毁一个对象。.NET不使用对象的引用计数方法，在每个.NET的宿主进程中，运行时都会预先分配一个叫托管堆的特殊内存堆。它的作用和传统的操作系统堆相似：为对象和数据存储分配内存。例如开发人员使用new操作符时：MyClass myClass2 = new MyClass(); .NET都会从托管堆中分配内存。所以严谨的情况下，最好在析构函数中对资源进行手动释放。 规范对象使用的方法 客户端应当限定对象的使用范围。使用using语句自动生成一个使用Dispose方法的try/finally块。1234567891011public class MyClass : IDisposable&#123; public void SomeMethod() &#123; Console.WriteLine(&quot;SomeMehtod invoked&quot;); &#125; public void Dispose() &#123; throw new NotImplementedException(); &#125;&#125; 以下两种调用方式是等价的。 12345678910111213141516MyClass myClass= new MyClass();using (myClass)&#123; myClass.SomeMethod();&#125;----------------------------------------------------------try&#123; myClass.SomeMethod();&#125;finally &#123; if (myClass != null) &#123; IDisposable disposable = myClass as IDisposable; disposable.Dispose(); &#125;&#125; 使用“确定性终结”。.NET无需显示的释放对象所占有的内存。理论上讲，开发者将对象的释放完全交给CLR进行处理也就意味着对象的释放是在某个不确定的时刻进行，通常是在托管堆资源耗尽时，但如果是数据库长连接的这种宝贵资源，是应该在以业务为导向的前提下进行创建和释放。 基于此，我们可以借鉴某些系统对象的使用方式。例如File对象和数据库连接对象，他们有一个共同的使用方式是操作之前先Open()，使用完成之后调用Close()，两种操作配对使用。这种方式叫做开/闭模式。 使用析构函数。在可能使用显式释放对象的场景中手动释放对象，把能不交给垃圾回收器回收的对象自己手动释放掉。 使用.NET Memory Profile查找托管堆上的大内存对象测试代码如下： 1234567List&lt;string&gt; list = new List&lt;string&gt;();for (int i = 0; i &lt; int.MaxValue; i++)&#123; string s = string.Join(&quot;,&quot;, Enumerable.Range(1000000, 10000000)); Console.WriteLine(s); list.Add(s); &#125; 使用.NET Memory Profile附加目标调试进程，运行之后在Overview中观察到System.String[]的存活bytes很多，选中此项查看选项Show Type details，可以观察到对象所在的函数Main，此方法可以粗略定位程序中的在托管堆连续创建对象的函数。下图可以看到持有 String[]对象的Main函数，是在Program这个文件中。 利用堆转储文件对可执行文件进行分析首先利用procdump生成目标可执行文件的堆转储文件*.dmp，将procdump路径加入系统环境变量，在命令行中执行： 1234567procdump.exe TestMemoryLeak -m 1024 -ma D:\\dotnet\\参数解释： TestMemoryLeak 目标调试进程名 -m 1024 在目标进程内存占用超过1024m时记录堆转储文件 -ma 指定包含所有进程内存信息，默认转储格式仅包括线程和句柄信息 D:\\dotnet\\ 堆转储文件的保存路径 上述命令执行后，当程序的内存使用超过1024M时，会在指定的路径下生成扩展名为.dmp的堆转储文件。 也可以在Windows的任务管理器中，右键对应的进程，选择“创建转储文件”。生成的文件将存放 在%用户%/AppData/Local路径中。 将生成的dmp文件导入到dotMemory中，即可直观的展现出堆现场的状态。 汇总页已给予诊断信息：A large number of strings with the same value is inefficient from the point of memory usage. 内存中保存了大量重复的字符串，可根据这些字符串中存储的数据对有问题的程序逻辑进行定位。 通过对dmp文件的分析可以找到现场占用存储大的对象类别。 另外dotMemory也支持通过Visual Studio插件进行调试分析。 使用dotMemoryUnit对方法体进行独立测试若排查过程中定位到程序中可能存在内存泄漏的方法体，可以单独建立Nunit测试项目编写单元测试逻辑对独立方法进行检测： 1234567891011121314151617using JetBrains.dotMemoryUnit;dotMemory.Check(memory =&gt; test());void test()&#123; List&lt;string&gt; list = new List&lt;string&gt;(); for (int i = 0; i &lt; int.MaxValue; i++) &#123; string s = string.Join(&quot;,&quot;, Enumerable.Range(1000000, 10000000)); Console.WriteLine(s); list.Add(s); &#125; Console.ReadLine();&#125; 检测结果将以单元测试结果的方式直接在Visual Studio中展现。 其他 注册事件后记得退出或销毁程序之前进行事件反注册 在频繁使用大块的byte组时，例如缓冲区场景时使用可重用的对象池。123456789101112131415161718192021222324252627class BufferPool&lt;T&gt;&#123; private readonly Func&lt;T&gt; _factoryMethod; private ConcurrentQueue&lt;T&gt; _queue = new ConcurrentQueue&lt;T&gt;(); public BufferPool(Func&lt;T&gt; factoryMethod) &#123; _factoryMethod = factoryMethod; &#125; public void Allocate(int count) &#123; for (int i = 0; i &lt; count; i++) _queue.Enqueue(_factoryMethod()); &#125; public T Dequeue() &#123; T buffer; return !_queue.TryDequeue(out buffer) ? _factoryMethod() : buffer; &#125; public void Enqueue(T buffer) &#123; _queue.Enqueue(buffer); &#125;&#125; 使用方法： 123456var myPool = new BufferPool&lt;byte[]&gt;(() =&gt; new byte[65535]);myPool.Allocate(1000);var buffer = myPool.Dequeue();// .. do something here ..myPool.Enqueue(buffer); 作为补救措施可以使用类似linux环境下的Supervisor的进程监控工具，当进程挂掉时可以立即拉起，之后通过分析系统日志程序退出方式定位问题。 附件：链接: https://pan.baidu.com/s/1nrTnJ406AntM5PbF0kmuJw?pwd=diu8 提取码: diu8 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"csharp","slug":"csharp","permalink":"https://lison.cc/categories/csharp/"}],"tags":[{"name":"内存泄漏","slug":"内存泄漏","permalink":"https://lison.cc/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}],"author":"Lison"},{"title":"C# Winform编程自定义控件（UserControl）可自适应大小的TextBox复合控件","slug":"csharp-usercontrol-mytextbox","date":"2022-05-09T06:43:32.000Z","updated":"2023-11-16T06:15:51.591Z","comments":true,"path":"csharp-usercontrol-mytextbox/","link":"","permalink":"https://lison.cc/csharp-usercontrol-mytextbox/","excerpt":"","text":"一个C# Winform自定义控件（UserControl）MyTextBox，实现功能： 窗体大小变化时重新计算自身位置，始终保持在居中状态。 自定义键盘回车事件，回车键触发时，调用用户传递的回调。 不使用*.Designer.cs文件，直接放在*.cs中。 重写控件属性Text与BackColor 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace BubbleMessage&#123; public class MyTextBox : UserControl &#123; public MyTextBox() &#123; InitializeComponent(); &#125; protected override void OnLayout(LayoutEventArgs e) &#123; base.OnLayout(e); //获取子控件 if (this.Controls.Count == 0) return; Control c = this.Controls[0]; //父窗口参数 Padding p = this.Padding; int x = 0, y = 0; int w = this.Width, h = this.Height; w -= (p.Left + p.Right); x += p.Left; //计算文本框的高度，使其显示在中间 int h2 = c.PreferredSize.Height; if (h2 &gt; h) h2 = h; y = (h - h2) / 2; c.Location = new Point(x, y); c.Size = new Size(w, h2); &#125; public event EventHandler ReturnPressed; /// &lt;summary&gt; /// 必需的设计器变量。 /// &lt;/summary&gt; private System.ComponentModel.IContainer components = null; /// &lt;summary&gt; /// 清理所有正在使用的资源。 /// &lt;/summary&gt; /// &lt;param name=&quot;disposing&quot;&gt;如果应释放托管资源，为 true；否则为 false。&lt;/param&gt; protected override void Dispose(bool disposing) &#123; if (disposing &amp;&amp; (components != null)) &#123; components.Dispose(); &#125; base.Dispose(disposing); &#125; #region 组件设计器生成的代码 /// &lt;summary&gt; /// 设计器支持所需的方法 - 不要修改 /// 使用代码编辑器修改此方法的内容。 /// &lt;/summary&gt; private void InitializeComponent() &#123; this.edit = new System.Windows.Forms.TextBox(); this.SuspendLayout(); // // edit // this.edit.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); this.edit.BackColor = System.Drawing.Color.White; this.edit.BorderStyle = System.Windows.Forms.BorderStyle.None; this.edit.Location = new System.Drawing.Point(3, 17); this.edit.Name = &quot;edit&quot;; this.edit.Size = new System.Drawing.Size(336, 18); this.edit.TabIndex = 0; this.edit.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.edit_KeyPress); // // MyTextBox // this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 15F); this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font; this.BackColor = System.Drawing.Color.White; this.Controls.Add(this.edit); this.Name = &quot;MyTextBox&quot;; this.Size = new System.Drawing.Size(344, 53); this.ResumeLayout(false); this.PerformLayout(); &#125; #endregion private System.Windows.Forms.TextBox edit; private void edit_KeyPress(object sender, KeyPressEventArgs e) &#123; if (e.KeyChar == &#x27;\\r&#x27;) &#123; ReturnPressed?.Invoke(this, e); &#125; &#125; public override string Text &#123; get &#123; return edit.Text; &#125; set &#123; edit.Text = value; &#125; &#125; public override Color BackColor &#123; get &#123; return base.BackColor; &#125; set &#123; edit.BackColor = value; base.BackColor = value; &#125; &#125; &#125;&#125;","categories":[{"name":"csharp","slug":"csharp","permalink":"https://lison.cc/categories/csharp/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://lison.cc/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}],"author":"Lison"},{"title":".NET序列化反序列化对象并写入JSON文件（读取JSON并反射其属性与值）","slug":"ccharp-read-json","date":"2022-04-27T07:03:22.000Z","updated":"2023-11-16T06:15:51.590Z","comments":true,"path":"ccharp-read-json/","link":"","permalink":"https://lison.cc/ccharp-read-json/","excerpt":"","text":"不使用NEWTONSOFT的JSON库，使用.net framework 4.6，序列化对象并存入JSON文件；然后读取JSON文件内容并反序列化对象；使用反射方法读取其所有属性与属性值，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using System;using System.IO;using System.Text;using System.Runtime.Serialization;using System.Runtime.Serialization.Json;using System.Reflection;namespace ConsoleApp1&#123; [DataContract] class MyConfig &#123; [DataMember] public string IP &#123; get; set; &#125; [DataMember] public int Port &#123; get; set; &#125; &#125; class Program &#123; const string CONFIG_JSON = &quot;.config&quot;; static void Main(string[] args) &#123; MyConfig config = new MyConfig(); Console.WriteLine(&quot;IP:&quot;); config.IP = Console.ReadLine(); Console.WriteLine(&quot;Port:&quot;); config.Port = int.Parse(Console.ReadLine()); string json = JSONSerializer&lt;MyConfig&gt;.Serialize(config); File.WriteAllText(CONFIG_JSON, json); Console.WriteLine(&quot;写入JSON文件.config\\r\\n开始读取文件内容&quot;); json = File.ReadAllText(CONFIG_JSON); Console.WriteLine(&quot;读取JSON文件.config\\r\\n&quot; + json); config = JSONSerializer&lt;MyConfig&gt;.DeSerialize(json); Type t = config.GetType(); PropertyInfo[] pArray = t.GetProperties(); for (int i = 0; i &lt; pArray.Length; i++) &#123; Console.WriteLine(&quot;属性&quot; + i + &quot;: &quot; + pArray[i].Name + &quot; &quot; + pArray[i].GetValue(config)); &#125; Console.Read(); &#125; &#125; public static class JSONSerializer&lt;TType&gt; where TType : class &#123; /// &lt;summary&gt; /// Serializes an object to JSON /// &lt;/summary&gt; public static string Serialize(TType instance) &#123; var serializer = new DataContractJsonSerializer(typeof(TType)); using (var stream = new MemoryStream()) &#123; serializer.WriteObject(stream, instance); return Encoding.Default.GetString(stream.ToArray()); &#125; &#125; /// &lt;summary&gt; /// DeSerializes an object from JSON /// &lt;/summary&gt; public static TType DeSerialize(string json) &#123; using (var stream = new MemoryStream(Encoding.Default.GetBytes(json))) &#123; var serializer = new DataContractJsonSerializer(typeof(TType)); return serializer.ReadObject(stream) as TType; &#125; &#125; &#125;&#125; 执行后会在当前路径生成.config文件。","categories":[{"name":"c#","slug":"c","permalink":"https://lison.cc/categories/c/"}],"tags":[{"name":"json","slug":"json","permalink":"https://lison.cc/tags/json/"}],"author":"Lison"},{"title":"java强软弱虚四大引用","slug":"android-interview-java-reference","date":"2021-08-14T09:08:23.000Z","updated":"2023-11-16T06:15:51.358Z","comments":true,"path":"android-interview-java-reference/","link":"","permalink":"https://lison.cc/android-interview-java-reference/","excerpt":"","text":"强软弱虚四大引用 - JAVA1. 强引用（GC: 不回收，死都不回收）​ 当内存不足时，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死也不收。 ​ 强引用是我们最常见的普遍对象引用，只要还有强引用指向一个对象，就能表明对象还活着，垃圾收集器不会碰这种对象。JAVA中最常见的就是强引用，把一个对象付给另一个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于科大状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收，因此强引用是造成JAVA内存泄漏的主要原因之一。 ​ 对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应的（强）引用赋值为null，一般认为就是可以被垃圾收集了。 123456789101112131415161718public class StrongR &#123; public static void main(String[] args) &#123; Object obj1 = new Object(); Object obj2 = obj1; obj1=null; System.gc(); System.out.println(obj1); System.out.println(obj2); &#125;&#125;// 輸出nulljava.lang.Object@15db9742 2. 軟引用（GC：JVM内存不夠就回收）​ 软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来说：当JVM内存充足时它不会被回收，当JVM内存不足时它会被回收。 ​ 软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用时就保留，不够用就回收。下面的代码展示了系统内存足够跟不足时软引用对象的GC情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SoftR &#123; public static void main(String[] args) &#123; Object o1 = new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;Object&gt;(o1); System.out.println(o1); System.out.println(softReference.get()); o1 = null; System.gc(); try &#123; byte[] bytes = new byte[30*1024*1024]; &#125; finally &#123; System.out.println(o1); System.out.println(softReference.get()); &#125; &#125;&#125;// 默认输出java.lang.Object@15db9742java.lang.Object@15db9742nulljava.lang.Object@15db9742 // 使用-Xms5m -Xmx5m -XX:+PrintGCDetails 启动参数后输出java.lang.Object@15db9742java.lang.Object@15db9742[GC (System.gc()) [PSYoungGen: 764K-&gt;496K(1536K)] 764K-&gt;680K(5632K), 0.0027296 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 496K-&gt;0K(1536K)] [ParOldGen: 184K-&gt;537K(4096K)] 680K-&gt;537K(5632K), [Metaspace: 2656K-&gt;2656K(1056768K)], 0.0046556 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 537K-&gt;537K(5632K), 0.0005369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 537K-&gt;537K(5632K), 0.0003787 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 537K-&gt;537K(4096K)] 537K-&gt;537K(5632K), [Metaspace: 2656K-&gt;2656K(1056768K)], 0.0017620 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 537K-&gt;537K(5632K), 0.0004040 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 537K-&gt;525K(4096K)] 537K-&gt;525K(5632K), [Metaspace: 2656K-&gt;2656K(1056768K)], 0.0047294 secs] [Times: user=0.11 sys=0.00, real=0.00 secs] nullnullException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at reference.SoftR.main(SoftR.java:16)Heap PSYoungGen total 1536K, used 30K [0x00000000ffe00000, 0x0000000100000000, 0x0000000100000000) eden space 1024K, 2% used [0x00000000ffe00000,0x00000000ffe07ad0,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 4096K, used 525K [0x00000000ffa00000, 0x00000000ffe00000, 0x00000000ffe00000) object space 4096K, 12% used [0x00000000ffa00000,0x00000000ffa834d0,0x00000000ffe00000) Metaspace used 2687K, capacity 4486K, committed 4864K, reserved 1056768K class space used 291K, capacity 386K, committed 512K, reserved 1048576K 3.弱引用（GC: 只要我被调用，我就回收，不用JVM内存够还是不够）​ 弱引用需要用java.lang.ref.WeakReference类来实现，它比弱引用的生存区更短。对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WeakR &#123; public static void main(String[] args) &#123; Object o1 = new Object(); WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;Object&gt;(o1); System.out.println(o1); System.out.println(weakReference.get()); o1 = null; System.gc(); System.out.println(o1); System.out.println(weakReference.get()); &#125;&#125;//输出java.lang.Object@15db9742java.lang.Object@15db9742nullnull -------------------------------------------------------------------------------private static void myHashmap() &#123; HashMap&lt;Integer,String&gt; map =new HashMap&lt;&gt;(); Integer key= new Integer(1); String value=&quot;hashmap&quot;; map.put(key, value); System.out.println(map); key = null; System.out.println(map); System.gc(); System.out.println(map); &#125;//输出 &#123;1=hashmap&#125;&#123;1=hashmap&#125;&#123;1=hashmap&#125;private static void myWeakHashmap() &#123; WeakHashMap&lt;Integer,String&gt; map = new WeakHashMap&lt;&gt;(); Integer key = new Integer(2); String value = &quot;weakHashmap&quot;; map.put(key, value); System.out.println(map); key = null; System.out.println(map); System.gc(); System.out.println(map); &#125;//输出&#123;2=weakHashmap&#125;&#123;2=weakHashmap&#125;&#123;&#125; 4. 虚引用​ 虚引用需要java.lang.ref.PhantomReference类来实现。顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时间都可能被垃圾回收器回收，它不能单点使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用。​ 虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅提供了一种确保对象被finalize以后，做某些事情的机制。PhantomReference的get()方法总是返回null，因此无法访问对应的引用对象，其意义在于说明一个对象已经进入了finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。​ 换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 1234567891011121314151617181920212223242526272829public class PhantomR &#123; public static void main(String[] args) throws Exception&#123; Object o1 = new Object(); ReferenceQueue&lt;Override&gt; referenceQueue=new ReferenceQueue&lt;&gt;(); PhantomReference&lt;Object&gt; phantomReference = new PhantomReference(o1, referenceQueue); System.out.println(o1); System.out.println(phantomReference.get()); System.out.println(referenceQueue.poll()); System.out.println(&quot;------------------------------&quot;); o1 = null; System.gc(); Thread.sleep(500); System.out.println(o1); System.out.println(phantomReference.get()); System.out.println(referenceQueue.poll()); &#125;&#125;//输出java.lang.Object@15db9742nullnull------------------------------nullnulljava.lang.ref.PhantomReference@6d06d69c","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"java强软弱虚四大引用","slug":"java强软弱虚四大引用","permalink":"https://lison.cc/tags/java%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/"}],"author":"Lison"},{"title":"android开发之 ListView优化策略","slug":"android-interview-listview","date":"2021-08-14T07:30:14.000Z","updated":"2023-11-16T06:15:51.360Z","comments":true,"path":"android-interview-listview/","link":"","permalink":"https://lison.cc/android-interview-listview/","excerpt":"","text":"ListView优化1.ListView如何提高效率​ 当convertView为空时，用setTag()方法为每个View绑定一个存放控件的ViewHolder对象。当convertView不为空时，重复利用已经创建的view的时候，使用getTag()方法获取绑定的ViewHolder对象，这样就避免了findViewById对控件的层层查询，二十快速定位到控件。 123456789101112131415161718192021222324252627//在外面先定义，ViewHolder静态类static class ViewHolder &#123; public ImageView img; public TextView title; public TextView info;&#125;//然后重写getView@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; if(convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.list_item, null); holder.img = (ImageView)item.findViewById(R.id.img) holder.title = (TextView)item.findViewById(R.id.title); holder.info = (TextView)item.findViewById(R.id.info); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder)convertView.getTag(); &#125; holder.img.setImageResource(R.drawable.ic_launcher); holder.title.setText(&quot;Hello&quot;); holder.info.setText(&quot;World&quot;); &#125; return convertView;&#125; 复用convertView，使用历史的view，提升效率。 自定义静态类ViewHolder，减少findViewById的次数。使用ViewHolder的好处是缓存了显示数据的试图（View），加快了UI的响应速度。 异步加载数据，分页加载数据 使用WeakReference引用ImageView对象 2. ListView如何实现分页加载 设置Listview的滚动监听器：setOnScrollListener(new OnScrollListener{….}) 在监听器中有两个方法：滚动状态发生变化的方法 onScrollStateChanged() 和ListView被滚动时调用的方法 onScroll() 在滚动状态发生改变的方法中，有三种状态： 1. SCROLL_STATE_TOUGH_SCROLL //手指按下移动的状态，触摸滑动 2. SCROLL_STATE_FLING //惯性滑动，滑翔 3. SCROLL_STATE_IDLE //静止状态 对不同的状态进行处理，分批加载数据，只关心静止状态。如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于总数量的时候，提示用户没有更多数据了。 123456789101112131415listView.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView absListView, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE) &#123; if (absListView.getLastVisiblePosition() == absListView.getCount() - 1) &#123; loadData(); &#125; &#125; &#125; @Override public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; lastItem = firstVisibleItem + visibleItemCount - 1; &#125; &#125;); 3. 如何在ScrollView中嵌入ListView​ 在ScrollView中添加一个ListView会导致ListView控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过ListView的item数量去计算ListView的显示高度，从而使其完整显示。现阶段最好的解决办法是，自定义ListView，重写onMeasure()方法，设置全部显示： 1234567891011public class ScrollListView extends ListView &#123; public ScrollListView(Context context) &#123; super(context); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125;&#125; 4.ListView中的图片错位问题是如何产生的？​ 图片错位问题的本质源于我们的ListView中使用了缓存convertView。假设一种场景，一个ListView一屏显示了9个item，那么在加载第十个item的时候，事实上该item是重复使用了第一个item，也就是说在第一个item从网络中下载图片并最终要显示的时候，其实该item已经不在当前显示区域了，此时显示的结果可能在第10个item上输出图像，这就导致了图片错位的问题。所以解决办法在于，可见的显示，不可见的隐藏。 5.关于ListView中的图片优化策略 不要直接用图片路径循环BitmapFactory.decodeFile(); 使用Options保存图片大小，不要加载图片到内存中去。 图片对其进行压缩处理。 在ListView中取图片时不要直接拿路径去取，而是使用WeakReference代替强引用（使用WeakReference、SoftReference、WeakHashMap来存储图片信息，保证资源可以即使释放）。 getView()中做图片转换时，产生的中间变量及时释放。 异步加载图片的思想： 先从内存缓存中获取图片显示（内存缓冲） 获取不到的话从SD卡中获取（SD卡缓冲） 都获取不到的话从网络下载图片并保存到SD卡同时加入内存并显示 原理： 先从内存中加载，没有则开启线程中SD卡或者网络中获取，从子线程中获取，否则快速滑动屏幕会感觉到不流畅。 与此同时，在adapter中设置一个busy变量，表示当前ListView是否处于滑动状态，如果是滑动状态则仅从内存中获取图片，否则再开线程去SD卡或者网络获取图片。 图片获取的线程使用线程池管理，避免每次都new一条新的线程；或者使用AsyncTask类，其内部也用到了线程池。从网络获取图片时，先将其保存到SD卡，然后再加载到内存，这样做的好处是加载到内存时可以做下压缩处理，减少图片所占内存。","categories":[{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Lison"},{"title":"安卓基础 - 关于ContentProvider、ContentResolver","slug":"android-interview-contentprovider","date":"2021-08-14T01:40:02.000Z","updated":"2023-11-16T06:15:51.358Z","comments":true,"path":"android-interview-contentprovider/","link":"","permalink":"https://lison.cc/android-interview-contentprovider/","excerpt":"","text":"1. 什么是ContentProvider​ ContentProvider是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承自ContentProvider，然后覆写query、insert、update、delete等方法。因为其是安卓四大组件之一必须在AndroidManifest.xml文件中进行注册。把自己的数据通过uri形式共享出去。 123&lt;provider android:exported=&quot;true&quot; android:name=&quot;com.itheima.contenProvider.provider.PersonContentProvider&quot;android:authorities=&quot;com.itheima.person&quot; /&gt; 第三方可以通过ContentResolver来访问该Provider。 2. 为什么要用ContentProvider？它和sql的实现上有什么差别？ ContentProvider屏蔽了数据存储的细节，对外提供统一的数据访问接口。可以实现不同app之间的数据共享。 更好的数据访问权限管理。ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。 ContentProvider封装了跨进程共享的逻辑，我们只需要URI（Uniform Resource Identifier，即统一资源标识符）即可访问数据。由系统来管理ContentProvider的创建、生命周期、及访问的线程分配，简化我们在应用间的共享数据（进程间通信）的方式。我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在的进程是启动还是未启动。 ​ sql也有增删改查的方法，但是sql只能查询本应用下的数据库。而ContentProvider还可以去增删改查本地.xml等类型的文件。 3.运行在主线程的ContentProvider为什么不会影响主线程的UI操作？​ ContentProvider的onCreate()是运行在UI线程的，而query()、insert()、delete()、update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程。因为那些方法可能同时被多个线程调用，所以他们的数据同步问题，要在实现逻辑中处理好。​ ContentProvider实现了进程间通信也是基于Binder机制的，所以会回到Binder的线程处理问题。并不是每个ContentProvider都会有一个线程池，而一个进程会共有一个线程池，其实就是Binder线程池。","categories":[{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Lison"},{"title":"安卓基础 - 关于Broadcast 和 Broadcast Receiver","slug":"android-interview-broadcast-receiver","date":"2021-08-13T09:01:46.000Z","updated":"2023-11-16T06:15:51.355Z","comments":true,"path":"android-interview-broadcast-receiver/","link":"","permalink":"https://lison.cc/android-interview-broadcast-receiver/","excerpt":"","text":"1. 什么是Broadcast和Broadcast ReceiverBroadcast（广播）是一种广泛在应用程序之间传输信息的机制，而BroadcastReceiver（广播接收器）则是用于接收来自系统和应用的广播对其进行响应的组件。Android提供了一套完整的API，允许应用程序自由的发送和接收广播，其中又用到可以传递信息的Intent。广播其实是一种订阅者模式，所以当然需要先register，register的方式有两种： 静态注册 在manifest的application节点中添加receiver标签。静态注册意味着应用在安装后就开始接收广播，一旦接收广播系统就会打开应用进程，但是如果应用是在stopped状态下就不会接收到广播。 动态注册 1234BroadcastReceiver br = new MyBroadcastReceiver();IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br, filter); 记得在onDestroy时调用unregisterReceiver避免内存泄漏。 广播的发送和接收方法： 普通广播普通广播是一种完全异步执行的广播，在广播发出后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此他们接收的顺序是不固定的。另外，接收器不能拦截普通广播。 有序广播有序广播是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递，所以此时的广播接收器是有先后顺序的，且优先级（priority）高的广播接收器会先收到广播消息。有序广播可以被接收器截断使得后面的接收器无法接收到它。应用场景比如收到短信，电话拨入。 123// 发送一个有序广播，广播接收器不指定权限(null)，接收顺序按照manifest配置的广播接收器的priority优先级Intent intent = new Intent(&quot;com.example.MY_BROADCAST&quot;);sendOrderedBroadcast(intent, null); 12345678// 在Broadcast Receiver的onReceive()中截断广播，不继续发送，则顺序之后的广播接收器将不会收到广播abortBroadcast();//传递结果到下一个广播接收器int code = 0;String data = &quot;hello&quot;;Bundle bundle = null;setResult(code, data, bundle); 本地广播 上述两种广播都属于全局广播，即发出的广播可被其他应用程序接收到，并且我们也可以接收到其他任何应用程序发送的广播。为了能够简单的解决全局广播可能带来的安全性问题，Android引入了一套本地广播机制，使用这个机制发出的广播只能够再应用程序内部进行传递，并且广播接收器也只能接收本应用程序发出的广播。 API21的Support v4包中新增本地广播 LocalBroadcastManager，用法很简单，只需要把调用context.sendBroadcast、registerReceiver、unregisterReceiver的地方换为LocalBroadcastManager.getInstance(Context context)中对应的函数即可。创建广播的过程和普通广播是一样的，不赘述。 1234// 创建广播接收器receiver = new MyBroadcastReceiver();// 注册本地广播LocalBroadcastManager.getInstance(ReceiverActivity.this).registerReceiver(receiver, new IntentFilter(&#x27;com.example.xxx&#x27;)); 12// 反注册receiverLocalBroadcastManager.getInstance(ReceiverActivity.this).unregisterReceiver(receiver); 1234// 发送异步广播final Intent intent = new Intent();intent.setAction(&quot;com.example.xxx&quot;);LocalBroadcastManager.getInstance(ReceiverActivity.this).sendBroadcast(intent); 1LocalBroadcastManager.getInstance(ReceiverActivity.this).sendBroadcastSync(intent); 注意一点，本地广播是无法通过静态注册方式来接受的，因为静态注册主要就是为了让程序在未启动的情况下也能收到广播，而发送本地广播时，应用程序肯定已经启动了，也完全不需要使用静态注册的功能。 粘性广播 通过Context.sendStickyBroadcast()方法可发送粘性广播，这种广播会一直滞留，当有匹配该广播的接收器被注册后，该接收器就会收到此条广播。发送粘性广播需要BROADCAST_STICKY权限。 1&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt; sendStickyBroadcast()只保留最后一条广播，并且一直保留下去，这样即使已经有广播接收器处理了该广播，一旦又有匹配的广播接收器被注册，该粘性广播仍会被接收。如果只想处理一遍该广播，可通过**removeStickyBroadcast()**方法来实现。 系统广播 常用系统广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162intent.action.AIRPLANE_MODE;//关闭或打开飞行模式时的广播Intent.ACTION_BATTERY_CHANGED;//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册Intent.ACTION_BATTERY_LOW;//表示电池电量低Intent.ACTION_BATTERY_OKAY;//表示电池电量充足，即从电池电量低变化到饱满时会发出广播Intent.ACTION_BOOT_COMPLETED;//在系统启动完成后，这个动作被广播一次（只有一次）。Intent.ACTION_CAMERA_BUTTON;//按下照相时的拍照按键(硬件按键)时发出的广播Intent.ACTION_CLOSE_SYSTEM_DIALOGS;//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息Intent.ACTION_CONFIGURATION_CHANGED;//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)Intent.ACTION_DATE_CHANGED;//设备日期发生改变时会发出此广播Intent.ACTION_DEVICE_STORAGE_LOW;//设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用？Intent.ACTION_DEVICE_STORAGE_OK;//设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用？Intent.ACTION_DOCK_EVENT;////发出此广播的地方frameworks\\base\\services\\java\\com\\android\\server\\DockObserver.javaIntent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;////移动APP完成之后，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;//正在移动APP时，发出的广播(移动是指:APP2SD)Intent.ACTION_GTALK_SERVICE_CONNECTED;//Gtalk已建立连接时发出的广播Intent.ACTION_GTALK_SERVICE_DISCONNECTED;//Gtalk已断开连接时发出的广播Intent.ACTION_HEADSET_PLUG;//在耳机口上插入耳机时发出的广播Intent.ACTION_INPUT_METHOD_CHANGED;//改变输入法时发出的广播Intent.ACTION_LOCALE_CHANGED;//设备当前区域设置已更改时发出的广播Intent.ACTION_MANAGE_PACKAGE_STORAGE;//Intent.ACTION_MEDIA_BAD_REMOVAL;//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播//广播：扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)Intent.ACTION_MEDIA_BUTTON;//按下&quot;Media Button&quot; 按键时发出的广播,假如有&quot;Media Button&quot; 按键的话(硬件按键)Intent.ACTION_MEDIA_CHECKING;//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?Intent.ACTION_MEDIA_EJECT;//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播?//广播：用户想要移除扩展介质（拔掉扩展卡）。Intent.ACTION_MEDIA_MOUNTED;//插入SD卡并且已正确安装（识别）时发出的广播//广播：扩展介质被插入，而且已经被挂载。Intent.ACTION_MEDIA_NOFS;//Intent.ACTION_MEDIA_REMOVED;//外部储存设备已被移除，不管有没正确卸载,都会发出此广播？// 广播：扩展介质被移除。Intent.ACTION_MEDIA_SCANNER_FINISHED;//广播：已经扫描完介质的一个目录Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;//Intent.ACTION_MEDIA_SCANNER_STARTED;//广播：开始扫描介质的一个目录Intent.ACTION_MEDIA_SHARED;// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。 Intent.ACTION_MEDIA_UNMOUNTABLE;//Intent.ACTION_MEDIA_UNMOUNTED// 广播：扩展介质存在，但是还没有被挂载 (mount)。Intent.ACTION_NEW_OUTGOING_CALL;Intent.ACTION_PACKAGE_ADDED;//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播） Intent.ACTION_PACKAGE_CHANGED;//一个已存在的应用程序包已经改变，包括包名Intent.ACTION_PACKAGE_DATA_CLEARED;//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）Intent.ACTION_PACKAGE_INSTALL;//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？//Intent.ACTION_PACKAGE_REMOVED;//成功的删除某个APK之后发出的广播//一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_REPLACED;//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）Intent.ACTION_PACKAGE_RESTARTED;//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）Intent.ACTION_POWER_CONNECTED;//插上外部电源时发出的广播Intent.ACTION_POWER_DISCONNECTED;//已断开外部电源连接时发出的广播Intent.ACTION_PROVIDER_CHANGED;//Intent.ACTION_REBOOT;//重启设备时的广播Intent.ACTION_SCREEN_OFF;//屏幕被关闭之后的广播Intent.ACTION_SCREEN_ON;//屏幕被打开之后的广播Intent.ACTION_SHUTDOWN;//关闭系统时发出的广播Intent.ACTION_TIMEZONE_CHANGED;//时区发生改变时发出的广播Intent.ACTION_TIME_CHANGED;//时间被设置时发出的广播Intent.ACTION_TIME_TICK;//广播：当前时间已经变化（正常的时间流逝）。//当前时间改变，每分钟都发送，不能通过组件声明来接收，只有通过Context.registerReceiver()方法来注册Intent.ACTION_UID_REMOVED;//一个用户ID已经从系统中移除发出的广播//Intent.ACTION_UMS_CONNECTED;//设备已进入USB大容量储存状态时发出的广播？Intent.ACTION_UMS_DISCONNECTED;//设备已从USB大容量储存状态转为正常状态时发出的广播？Intent.ACTION_USER_PRESENT;//Intent.ACTION_WALLPAPER_CHANGED;//设备墙纸已改变时发出的广播 注意事项：不要在广播里添加过多逻辑或者进行任何耗时操作，因为在广播中是不允许开辟线程的，当onReceiver()方法运行较长时间（超过10秒）还没有结束的话，那么程序会报错（ANR），广播更多的时候扮演的是一个打开其他组件的角色，比如启动Service，Notification，Activity等。 12//如何测试广播adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 广播的发送者和接收者事先是不需要知道对方的存在的，这样带来的好处便是，系统各个组件可以松耦合的组织在一起，这样系统就具有高度的可扩展性，容易与其他系统进行集成。 2. 为什么安装在SD卡中的应用无法收到开机广播在Android API Level8之后，程序可以安装在SD卡上（manifest android:installLocation选项）。如果程序安装在SD卡上，系统启动完成发送BOOT_COMPLETED广播之后，SD卡才会挂在，因此程序无法监听到该广播。 解决办法： 同时监听开机和SD卡挂在广播（不能只监听挂在就认为系统以开机，因为有的手机没有sd卡） 如何实现一个能同时监听开机BOOT_COMPLETED和挂载MEDIA_MOUNTED的广播接收器呢？理论上只要将MEDIA_MOUNTED的intent-filter和BOOT_COMPLETED的intent-filter放在一起就行了，但是放在同一个intent-filter里，BOOT_COMPLETED会监听不到，需要单独放置再两个intent-filter中： 1234567891011&lt;receiver android:name=&quot;.Ge&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.MEDIA_MOUNTED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.MEDIA_UNMOUNTED&quot;/&gt; &lt;data android:scheme=&quot;file&quot;&gt; &lt;/data&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 无法接收开机广播的情况还有以下几种： BOOT_COMPLETED对应的action和uses-permission没有一起添加 应用安装到了SD卡内，安装再sd卡内的应用是收不到BOOT_COMPLETED广播的 系统开启了Fast Boot模式，这种模式下系统启动并不会发送BOOT_COMPLETED广播 应用程序安装后从来没有启动过，这种情况下应用程序接收不到任何广播，包括BOOT_COMPLETED、ACTION_PACKAGE_ADDED、CONNECTIVITY_ACTION等。系统为了加强安全性控制，应用程序安装后或是（设置）应用管理中被强制关闭后处于stopped状态，在这种状态下接收不到任何广播。直到被启动过（用户打开或是其他应用调用）才会脱离这种状态，所以Androiod 3.1之后 应用程序无法在安装后自己启动 没有UI的程序必须通过其他应用激活才能启动，如它的Activity、Service、Content Provider被其他应用调用。 针对上述应用处于stopped的情况，在发送广播时，可以使用允许发送给stopped状态下的应用FLAG 1234// 默认是FLAG_EXCLUDE_STOPPED_PACKAGESintent = new Intent(intent);// 允许发送给stopped状态下的应用intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES); 所以为了确保可以接收到BOOT_COMPLETED广播： 安装应用后，首先要启动一次 添加一下权限： 12&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RESTART_PACKAGES&quot; /&gt; &lt;receiver android:name=&quot;.BootBroadcastReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 1234567891011121314151617181920212223244. ```java public class BootBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //接收广播：系统启动完成后运行程序 if (intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) &#123; Intent ootStartIntent = new Intent(context, Login_Activity.class); ootStartIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(ootStartIntent); &#125; //接收广播：安装更新后，自动启动自己。 if (intent.getAction().equals(Intent.ACTION_PACKAGE_ADDED) || intent.getAction().equals(Intent.ACTION_PACKAGE_REPLACED)) &#123; Intent ootStartIntent = new Intent(context, Login_Activity.class); ootStartIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(ootStartIntent); &#125; &#125; &#125; 最后一种情况，看下系统中是否有360管家之类的流氓软件，他们会将一些开机广播给屏蔽掉，加快开机速度，只需将其打开即可。","categories":[{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Lison"},{"title":"安卓基础 - 关于Service","slug":"android-interview-service","date":"2021-08-13T01:40:55.000Z","updated":"2023-11-16T06:15:51.362Z","comments":true,"path":"android-interview-service/","link":"","permalink":"https://lison.cc/android-interview-service/","excerpt":"","text":"1. 什么是Service，Service是否在主线程中执行？12345&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot; &gt;&lt;/service&gt; ​ Service是Android中经常使用的四大组件之一，它是Android中实现程序后台执行的解决方式，非常适用于执行那些不需要和用户交互并且还要长期执行的任务。 ​ 这里的后台并非子线程的意思。Service默认执行在UI线程中，因此，不要在Service中执行耗时的操作。如有必要，需要在Service中创建子线程来完成耗时操作。 ​ Service的执行不依赖于用户界面，即使应用被切换到后台或者用户打开了另外一个应用程序，Service仍然能够保持正常执行，这也是Service的使用场景。当某个应用程序进程被杀掉时，全部依赖于该进程的Service也会停止运行。 ​ Service的优先级高于后台挂起的Activity，当然也高于Activity所创建的Thread，因此，系统可能在内存不足时优先杀死后台的Activity或者Thread，而不会轻易杀死Service组件，即使被迫杀死Service，也会在资源可用是重启被杀死的Service。 2. Service与Thread的区别，什么场景应该使用ServiceThread是程序执行的最小单元，可以用Thread执行一些异步任务。 Servie是系统的组件，它由系统进程托管（ServiceManager）；它们之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是Binder，它是在linux层交换信息的一种IPC。而Thread是由本应用程序托管。 thread与activity不存在依赖关系，即activity被销毁，在activity中启动的thread有可能还在继续运行，鉴于activity已经销毁，则肯定也失去了对thread的控制权，并且在一个activity中创建的子线程，另一个activity无法对其进行操作。但是Service就不同了，所有的activity都可以与service进行关联，然后可以很方便的操作其中的方法，即使activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中的Binder实例。因此使用Service来处理后台任务，activity就可以放心的finish，完全不需要担心无法对后台任务进行控制的情况。 其实Service和Thread根本不是一个级别的东西，Service是系统四大组件之一，Thread只是一个用来执行后台任务的工具类，它可以在Activity中被创建，也可以在Service中被创建。因此我们不应该讨论该使用Service还是Thread，而应该讨论在什么地方创建Thread。 典型的应用中，它可以在以下三个位置被创建，不同的位置，其生命周期也不一样，所以，我们应该根据该Thread的目标生命周期来决定是在Service中创建Thread还是在Activity中创建它。 在Activity中被创建。这种情况下，一般在onCreate时创建，在onDestroy中销毁，否则Activity销毁后，Thread会依然在后台运行。这种情况下，Thread的生命周期为整个Activity的生命周期。所以，在Activity中创建的Thread只适合完成一些依赖Activity本身有关的任务，比如定时更新一下Activity的控件状态等。 核心特点：该Thread就是为这个Activity服务的，完成这个特定的Activity交代的任务，主动通知该Activity一些消息和事件，Activity销毁后，该Thread也就没有存活的意义了。 在Application中被创建。这种情况一般在自定义的Application类中，onCreate方法，在其中创建Thread，当然，也需要在onTerminate方法中销毁Thread，否则，如果Thread没有退出的话，即使整个Application退出了，线程依然会在后台运行。这种情况下，Thread的生命周期即为整个Application的生命周期。所以，在Application中创建的Thread，可以执行一些整个应用级别的任务，比如定时检查一下网络连接状态等。 核心特点：该Thread的终极目标是为整个APP各个Activity服务的，包括完成某个Activity交代的任务，主动通知某个Activity一些消息和事件等，APP退出之后该Thread也就没有存活的意义了。 以上两种情况，Thread的生命周期都不应该超出整个应用程序的生命周期，也就是说，整个APP退出之后，Thread都应该完全退出，这样才不会出现内存泄漏或者僵尸线程。那么如果你希望整个APP退出之后依然能够运行该Thread，那么就应该把Thread放到Service中去创建和启动了。 在Service中被创建。这是保证最长生命周期的Thread的唯一方式，只要整个Service不退出，Thread就可以一直在后台执行，一般在Service的onCreate中创建，在onDestroy中销毁。所以在Service中创建的Thread，适合长期执行一些独立于APP的后台任务，比如在Service中保持与服务端的长连接。 3. Service生命周期​ Service有绑定和非绑定模式，以及这两种模式的混合使用。不同的使用方法生命周期也不同。 ​ 非绑定模式：当第一次调用startService的时候，执行的方法依次为onCreate() onStartCommand()，当Service关闭时候掉用onDestroy() ​ 绑定模式：第一次调用bindService()的时候，执行的方法为onCreate() onBind() ，解除绑定（掉用unBindService())的时候会执行onUnbind() onDestroy()方法。 上面的两种生命周期是在相对单纯的模式下的情形。在开发过程中必须注意Service的实例只会有一个，也就是说如果当前要启动的Service已经存在了那么就不会再次创建该Service当然也不会再次掉用onCreate()方法。 客户端通过bindService()方法绑定服务端。当调用这个方法时，必须要提供一个ServiceConnection，用它来建立和服务端的绑定。虽然bindService()方法没有返回值，但是当Android系统建立服务端和客户端的连接时，会调用ServiceConnection对象的onServiceConnected方法来传递一个IBinder到客户端，用于和服务端通信。服务异常终止时系统会回调这个方法onServiceDisconnected()。当客户端取消绑定时，系统“绝对不会”调用该方法。 一个Service 可以被多个客户端绑定，但是Android系统只会在第一个客户端绑定服务端时，调用service的onBind()方法去获取IBinder对象。之后系统会传递这个IBinder到绑定服务端的其他客户端（这时是不会再次调用onBind()方法的）。如果服务不是通过startService()方法启动的，那么当最后一个客户端和服务端解绑时，系统就会摧毁掉这个服务。 Service的生命周期图如下所示： 4. Service客户端与服务端进行交互的编程接口定义方式 扩展Binder类 ​ 当我们的服务属于本应用的一部分，和应用运行在同一个进程中时，我们采用这种方式来创建这个交互的接口，继承Binder类，并在onBind()返回一个它的实例对象。这样客户端就可以接收到这个IBinder对象，并用它直接访问Binder实现类或者Service中的公有方法。我们往往在服务仅仅作为应用的一部分运行在后台时采用这种方式。但是如果我们需要服务能被其他应用或者其他线程访问时，就不能采用这样的方法了。 使用Messenger ​ 当我们需要跨进程通信（IPC）时采用这种方式，这种方式需要在Service中定义一个Handler，用这个Handler去响应不同的Message。这样的一个Handler是基于Messenger的，可以通过IBinder传递到客户端，客户端可以利用这个Messenger向服务端发送命令。同样的客户端也可以定义一个Messenger，传递给服务端让其可以发送消息回客户端。这是一种最便捷的跨进程通讯方式，使用Messenger实现时，所有的请求都被放在单一的线程中，这样服务就是线程安全的。Messenger内部实现采用的是AIDL，因此传递的消息对象必须是可序列化的。 使用AIDL ​ AIDL(Android Interface Definition Language 安卓接口定义语言)执行所有将对象分解成原语的工作，操作系统可以识别这些源于并将它们编组到各进程中，以执行IPC。上述采用的Messenger方法实际是以AIDL作为其底层结构。如上所述，Messenger会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。不过，如果你想让服务同时处理多个请求，则可直接使用AIDL。在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。如需直接使用AIDL，需要创建一个定义变成接口的.aidl文件。Android SDK工具利用该文件生成一个实现接口并处理IPC的抽象类，随后可在服务内对其进行扩展。注：大多数应用都不会使用AIDL来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL并不适合大多数应用。 5. 什么是IntentService，典型使用场景？IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程（Worker Thread）来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们手动去控制。另外，可以启动多次IntentService，而每一个耗时操作会以工作队列的方式在IntentService和onHandlerIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。 还有一种说明是：所有请求都在一个单独的工作线程中，不会阻塞应用程序的主线程（UI Thread），同一时间之处理一个请求。使用IntentService省去了我们在Service中手动开线程的麻烦，并且当操作完成时，无需手动停止Service。 ​ 典型使用场景：比如一项任务分成几个子任务，子任务按照顺序先后执行，子任务全部执行完后，这项任务才算成功。那么，利用几个子线程顺序执行时可以达到这个目的，但是每个线程必须去手动控制，而且得在一个子线程执行完后，再开启另一个子线程。或者，全部放到一个线程中让其顺序执行，这样都可以做到。但是如果这是一个后台任务，就得放到Service里面，由于Service和Activity是同级的，所以，要执行耗时任务，就得在Service里开子线程来执行，此时最合适的方式就是使用IntentService。","categories":[{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Lison"},{"title":"安卓基础 - 关于Activity","slug":"android-interview-activity","date":"2021-08-11T07:01:19.000Z","updated":"2023-11-16T06:15:51.355Z","comments":true,"path":"android-interview-activity/","link":"","permalink":"https://lison.cc/android-interview-activity/","excerpt":"","text":"1. 什么是ActivityActivity是安卓四大组件之一，一般的一个用户交互界面对应一个Activiy。activity是Context的子类，同时实现了window.callback和keyevent.callback，可以处理用户与窗体交互的事件。常用的有FragmentActivity、ListActivity、PreferenceActivity、TabActivity等。 2.Activity的生命周期Activity从创建到销毁有多种状态，从一个状态切换到另一个状态时会激发相应的回调方法，这些回调方法包括：onCreate onStart onResume onPause onStop onDestroy 这些方法都是两两对应的，onCreate创建对应onDestroy销毁；onStart可见于onStop不可见；onResume可编辑（即获得焦点）与onPause（可见但未获取焦点，例如被对话框遮挡）；如果界面有共同特点或者功能的时候，一般会自定义一个BaseActivity，例如统一处理进度对话框的显示与销毁。 3. 如何保存Activity的状态或者说Activity重启如何保存数据Activity的状态通常情况下系统会自动保存，只有当我们需要保存额外的数据时才需要用到这样的功能。一般来说，onPause()和onStop()方法被调用后activity实例仍然存在于内存中，activity的所有信息和状态数据不会消失，当activity重新回到前台之后，所有的改变都会得到保留。 但是当系统内存不足时，onPause()和onStop()方法被调用后activity可能会被系统摧毁，此时内存中就不会存有该activity的实例对象了。如果之后这个activity重新回到前台，之前所作的改变都会消失。为了避免此种情况的发生，我们可以重写onSavedInstanceState()方法。onSavedInstanceState()方法接收一个Bundle类型的参数，开发者可以将状态数据存储到这个Bundle对象中，这样即使activity被系统销毁，当用户重新启动这个activity而调用它的onCreate()方法时，上述的Bundle对象会作为实参传递给onCreate()方法，开发者可以从Bundle对象中取出保存的数据，然后利用这些数据将activity恢复到被销毁之前的状态。 需要注意的是onSavedInstanceState()方法并不是一定会被系统调用，因为有些场景是不需要保存状态数据的。比如用户按下BACK键退出activity时，用户显然是要关闭这个activity，此时是没有必要保存数据以供下次恢复的，也就是onSavedInstanceState()方法不会被调用。如果系统决定调用onSavedInstanceState()方法，那调用将发生在onPause()或onStop()方法之前。 123456789101112131415161718private String TAG = MainActivity.class.getSimpleName();@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null) &#123; Log.e(TAG, savedInstanceState.getString(&quot;test&quot;)); &#125; &#125; @Override protected void onSaveInstanceState(@NonNull @org.jetbrains.annotations.NotNull Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString(&quot;test&quot;, &quot;letme&quot;); Log.e(TAG, &quot;onSaveInstanceState&quot;); &#125; 4. 两个Activity之间跳转时必然会执行的是哪几个方法？一般情况下比如有两个activity，分别为A和B。当在A中启动B时，A会调用onPause()方法，然后B调用onCreate()、onStart()、onResume()方法。 这个时候B覆盖了A，A会调用onStop()方法，如果B窗体是透明的，或者是对话框样式，则不会调用A的onStop()方法。 5. 横竖屏切换时Activity的生命周期此时的生命周期跟Manifest.xml中的配置有关系。 当不设置activity的android:configChanges时，屏幕切换时会重新调用各个生命周期，默认首先销毁当前activity，然后重新加载。 当设置了activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，屏幕切换不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 6. 如何退出Activity，如何安全退出已调用多个Activity的Application？ 通常用户退出activity只需按返回键，代码退出activity直接调用finish()方法即可。 记录打开的Activity：也可维护一个Activity栈，在需要退出时，依次弹出每个activity并执行finish()方法。 发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity受到广播后，关闭即可。 递归退出：再打开新的activity时使用startActivityForResult，然后自己设定标记，在onActivityResult中处理，递归关闭。 通过Intent的Flag来实现：intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)激活一个新的activity。此时如果该任务栈中已经有该activity，那么系统会把这个activity上面所有的activity干掉。相当于给activity设置启动模式为SingleTop。 7. Activity四种启动模式 启动模式 简介 standard 默认模式，Activity会被实例化多次 singleTop 如果栈顶存在Activity实例则通过onNewIntent重用，否则重新创建Activity实例。只要不在栈顶则重新创建，任务栈中可能存在多个实例。 singleTask 只要在任务栈中存在Activity实例就重用，否则重新创建Activity实例。TaskId不变。 singleInstance 在新的任务栈中开启，并且全局只有一个Activity实例。TaskId会变化。 8. Android中的Context，Activity，Service，Application有什么区别？Context具体作用包括： 启动新的Activity 启动和停止Service 发送广播消息（Intent） 注册广播消息（Intent）接收者 访问APK中各种资源，例如Resources和AssetManager 创建View 访问Package的相关信息 APK的各种权限管理 相同：Activity和Service都继承自ContextWrapper，而ContextWrapper又是Context的子类，那么Activity、Service最终也都继承自Context；而Applilcation直接继承自Context。Context字面意思是上是上下文的意思，在实际应用中它也确实起到了管理上下文环境中各个参数和变量的作用，方便我们可以简单的访问到各种资源。 不同：维护的生命周期不同。Context维护的是当前Activity的生命周期，Application维护的是整个项目的生命周期。 使用Context时需要注意内存泄漏问题，需注意一下几个方面： 不要让生命周期长的对象引用activity context，即保证引用activity的对象的生命周期要与activity本身是一样的。 对于生命周期长的对象，可以使用application context。 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象的引用导致的生命周期变化。 9. Activity和Service通信的两种方式 Binder对象具体实现两个组件之间的交互。使用startService将只触发一次onCreate，多次调用startService将多次触发onStartCommand；而使用bindService不会触发onStartCommand，同样使用bindService启动的Service生命周期会跟随activity的生命周期。ServiceConnection接口的onServiceConnected()方法的触发条件为：bindService()方法执行成功同时onBind()方法返回非空IBinder对象。onServiceDisconnected() 在连接正常关闭的情况下是不会被调用的（即调用unBindService之后不会调用）该方法只在Service 被破坏了或者被杀死的时候调用. 例如, 系统资源不足, 要关闭一些Services, 刚好连接绑定的 Service 是被关闭者之一, 这个时候onServiceDisconnected() 就会被调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyService extends Service &#123; DownloadBinder downloadBinder=new DownloadBinder();class DownloadBinder extends Binder &#123; public void startDownload()&#123; Log.e(TAG,&quot;start download&quot;); &#125; public int getProcess()&#123; Log.e(TAG,&quot;get Process&quot;); return 0; &#125; &#125; private String TAG = MyService.class.getSimpleName(); @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.e(TAG,&quot;onBind&quot;); return downloadBinder; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.e(TAG,&quot;onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onCreate() &#123; Log.e(TAG,&quot;onCreate&quot;); super.onCreate(); &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.e(TAG,&quot;onUnbind&quot;); return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; Log.e(TAG,&quot;onDestroy&quot;); super.onDestroy(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; private String TAG = MainActivity.class.getSimpleName(); Button btnBind, btnUnbind; Context mContext; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null) &#123; Log.e(TAG, savedInstanceState.getString(&quot;test&quot;)); &#125; mContext = this; btnBind = findViewById(R.id.btn_bind); btnUnbind = findViewById(R.id.btn_unbind); btnBind.setOnClickListener(v -&gt; &#123; Intent intent = new Intent(mContext, MyService.class); bindService(intent, serviceConnection, BIND_AUTO_CREATE); startService(intent); Toast.makeText(mContext, &quot;Service Bind&quot;, Toast.LENGTH_LONG).show(); &#125;); btnUnbind.setOnClickListener(v -&gt; &#123; unbindService(serviceConnection); Toast.makeText(mContext, &quot;Service unBind&quot;, Toast.LENGTH_LONG).show(); &#125;); &#125; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e(TAG, &quot;onServiceConnected&quot;); MyService.DownloadBinder binder =(MyService.DownloadBinder)service; binder.startDownload(); binder.getProcess(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e(TAG, &quot;onServiceDisconnected&quot;); &#125; &#125;; @Override protected void onSaveInstanceState(@NonNull @org.jetbrains.annotations.NotNull Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString(&quot;test&quot;, &quot;letme&quot;); Log.e(TAG, &quot;onSaveInstanceState&quot;); &#125;&#125; 使用广播（略）","categories":[{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Lison"},{"title":"Android ANR产生的原因及其定位分析","slug":"android-detect-anr","date":"2021-07-14T02:02:54.000Z","updated":"2023-11-16T06:15:51.354Z","comments":true,"path":"android-detect-anr/","link":"","permalink":"https://lison.cc/android-detect-anr/","excerpt":"ANR产生的原因： KeyDispatchTimeout View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应。 BroadcastTimeout 原因是BroadcastReceiver的onReceive()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。 ServiceTimeout 原因是Service的各个生命周期函数在特定时间（20秒）内无法完成处理。","text":"ANR产生的原因： KeyDispatchTimeout View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应。 BroadcastTimeout 原因是BroadcastReceiver的onReceive()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。 ServiceTimeout 原因是Service的各个生命周期函数在特定时间（20秒）内无法完成处理。 典型的ANR问题场景 应用程序UI线程存在耗时操作，例如在UI线程中进行网络请求，数据库操作或者文件操作等，可能会导致UI线程无法及时处理用户输入等。当然在Android 4.0之后，如果在UI线程中进行网络操作，将会抛出NetworkOnMainThreadException异常。 应用程序的UI线程等待子线程释放某个锁，从而无法处理用户的输入。 耗时的动画需要大量的计算工作，可能导致CPU负载过重。 ANR的定位和分析见：/data/anr/traces.txt ，关于此文件的详细介绍此处不展开。 ANR的避免和检测StrictMode 严格模式StrictMode是Android SDK提供的一个用来检测代码中是否存在违规操作的工具类，StrictMode主要检测两大类问题： 线程策略ThreadPolicy detectCustomSlowCalls 检测自定义耗时操作 detectDiskReads 检测是否存在磁盘读取操作 detectDiskWrites 检测是否存在磁盘写入操作 detectNetwork 检测是否存在网络操作 虚拟机策略VmPolicy detectActivityLeaks 检测是否存在Activity泄漏 detectLeakedClosableObjects 检测是否存在未关闭的Closable对象泄漏 detectLeakedSqlLiteObjects 检测是否存在Sqlite对象泄漏 setClassInstanceLimit 检测类实例个数是否超过限制 可以看到，其中的ThreadPolicy可以用来检测可能存在的主线程耗时操作，解决这些检测到的问题能够减少应用发生ANR的概率。需要注意的是，我们只能在Debug版本中使用它，正式版需要关闭。StrictMode的使用方法如下： 1234567891011@overrideprotected void onCreate(Bundle savedInstanceState)&#123; if(BuildConfig.DEBUG)&#123; //开启线程模式 StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build()); //开启虚拟机模式 StrictMode.setVmPolicy(new VmPolicy.Builder().detectAll().penaltyLog().build()); &#125; super.onCreate(savedInstanceState);&#125; 上面的初始化代码调用penaltyLog()表示在logcat中打印日志，调用detectAll方法表示启动所有的检测策略，我们也可以根据应用的具体需求只开启某些策略，语句如下： 12345678910111213StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectDiskReads() .detectDiskWrites() .detectNetwork() .penaltyLog() .build()) StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectActivityLeaks() .detectLeakedSqlLiteObjects() .detectLeakedClosableObjects() .penaltyLog() .build()) BlockCanary UI卡顿检测BlockCanary是一个非嵌入式的性能监控函数库，它的用法和LeakCanary类似，只不过后者监控应用的内存泄漏，而BlockCanary主要用来监控应用主线程的卡顿。它的基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束时的时间点来判断是否超过设定的时间，如果是，则判断为主线程卡顿。代码如下： 1234567dependencies&#123; compile &#x27;com.github.moduth:blockcanary-android:1.2.1&#x27; //仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用 debugCompile &#x27;com.github.moduth:blockcanary-android:1.2.1&#x27; releaseCompile &#x27;com.github.moduth:blockcanary-android:1.2.1&#x27;&#125; 然后在Application类中进行配置和初始化即可： 1234567891011public class DemoApplication extends Application&#123; @override public void onCreate()&#123; //在主进程初始化调用 BlockCanary.install(this, new AppBlockCanaryContext()).start(); &#125;&#125;public class AppBlockCanaryContext extends BlockCanaryContext&#123; // 实现各种上下文，包括应用标识符、用户uid、网络类型、卡慢判断阈值、Log保存位置等&#125; LeakCanary 内存泄漏检测","categories":[{"name":"Android","slug":"Android","permalink":"https://lison.cc/categories/Android/"}],"tags":[{"name":"Android ANR","slug":"Android-ANR","permalink":"https://lison.cc/tags/Android-ANR/"}],"author":"Lison"},{"title":"Android触摸事件传递机制","slug":"android-touch-event-delivery-mechanism","date":"2021-07-13T02:12:28.000Z","updated":"2023-11-16T06:15:51.368Z","comments":true,"path":"android-touch-event-delivery-mechanism/","link":"","permalink":"https://lison.cc/android-touch-event-delivery-mechanism/","excerpt":"1. 要解决的问题 Android开发中经常会遇到多个View，ViewGroup嵌套的问题，例如ViewPager中嵌套Fragment，而在Fragment中需要实现一个横向滚动的广告栏，这时候就会遇到广告栏的滑动事件和ViewPager的滑动事件相互冲突的问题。","text":"1. 要解决的问题 Android开发中经常会遇到多个View，ViewGroup嵌套的问题，例如ViewPager中嵌套Fragment，而在Fragment中需要实现一个横向滚动的广告栏，这时候就会遇到广告栏的滑动事件和ViewPager的滑动事件相互冲突的问题。 2. 触摸事件的类型触摸事件对应的是MotionEvent类，事件的类型主要有以下三种： ACTION_DOWN 用户手指按下的操作，一个按下操作标志着一次触摸事件的开始。 ACTION_MOVE 用户手指按压屏幕后，在松开之前，如果移动的距离超过一定的阈值，那么会被判定为ACTION_MOVE操作，一般情况下，手指的轻微移动都会出发一系列的移动事件。 ACITON_UP 用户手指离开屏幕的操作，一次抬起操作标志着一次触摸事件的结束。 在一次触摸屏幕操作中，ACTION_DOWN和ACTION_UP这两个事件是必须的，而ACTION_MOVE视情况而定，如果用户仅仅是点击了一下屏幕，那么可能只会监测到按下和抬起的动作。 3.事件传递的三个阶段 分发（Dispatch） 事件的分发对应着dispatchTouchEvent方法，在Android系统中，所有的触摸事件都是通过这个方法来风法的，方法原型如下： 1public boolean dispatchTouchEvent(MotionEvent ev) 在这个方法中，根据当前视图的具体实现逻辑，来决定是直接消费这个事件还是将事件继续分发给子视图处理，方法返回值为true表示事件被当前视图消费掉，不在继续分发事件；方法返回值为super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判定是否拦截该事件。 拦截（Intercept） 事件的拦截对应着onInterceptTouchEvent方法，这个方法只在ViewGroup及其子类中才存在，在View和Activity中是不存在的。方法原型如下： 1public boolean onInterceptTouchEvent(MotionEvent ev) 同理，这个方法也是通过返回的布尔值来决定是否拦截对应的事件，根据具体的实现逻辑，返回true表示拦截这个事件，不继续分发给子视图，同时交由自身的onTouchEvent方法进行消费；返回false或者super.onInterceptTouchEvent表示不对事件进行拦截，需要继续传递给子视图。 消费（Consume） 事件的消费对应着onTouchEvent方法，方法原型如下： 1public boolean onTouchEvent(MotionEvent event) 该方法返回true表示当前视图可以处理对应的事件，事件将不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会被传递给父视图的onTouchEvent方法进行处理。 在Android系统中，拥有事件传递处理能力的类有以下三种。 Activity 拥有dispatchTouchEvent和onTouchEvent方法。 ViewGroup 拥有dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent方法 View 拥有dispatchTouchEvent和onTouchEvent方法 4. View的事件传递机制虽然ViewGroup是View的子类，但是这里所说的View是指除ViewGroup外的View控件，例如TextView、Button、CheckBox等，View空间本身已是最小单位，不能再作为其他View的容器。View控件拥有dispatchTouchEvent和onTouchEvent两个方法。传递机制如下图： 从上面的流程图可以得出如下结论。 触摸事件的传递流程是从dispatchTouchEvent开始的，如果不进行人为干预（也就是默认返回父类的同名函数），则事件会依照嵌套层次从外层向内层传递，到达最内层的View时，就由它的onTouchEvent方法处理，该方法如果能够消费该事件，则返回true，如果处理不了，则返回false，这时事件会重新向外层传递，并由外层View的onTouchEvent方法进行处理，依次类推。 如果事件在向内层传递过程中由于人为干预，事件处理函数返回true，则会导致事件提前被消费掉，内层View将不会受到这个事件。 View控件的时间触发顺序是先执行onTouch方法，在最后才执行onClick方法。如果onTouch返回true，则事件不会继续传递，最后也不会调用onClick方法；如果onTouch返回false，则事件继续传递。 5. ViewGroup的事件传递机制ViewGroup是作为View控件的容器存在的，Android系统默认提供了一系列的ViewGroup子类，常见的有LinearLayout、RelativeLayout、FrameLayout、ListView、ScrollView等。ViewGroup拥有dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法，可以看出和View的唯一区别是多了一个onInterceptTouchEvent方法。 触摸事件的传递顺序是由Activity到ViewGroup，再由ViewGroup递归传递给他的子View。 ViewGroup通过onInterceptTouchEvent方法对事件进行拦截，如果该方法返回true，则事件不会继续传递给子View，如果返回false或者super.onInterceptTouchEvent，则事件会继续传递给子View。 在子View中对事件进行消费后，ViewGroup将接受不到任何事件。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"一种AutoJSPro在Android10下自由自在操作剪贴板的方法","slug":"autojs-clipboard","date":"2021-06-10T03:07:34.000Z","updated":"2023-11-16T06:15:51.588Z","comments":true,"path":"autojs-clipboard/","link":"","permalink":"https://lison.cc/autojs-clipboard/","excerpt":"前提条件： 解决使用AutoJS在执行getClip()时候获取到空数据的方法。 使用AutoJS Pro Android 10 不能访问或者设置剪贴板 设备已获取ROOT 设备已安装Magisk 能满足以上条件的盆友在稻谷Android 10剪贴板这个问题上应该就不会很费劲了。满足以上条件后，实际上走到这里的人已经不多了。","text":"前提条件： 解决使用AutoJS在执行getClip()时候获取到空数据的方法。 使用AutoJS Pro Android 10 不能访问或者设置剪贴板 设备已获取ROOT 设备已安装Magisk 能满足以上条件的盆友在稻谷Android 10剪贴板这个问题上应该就不会很费劲了。满足以上条件后，实际上走到这里的人已经不多了。 关于设备如何ROOT以及Magisk是什么以及如何安装本节不做介绍，只是介绍一下关于特殊的Android10如何自由自在操作剪贴板。 只需要在Magisk中安装Riru，然后依次安装Riru - Clipboard Whitelist这两个插件，如下图： 然后打开Clipboard这个app，勾选Autojs以及任何你想访问剪贴板的应用。 后面就可以自由的setClip(‘’)和getClip()了。","categories":[{"name":"autojs","slug":"autojs","permalink":"https://lison.cc/categories/autojs/"}],"tags":[{"name":"autojs pro","slug":"autojs-pro","permalink":"https://lison.cc/tags/autojs-pro/"}],"author":"Lison"},{"title":"phpstorm 2020.2 配置yui-compressor压缩js与css的菜坑","slug":"phpstorm-yui-compressor","date":"2021-01-18T09:21:16.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"phpstorm-yui-compressor/","link":"","permalink":"https://lison.cc/phpstorm-yui-compressor/","excerpt":"","text":"注意代码中不要出现以下的function定义类型，会报语法错误，还是使用传统的function(){} 123()=&gt; &#123; console.log(&#x27;hello&#x27;)&#125;, 12[ERROR] in edit.js 197:19:syntax error","categories":[{"name":"php","slug":"php","permalink":"https://lison.cc/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lison.cc/tags/php/"}],"author":"Lison"},{"title":"Debian 10 设置nginx开机自启","slug":"debian10-nginx-bootup","date":"2020-11-11T12:21:54.000Z","updated":"2023-11-16T06:15:51.593Z","comments":true,"path":"debian10-nginx-bootup/","link":"","permalink":"https://lison.cc/debian10-nginx-bootup/","excerpt":"直接编辑 ~/.bashrc，加入以下代码： 12345678910SERVICE=’nginx’if pgrep $SERVICE &gt; /dev/nullthenecho “$SERVICE service running, everything is fine”elseecho “$SERVICE is not running, starting”nginxecho “$SERVICE started”fi","text":"直接编辑 ~/.bashrc，加入以下代码： 12345678910SERVICE=’nginx’if pgrep $SERVICE &gt; /dev/nullthenecho “$SERVICE service running, everything is fine”elseecho “$SERVICE is not running, starting”nginxecho “$SERVICE started”fi","categories":[{"name":"linux","slug":"linux","permalink":"https://lison.cc/categories/linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://lison.cc/tags/nginx/"},{"name":"debian","slug":"debian","permalink":"https://lison.cc/tags/debian/"}],"author":"Lison"},{"title":"Fiddler Android 7.0以上无法抓取https包问题解决","slug":"android-fiddler","date":"2020-09-18T12:20:29.000Z","updated":"2023-11-16T06:15:51.355Z","comments":true,"path":"android-fiddler/","link":"","permalink":"https://lison.cc/android-fiddler/","excerpt":"传送：https://www.lixiaopeng.top/article/55.html","text":"传送：https://www.lixiaopeng.top/article/55.html","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"fiddler","slug":"fiddler","permalink":"https://lison.cc/tags/fiddler/"}],"author":"Lison"},{"title":"Java拾遗：多线程中的生产者消费者问题 – 线程的同步","slug":"java-threads-synchronize","date":"2020-09-18T12:10:50.000Z","updated":"2023-11-16T06:15:51.629Z","comments":true,"path":"java-threads-synchronize/","link":"","permalink":"https://lison.cc/java-threads-synchronize/","excerpt":"为了完成多个任务，常创建多个线程，它们可能毫不相关，但有时它们完成的任务在某种程度上有一定的关系，此时就需要线程之间有一些交互。在Java中，使用一对方法wait()和notify()/notifyAll()实现线程的交互。","text":"为了完成多个任务，常创建多个线程，它们可能毫不相关，但有时它们完成的任务在某种程度上有一定的关系，此时就需要线程之间有一些交互。在Java中，使用一对方法wait()和notify()/notifyAll()实现线程的交互。 同步问题的提出操作系统中的生产者消费者问题，就是一个经典的同步问题。举一个例子，有两个人，一个人在刷盘子，另一个人在烘干。这两个人各自代表一个线程，他们之间有一个共享的对象 — 盘架，刷好而等待烘干的盘子放在盘架上。两个人在没有事做事都愿意歇着。显然，盘架上有刷好的盘子时，烘干的人才能开始工作；而如果刷盘子的人刷的太快，刷好的盘子占满了盘架时，他就不能再继续工作了，而要等到盘架上有空位置才行。 这个示例要说明的问题是，生产者生产一个产品后就放入共享对象中，而不管共享对象中是否有产品。消费者从共享对象中取用产品，但不检测是否已经取过。 若共享对象中只能存放一个数据，可能出现以下问题（线程不同步的情况下）： – 生产者比消费者快时，消费者会漏掉一些数据没有取到。– 消费者比生产者快时，消费者取相同的数据。 在java语言中，可以用wait()和notify()/notifyAll()方法来协调线程间的运行速度关系，这些方法都定义在java.lang.Object类中。 解决方法为了解决线程运行速度问题，Java提供了一种建立在对象实例之上的交互方法。\\Java中的每个对象实例都有两个线程队列和他相连*。*第一个用来排列等待锁定标志的线程。第二个则用来实现wait()和notify()的交互机制**。** 类java.lang.Object中定义了三个方法wait()和notify()/notifyAll()。 wait方法导致当前的线程等待，同时会让当先线程释放其所持有的“对象互斥锁”，进入wait队列（等待队列）；而notify()/notifyAll()方法的作用是唤醒一个或所有正在等待队列中等待的线程，并将它（们）移入用一个“对象互斥锁”队列。notify()/notifyAll()方法和wait()方法都只能在被声明为synchronized的方法或代码中调用。方法notify()最多只能释放等待队列中的第一个线程，如果有多个线程在等待，则其他的线程将继续留在队列中。notifyAll()方法能够释放所有等待线程。 再来看看前面刷盘子的例子。线程t1代表刷盘子，线程t2代表烘干，它们都有对盘架drainingBoard的访问权。假设线程t2（烘干线程）想要进行烘干工作，而此时盘架时空的，则应表示如下： 12if(drainingBoard.isEmpty()) drainingBoard.wait(); //盘架空时则等待 当线程t2执行了wait()调用后，它不可以再执行，并加入到对象drainingBoard的等待队列中。在有线程将它从这个队列释放之前，它不能再次运行。 那么，烘干线程怎样才能重新运行呢？这应该有洗刷线程t1来通知它已经有工作可以做了，运行drainingBoard的notify调用可以做到这一点： 12drainingBoard.addItem(); //放入一个盘子drainingBoard.notify(); 此时，drainingBoard的等待队列中第一个阻塞线程由队列中释放出来，并可重新参加运行的竞争。 注意，在这里使用notify调用时，没有考虑是否有正在等待的线程。事实上，应该只有在增加盘子后使得盘架不再空时才执行这个调用。如果等待队列中没有阻塞线程时调用了方法notify()，则这个调用不做任何工作。notify()调用不会被保留到以后再发生效用。 使用这个机制，程序能够非常简单的协调洗刷线程和烘干线程，而且并不需要了解这些线程的身份。每当执行一项工作，使得另一个线程能够开始工作，就通知对象drainingBoard(调用notify())；每当由于盘架空或满而不能继续工作时，就等待对象drainingBoard(调用wait())。 在调用一个对象的wait(),notify()/notifyAll()时，必须首先持有该对象的锁定标志，因此这些方法必须在同步程序块中调用。这样，应该将代码改写如下： 1234synchronized(drainingBoard) &#123; if(drainingBoard.isEmpty()) drainingBoard.wait(); &#125; 和 1234 synchronized(drainingBoard) &#123; drainingBoard.addItem(); drainingBoard.notify();&#125; 附上源码： DrainingBoard.java 1234567891011121314151617181920212223242526272829303132public class DrainingBoard &#123; private ArrayList&lt;String&gt; plates; private static int MAX_ITEM_COUNT = 10; public DrainingBoard() &#123; plates = new ArrayList&lt;&gt;(); &#125; public void addItem() &#123; if (plates.size() &gt;= MAX_ITEM_COUNT) return; plates.add(“P” + plates.size()); &#125; public void minusItem() &#123; if (!isEmpty()) plates.remove(0); &#125; public boolean isEmpty() &#123; return plates.size() == 0; &#125; public int getSize() &#123; return plates.size(); &#125; public boolean isFull() &#123; return plates.size() &gt;= MAX_ITEM_COUNT; &#125; &#125; main.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227 DrainingBoard drainingBoard = new DrainingBoard(); Thread t1 = new Thread() &#123; @Override public void run() &#123; while (true) &#123; synchronized (drainingBoard) &#123; try &#123; if (drainingBoard.isFull()) &#123; System.out.println(“Full wait()”);&gt; drainingBoard.wait(); //t1进入等待（drainingBoard）的队列，资源达到上限 &#125; else &#123; drainingBoard.addItem(); System.out.println(“Add notify()” + drainingBoard.getSize()); drainingBoard.notify(); //通知等待（drainingBoard）队列中的第一个线程可以出队了 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; while (true) &#123; synchronized (drainingBoard) &#123; try &#123; if (drainingBoard.isEmpty()) &#123; System.out.println(“Empty wait()”); drainingBoard.wait(); //t2进入等待（drainingBoard）的队列（资源枯竭），知道有人notify他才可以出队 &#125; else &#123; System.out.println(“Have minus()” + drainingBoard.getSize()); drainingBoard.minusItem(); drainingBoard.notify(); //通知等待（drainingBoard）的队列中的第一个线程出队（释放） &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; &#125;; // t1.setPriority(Thread.MIN_PRIORITY); // t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start();部分运行结果（因机器而异，并不完全相同）：&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Have minus()2&gt; Have minus()1&gt; Empty wait()&gt; Add notify()1&gt; Add notify()2&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()&gt; Have minus()10&gt; Have minus()9&gt; Have minus()8&gt; Have minus()7&gt; Have minus()6&gt; Have minus()5&gt; Have minus()4&gt; Have minus()3&gt; Add notify()3&gt; Add notify()4&gt; Add notify()5&gt; Add notify()6&gt; Add notify()7&gt; Add notify()8&gt; Add notify()9&gt; Add notify()10&gt; Full wait()文章讲解摘自《Java语言程序设计（一）》多线程章节，文章中没有给出详细代码，害得我亲手撸了一遍，不过也巩固了科学技术知识，提高了加班生产力。其中的对线程设置优先级的地方已注释，怎么切换好像都看不出太不一样的地方。","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lison.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Lison"},{"title":"問題排查與解決：Fragment null must be a public static class to be properly recreated from instance state","slug":"fragment-null-must-be-a-public-static-class-to-be-properly-recreated-from-instance-state","date":"2020-09-15T12:06:28.000Z","updated":"2023-11-16T06:15:51.606Z","comments":true,"path":"fragment-null-must-be-a-public-static-class-to-be-properly-recreated-from-instance-state/","link":"","permalink":"https://lison.cc/fragment-null-must-be-a-public-static-class-to-be-properly-recreated-from-instance-state/","excerpt":"前提條件： compileSdkVersion 29buildToolsVersion “29.0.2”將項目從android.support包升級到了androidx，升級過程很順利，沒有什麼異常，但是運行項目的時候出現了標題提到的錯誤。 問題分析：在用戶使用App的過程中，用戶切換App，返回主界面，又返回了App等操作時，Android Framework會重建Fragment，並且要求Fragment不能是匿名類型，具體見源碼：androidx\\fragment\\app\\BackStackRecord.java","text":"前提條件： compileSdkVersion 29buildToolsVersion “29.0.2”將項目從android.support包升級到了androidx，升級過程很順利，沒有什麼異常，但是運行項目的時候出現了標題提到的錯誤。 問題分析：在用戶使用App的過程中，用戶切換App，返回主界面，又返回了App等操作時，Android Framework會重建Fragment，並且要求Fragment不能是匿名類型，具體見源碼：androidx\\fragment\\app\\BackStackRecord.java 123456789101112private void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException(&quot;Fragment &quot; + fragmentClass.getCanonicalName() + &quot; must be a public static class to be properly recreated from&quot; + &quot; instance state.&quot;); &#125;&#125; 1234567891011121314151617可以看到Fragment必須滿足：不能是匿名類，必須是Public，必須是成員方法，是否是靜態方法解決辦法：如果你的Fragment是abstract類型，也需要重新new一個Fragment，就這麼簡單。附上我的修改前（已註釋）和修改後的代碼：// mWebViewFragment = new WebViewFragment() &#123;// @Override// protected String getLoadUrl() &#123;// return mUrl;// &#125;// &#125;; mWebViewFragment = new WebviewFragmentImpl(mUrl); mFragmentManager.beginTransaction() .replace(R.id.fl_content, mWebViewFragment).commit();PS。看源碼是個好習慣 參考文章：https://stackoverflow.com/questions/52355079/illegalstateexception-fragment-must-be-public-static-class-to-be-properly-recreahttps://stackoverflow.com/questions/39295458/fragment-must-be-a-public-static-class-to-be-properly-recreated-from-instance-st","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"這世上真話本就不多，一位女子的臉紅勝過一大段對白","slug":"dont-lie-to-me","date":"2020-08-12T08:29:50.000Z","updated":"2023-11-16T06:15:51.601Z","comments":true,"path":"dont-lie-to-me/","link":"","permalink":"https://lison.cc/dont-lie-to-me/","excerpt":"駱駝祥子","text":"駱駝祥子 可惜後來有了胭脂，便分不清真情還是假意","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"非从零开始Redmi 4A Rolex获取Root与卸载系统应用折腾全过程","slug":"android-redmi4a-root","date":"2020-07-09T11:59:58.000Z","updated":"2023-11-16T06:15:51.363Z","comments":true,"path":"android-redmi4a-root/","link":"","permalink":"https://lison.cc/android-redmi4a-root/","excerpt":"很早之前写过一篇《使用XN Rootkit配合Magisk Manager为小米平板4 Plus获取Root超级用户》，好像有点不知所云，命名小米官方就支持刷机，一键获取Root，为什么还要如此折腾。。。","text":"很早之前写过一篇《使用XN Rootkit配合Magisk Manager为小米平板4 Plus获取Root超级用户》，好像有点不知所云，命名小米官方就支持刷机，一键获取Root，为什么还要如此折腾。。。 今天记录下使用官方的方法刷机以及获取Root的方法，记录包含如下三个步骤。 刷机开发板。 获取root。 删除系统应用。 目标机器使用红米4A Rolex，其他版本应该也差不多。用到的文件清单如下： 红米4A开发板Rom，点击链接查找自己手机使用的版本，注意这里用的卡刷方式，不要下载错了 adb 准备工作，确保手机已经绑定小米账号并解锁了Bootloader，下载刷机对应版本的Rom文件，这里用的是卡刷。 第一步刷机打开手机，我的设备-&gt;MIUI版本，点击10次中间的图标： 之后系统会提示“已开启系统扩展功能”等类似的字样，现在点击右上角的三个点按钮，可以看到如下的菜单： 会发现多了几项，其中“手动选择安装包”就是我需要的。 然后将下载的rom文件放在sdcard/downloaded_rom文件夹中，如果没有这个文件夹，就手动建立一下，把文件拷贝进去，然后点击上图中的手动选择安装包，选择刚才的Rom文件，刷机便开始了，此处略去十几分钟的字。。。。 第二部获取Root刷机完成之后，系统会重启，完成之后在手机中找到”安全中心“，进入后打开”应用管理“-&gt;权限，点击最下面的ROOT权限管理，这是官方的ROOT方法，开始ROOT之后，大概又过去十分八分钟，中间不要断电，不要重启手机，完成之后系统重启，此时已经拿到了ROOT权限。 第三部卸载系统应用这里使用adb的uninstall方法卸载系统应用：adb shell pm uninstall -k –user 0 com.duokan.reader 后面跟的是包名，以下是一份可以卸载的包名列表，终于知道手机为什么被占用那么多空间了， 小米黄页 com.miui.yellowpage 快应用 com.miui.hybrid 浏览器 com.android.browser 米币支付 com.xiaomi.payment 全球上网 com.miui.virtualsim 搜狗输入法小米版 com.sohu.inputmethod.sogou.xiaomi 系统更新(不要卸载，会卡米) com.android.updater 小爱同学 com.miui.voiceassist 小米安全键盘 com.miui.securityinputmethod 小米卡包 com.xiaomi.pass 小米钱包 com.mipay.wallet 小米视频 com.miui.video msa广告 com.miui.systemAdSolution 小米音乐 com.miui.player 应用商店(不能卸载，会卡机) com.xiaomi.market 用户反馈 com.miui.bugreport 邮件 com.android.email 小米游戏 com.xiaomi.gamecenter 游戏服务 com.xiaomi.gamecenter.sdk.service 指南针 com.miui.compass 系统帮助 com.mobiletools.systemhelper 小米商城 com.xiaomi.shop 小米查找 com.xiaomi.xmsf 运动计步 com.xiaomi.joyose 云盘 com.android.midrive 手机管家 com.miui.securitycenter 小米换机 com.miui.huanji 智能助理 com.miui.personalassistant 小米计算器 com.miui.calculator 小米有品 com.xiaomi.youpin 小米清理大师 com.miui.cleanmaster 分析 com.miui.analytics 亲情守护 com.miui.greenguard 硬件检测 com.miui.cit 云备份 com.miui.cloudbackup 便签 com.miui.notes 相册 com.miui.gallery 云服务 com.miui.cloudservice com.miui.cloudservice.sysbase 腾讯生物认证服务 com.tencent.soter.soterserver 翻译服务 com.miui.translationservice 金山翻译服务 com.miui.translation.kingsoft 有道翻译服务 com.miui.translation.youdao 获取补丁 com.miui.catcherpatch 内容扩展 com.miui.contentextension 内容捕捉器 com.miui.contentcatcher 查找 com.xiaomi.mircs 什么 有道啦腾讯啦全部卸掉，执行命令如果返回Success，说明卸载成功，手机上的APP图标也会立刻消失掉，如果返回：Failure – not installed for 0则多半的包名敲错了。 也可以定向查找包名：&gt;adb shell pm list package | findStr xiaomi 最后最重要的一点，卸载系统应用有风险，少年中年还需谨慎。如不小心变砖，请尝试关机进入recovery模式清除数据再重启，如果不行，那老衲也爱莫能助了，我弥陀佛～","categories":[{"name":"刷机","slug":"刷机","permalink":"https://lison.cc/categories/%E5%88%B7%E6%9C%BA/"}],"tags":[{"name":"root","slug":"root","permalink":"https://lison.cc/tags/root/"}],"author":"Lison"},{"title":"Android模拟车间生产看板，数字看板安卓版","slug":"android-digital-board","date":"2020-07-01T11:56:46.000Z","updated":"2023-11-16T06:15:51.354Z","comments":true,"path":"android-digital-board/","link":"","permalink":"https://lison.cc/android-digital-board/","excerpt":"分享一个多年前徒手撸制的粗制滥造生产看板，所有数据均为模拟，主要提供样式展示思路，可用于生产车间实时/伪实时数据 更新展示，班次、MPS进度展示等，适合模拟LED屏展示。这里只是打个样，具体需要根据实际业务发挥。","text":"分享一个多年前徒手撸制的粗制滥造生产看板，所有数据均为模拟，主要提供样式展示思路，可用于生产车间实时/伪实时数据 更新展示，班次、MPS进度展示等，适合模拟LED屏展示。这里只是打个样，具体需要根据实际业务发挥。 项目地址：https://gitee.com/lison/digitalboard 下载地址：https://gitee.com/lison/digitalboard/releases/v1.0","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"android网络编程高可用实践：Okhttp 接入HttpDNS","slug":"android-okhttp-httpdns","date":"2020-05-21T11:50:46.000Z","updated":"2023-11-16T06:15:51.362Z","comments":true,"path":"android-okhttp-httpdns/","link":"","permalink":"https://lison.cc/android-okhttp-httpdns/","excerpt":"安卓网络请求中经常用到OkHttp库，用到域名请求API，使用到域名则必须与DNS交互，使用DNS域名解析则绕不开运营商的LocalDNS问题，域名污染、域名劫持问题，这也是很多场景客户那里打不开，我这里好好的情况的一种典型解释。上古的方法是客户端发起一次Http请求，服务端响应之后客户端根据httpStatus判断如果是某种情况，则更换IP或域名请求其他服务器，但是这样一次完整的请求实在太浪费时间，想一下你的http请求默认超时多少秒？(OkHttp默认10_000毫秒,黄花菜都热了)。","text":"安卓网络请求中经常用到OkHttp库，用到域名请求API，使用到域名则必须与DNS交互，使用DNS域名解析则绕不开运营商的LocalDNS问题，域名污染、域名劫持问题，这也是很多场景客户那里打不开，我这里好好的情况的一种典型解释。上古的方法是客户端发起一次Http请求，服务端响应之后客户端根据httpStatus判断如果是某种情况，则更换IP或域名请求其他服务器，但是这样一次完整的请求实在太浪费时间，想一下你的http请求默认超时多少秒？(OkHttp默认10_000毫秒,黄花菜都热了)。 以下内容为转载，后续将更新项目库中关于OkHttp配合HttpDNS提升APP可用性。 HttpDns 是什么？HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。 链接：HttpDns 原理是什么简单理解，就是客户端把HTTP请求的域名发送到HttpDns服务商，HttpDns会把解析的IP地址传回客户端，来达到绕开运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率的目的。 下面我就不写了，快速通道：OkHttp接入HttpDNS，最佳实践Android OkHttp实现HttpDns的最佳实践OKHttp 如何支持 HttpDnsHTTPS IP直连问题小结基于OkHttp3 加入HttpDns功能okhttp https ip直连设置Host HttpDNS功能说明及实现OkHttpDNS实现原理 资源：DNSPOD | D+阿里云 HTTPDNSSDK：七牛-安卓版(支持D+企业版加密功能)七牛-OC版(支持D+企业版加密功能)新浪-安卓版(支持D+企业版加密功能)七牛接入： implementation ‘com.qiniu:happy-dns:0.2.13’ okhttp设置dns 123456789101112131415161718192021222324252627282930313233343536373839404142private static class HttpDns implements Dns&#123;private DnsManager dnsManager;public HttpDns()&#123; try &#123; IResolver[] resolvers = new IResolver[1]; resolvers[0] = new Resolver(getByName(“119.29.29.29”)); dnsManager = new DnsManager(NetworkInfo.normal, resolvers); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125;&#125;@Overridepublic List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException &#123; Log.d(“HttpDns”,”lookup==”+hostname); if (dnsManager == null) //当构造失败时使用默认解析方式 return Dns.SYSTEM.lookup(hostname); try &#123; String[] ips = dnsManager.query(hostname); //获取HttpDNS解析结果 if (ips == null || ips.length == 0) &#123; return Dns.SYSTEM.lookup(hostname); &#125; List&lt;InetAddress&gt; result = new ArrayList&lt;&gt;(); for (String ip : ips) &#123; //将ip地址数组转换成所需要的对象列表 result.addAll(Arrays.asList(getAllByName(ip))); Log.d(“HttpDns”,””+ip); &#125; return result; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //当有异常发生时，使用默认解析 return Dns.SYSTEM.lookup(hostname); &#125;&#125;OkHttpClient mOkHttpClient = new OkHttpClient().newBuilder() .dns(new HttpDns()) .build(); 文章引用内容： Okhttp 接入HttpDNS（支持http/https，）达到IP直连 Android 网络优化，使用 HTTPDNS 优化 DNS，从原理到 OkHttp 集成 OkHttp接入HttpDNS，最佳实践","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"okhttp","slug":"okhttp","permalink":"https://lison.cc/tags/okhttp/"}],"author":"Lison"},{"title":"Android Studio优秀插件最佳实践，不定期更新中","slug":"android-studio-plugins","date":"2020-04-15T11:47:39.000Z","updated":"2023-11-16T06:15:51.367Z","comments":true,"path":"android-studio-plugins/","link":"","permalink":"https://lison.cc/android-studio-plugins/","excerpt":"本来Intellij全家桶的东西已经够强大了，然而还有这么多优秀的插件，本文手记笔者开发过程中接触使用的插件，在此作记录，插件排名不分先后（当然eclipse也很经典）","text":"本来Intellij全家桶的东西已经够强大了，然而还有这么多优秀的插件，本文手记笔者开发过程中接触使用的插件，在此作记录，插件排名不分先后（当然eclipse也很经典） SVG2VectorDrawable 字面意思可以看明白，svg转向量图Drawable对象，APP图片瘦身必备步骤，之前都是使用在线工具直接生成各种大小的Drawable对象，本质还是图片，这个工具将图片直接转为Vector。典型的使用场景是比如我们app底部的Tab选项卡使用的那一类小图标，形式比较固定，就是一个默认的icon，一个默认颜色，按下时变成其他颜色。关于Vetor对象的图标的高级使用方法详见 -&gt; https://gist.github.com/pgq10240817/18acdb1c84bf9b142793562de1dcee0f。 Lifecycle Sorter，这个翻译成生命周期整理器？没错，就是自动将Activity，Fragment的override方法比如onCreate，onResume等方法依次按照生命周期顺序从上到下重新排列，不用每次都费力去差sdk了吧。安装完成点击Code-&gt;Sort Lifecycle Methods。不过如果你都能记得住并且此时是一脸不屑的话，na当我没说。传送门这里—&gt; InnerBuilder，将Bean转化为构造器与链式调用模式的代码，将原始的getter setter方式改造为Builder加链式调用，例如：User user = new User.Builder().firstName(“Lison”).lastName(“Liou”).age(32).phoneNo(“15066796811”).build();而这之前通常的写法是：User user=new User(); user.setFirstName(“Lison”) … 传送门 Parcelable Code Generator，要在Intent中传递序列化对象，一种方法是实现Serializeble接口，另外一种就是实现Parcelable接口；Parcelable的方式效率比较高，但需要重写一堆方法，本插件就是为此而生，自动生成describeContents，writeToParcelable等方法。传送门 IdeaVim 这个不用多做介绍，懂的自然懂，Android Studio的Vim模拟器，反正我在几乎所有的IDE上都装了Vim插件，Android Studio, Pycharm, VS2019，VScode bla，传送门 lombok 帮助你减少重复代码编写的工作，比如重复的编写getter setter代码，重复的使用Builder插件生成代码（InnerBuilder没别的意思），简单化注解同步方法等等。使用很酷，很提高效率。需要注意的是有些版本的插件与当前Android Studio不兼容，需要自己尝试下。传门送。 注解列表介绍。 今天先放三个，后面慢慢更新。。。 有句流行语怎么说来，乾坤未定，你我皆是黑马。虽然不再高考，但也没到认命的时候把。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"设计模式之我所使用的Builder模式 – 构建器模式","slug":"design-pattern-builder","date":"2020-04-15T11:45:22.000Z","updated":"2023-11-16T06:15:51.597Z","comments":true,"path":"design-pattern-builder/","link":"","permalink":"https://lison.cc/design-pattern-builder/","excerpt":"Builder模式，翻译过来中文是构建器、建造器都可以。定义为：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。同样的构建过程是指同样的构建方式，比如汽车组装的过程是 组装大架子(); 组装轮胎(); 喷漆(); 这样一个过程，那最后组装完成下线的是一辆本田还是一辆自行车，取决于你调用构建过程所传入的Builder类型。","text":"Builder模式，翻译过来中文是构建器、建造器都可以。定义为：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。同样的构建过程是指同样的构建方式，比如汽车组装的过程是 组装大架子(); 组装轮胎(); 喷漆(); 这样一个过程，那最后组装完成下线的是一辆本田还是一辆自行车，取决于你调用构建过程所传入的Builder类型。 经典的Builder模式主要有四个参与者： Product：被构造的复杂对象，ConcreteBuilder用来创建该对象的内部表示，并定义它的装配过程。 Builder：抽象接口，用来定义创建Product对象的各个组成部件的操作。 ConcreteBuilder：Builder接口的具体实现，可以定义多个，是实际构建Product对象的地方，同时会提供一个返回Product的接口。 Director：Builder接口的构造器和使用者。 直接代码说话 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class User &#123; private final String firstName; private final String lastName; private final String gender; private final int age; private final String phoneNo; private User(Builder builder) &#123; firstName = builder.firstName; lastName = builder.lastName; gender = builder.gender; age = builder.age; phoneNo = builder.phoneNo; &#125; public static final class Builder &#123; private int age; private String firstName; private String lastName; private String gender; private String phoneNo; public Builder() &#123; &#125; public Builder age(int val) &#123; age = val; return this; &#125; public Builder firstName(String val) &#123; firstName = val; return this; &#125; public Builder lastName(String val) &#123; lastName = val; return this; &#125; public Builder gender(String val) &#123; gender = val; return this; &#125; public Builder phoneNo(String val) &#123; phoneNo = val; return this; &#125; public User build() &#123; return new User(this); &#125; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;firstName=&#x27;&quot; + firstName + &#x27;\\&#x27;&#x27; + &quot;, lastName=&#x27;&quot; + lastName + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, phoneNo=&#x27;&quot; + phoneNo + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;使用方法：User user = new User.Builder().firstName(&quot;Lison&quot;).lastName(&quot;Liou&quot;).age(32).phoneNo(&quot;15066796811&quot;).build();构造器与链式调用，得劲儿。如果用Android Studio等Intellij全家桶的话，推荐插件：InnerBuilder，自动对Bean生成构造器模式模式的代码，好东西。","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lison.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Lison"},{"title":"半途记●我是如何使用gitbook发布电子书的","slug":"gitbook-giveup","date":"2020-03-22T11:37:46.000Z","updated":"2023-11-16T06:15:51.607Z","comments":true,"path":"gitbook-giveup/","link":"","permalink":"https://lison.cc/gitbook-giveup/","excerpt":"目的：使用gitbook发布一本电子书（把一本实体书转换为电子书），能够在web访问。","text":"目的：使用gitbook发布一本电子书（把一本实体书转换为电子书），能够在web访问。 门槛：1.对github以及git工具起码有一知半解2.能够或者已经在gitbook.com创建自己的organization和space3.知道如何把第二步的内容和github的repository进行集成4.你的电脑已经安装nodejs5.对我的文章内容有是非黑白是不是胡说八道的辨别能力哈哈哈具备上述条件，就可以继续往下看了。 然鹅我的星途起点是，电脑很久之前装的npm和git，然后直接从gitbook.com注册了账号并且下载了一个windows版本的gitbook编辑器“Gitbook editor”，看起来是这样的： 然后就开始+new book开始加入标题章节开始写书了，写完了save然后publish，然后输入github创建的repository地址就提交成功了，看起来是这样的： 好像还不错。可是怎么没有分享功能呢，于是查了资料，说要搞一个book.json，然后在项目目录添加，可是怎么也不好死，一点也不好死。。。 后来找到了这篇文章：https://zhaoda.net/2015/11/09/gitbook-plugins/然后一路 123npm install gitbook-cli -ggitbook initgitbook serve gitbook serve 若失败的话可能是端口占用，然鹅我直接使用另外的端口启动 12gitbook serve --port 5000gitbook build gitbook build出错的话根据错误提示若未安装各种plugins，则先执行gitbook install，同样配置完成book.json之后也要gitbook install一下。 运行完成之后就可以访问http://localhost:5000了","categories":[{"name":"前端","slug":"前端","permalink":"https://lison.cc/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"kotlin建造者模式(Builder)实践","slug":"design-pattern-builder-with-kotlin","date":"2019-07-23T11:32:20.000Z","updated":"2023-11-16T06:15:51.594Z","comments":true,"path":"design-pattern-builder-with-kotlin/","link":"","permalink":"https://lison.cc/design-pattern-builder-with-kotlin/","excerpt":"后来又开始写安卓，士别三日党刮目相看，我这是别了大概两年多吧，kotlin已经不再新鲜，IO大会出现了很多新特性，Instant run，Android Q bla bla不管他，不管被拉下多远还是要操练起来。","text":"后来又开始写安卓，士别三日党刮目相看，我这是别了大概两年多吧，kotlin已经不再新鲜，IO大会出现了很多新特性，Instant run，Android Q bla bla不管他，不管被拉下多远还是要操练起来。 现状是目前的安卓项目中已经集成了kotlin的一个插件，信息提示的，比较炫酷，长这个样子 =&gt; 传送门 好吧，放了两天都不知道要说什么了，只记得最后加了个onShow和onHide的回调，用来满足业务需求，例如请求api发现客户端token无效或超时而要求用户重新登录，封装了一个Util，直接贴代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Created by Lison on 7/9/2019. * * http://lison.cc */class AlerterUtil( val activity: Activity, val title: String, val titleId: Int, val text: String, val textId: Int, val backgroundColor: Int, val icon: Int, val showAlertListener: OnShowAlertListener, val hideAlertListener: OnHideAlertListener) &#123; private constructor(builder: Builder) : this(builder.activity, builder.title, builder.titleId, builder.text, builder.textId, builder.backgroundColor, builder.icon, builder.showAlertListener, builder.hideAlertListener) class Builder &#123; /** lateinit 可以只創建變量不賦值 **/ lateinit var activity: Activity private set var title: String = &quot;&quot; private set var titleId: Int = 0 private set var text: String = &quot;&quot; private set var textId: Int = 0 private set var backgroundColor: Int = 0 private set var icon: Int = 0 private set var showAlertListener: OnShowAlertListener = OnShowAlertListener &#123; &#125; private set var hideAlertListener: OnHideAlertListener = OnHideAlertListener &#123; &#125; private set constructor(activity: Activity) &#123; this.activity = activity &#125; fun title(title: String) = apply &#123; this.title = title &#125; fun title(titleId: Int) = apply &#123; this.titleId = titleId &#125; fun text(text: String) = apply &#123; this.text = text &#125; fun text(textId: Int) = apply &#123; this.textId = textId &#125; fun backGroundColor(color: Int) = apply &#123; this.backgroundColor = color &#125; fun icon(icon: Int) = apply &#123; this.icon = icon &#125; fun onShowAlertListener(onShowAlertListener: OnShowAlertListener) = apply &#123; this.showAlertListener = onShowAlertListener &#125; fun onHideAlertListener(onHideAlertListener: OnHideAlertListener) = apply &#123; this.hideAlertListener = onHideAlertListener &#125; fun build() = AlerterUtil(this) fun ok() = apply &#123; backgroundColor = R.color.colorSpring icon = R.drawable.icon_ok &#125; fun warn() = apply &#123; backgroundColor = R.color.colorAlert &#125; fun error() = apply &#123; backgroundColor = R.color.colorError icon = R.drawable.icon_error &#125; &#125; fun alert() &#123; var al = Alerter.create(activity) if (TextUtil.isNotBlank(title)) al.setTitle(title) else if (titleId != 0) al.setTitle(titleId) if (TextUtil.isNotBlank(text)) al.setText(text) else if (textId != 0) al.setText(textId) if (backgroundColor != 0) al.setBackgroundColorRes(backgroundColor) else al.setBackgroundColorRes(R.color.colorPrimary) if (icon != 0) al.setIcon(icon) if (showAlertListener != null) al.setOnShowListener(showAlertListener) if (hideAlertListener != null) al.setOnHideListener(hideAlertListener) al.show() &#125; 调用方式如下 123456new AlerterUtil.Builder(this).text(getString(R.string.need_barcode)).onHideAlertListener(new OnHideAlertListener() &#123; @Override public void onHide() &#123; //打开登录Activity &#125;&#125;).build().alert(); kotlin是个好东西，与java无缝衔接；设计模式更是把好武器。好了好了困了。 参考资料： https://www.cnblogs.com/scuwangjun/p/9699895.html https://github.com/Tapadoo/Alerter https://stackoverflow.com/questions/36140791/how-to-implement-builder-pattern-in-kotlin","categories":[{"name":"kotlin","slug":"kotlin","permalink":"https://lison.cc/categories/kotlin/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lison.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Lison"},{"title":"弃一道白泥 回灵山","slug":"hui-lingshan","date":"2019-06-13T11:25:20.000Z","updated":"2023-11-16T06:15:51.619Z","comments":true,"path":"hui-lingshan/","link":"","permalink":"https://lison.cc/hui-lingshan/","excerpt":"无以聊表敬意，我给您P个图吧，China Rock。 出自九三的《回衫》，收录于碟《景德镇文艺复兴》。懂的自然懂。","text":"无以聊表敬意，我给您P个图吧，China Rock。 出自九三的《回衫》，收录于碟《景德镇文艺复兴》。懂的自然懂。 公鸡打鸣 船夫起杆 留一件青衫 在江湾 运水而去 虫蚁相随 汐来潮退 无月而归 生我惘我 有衫无杉 弃一道白泥 回灵山 愿作那光中物 愿作那气中烟","categories":[{"name":"Literature Library","slug":"Literature-Library","permalink":"https://lison.cc/categories/Literature-Library/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"记java归并排序","slug":"java-merge-sort","date":"2019-05-15T11:22:00.000Z","updated":"2023-11-16T06:15:51.628Z","comments":true,"path":"java-merge-sort/","link":"","permalink":"https://lison.cc/java-merge-sort/","excerpt":"1234567891011static int[] sort(int[] A, int low, int high) &#123; if (low &lt; high) &#123; int mid = (low + high) / 2; sort(A, low, mid); sort(A, mid + 1, high); merge(A, low, mid, high); &#125; return A; &#125;","text":"1234567891011static int[] sort(int[] A, int low, int high) &#123; if (low &lt; high) &#123; int mid = (low + high) / 2; sort(A, low, mid); sort(A, mid + 1, high); merge(A, low, mid, high); &#125; return A; &#125; 123456789101112131415161718192021222324static void merge(int[] A, int low, int mid, int high) &#123; int n1 = mid - low + 1, n2 = high - mid, i, j, k; int[] L = new int[high - low + 1], R = new int[high - low + 1]; for (i = 0; i &lt; n1; i++) L[i] = A[low + i]; for (j = 0; j &lt; n2; j++) R[j] = A[mid + j + 1]; L[n1] = Integer.MAX_VALUE; R[n2] = Integer.MAX_VALUE; i = j = 0; for (k = low; k &lt; high + 1; k++) &#123; if (L[i] &lt; R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125;&#125; 123456int[] arr = &#123; 8, 3, 6, 4, 2 &#125;; System.out.println(Arrays.toString(arr)); // System.err.println(Arrays.toString(sort(arr, 0, arr.length - 1))); // System.err.println(Arrays.toString(sort(arr, 0, arr.length - 1))); System.err.println(Arrays.toString(s(arr))); 使用分治法分而治之，时间复杂度O(nlogn)，空间复杂度O(n)","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lison.cc/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lison"},{"title":"如果上天能够给你一个重新来过的机会，你还写不写代码了","slug":"my-english-vocabulary","date":"2019-05-05T09:48:38.000Z","updated":"2023-11-16T06:15:51.638Z","comments":true,"path":"my-english-vocabulary/","link":"","permalink":"https://lison.cc/my-english-vocabulary/","excerpt":"注册托福的考试账号，问我下一个希望达成的学历水平，还有学习领域。 就是再给你一次机会，你还选不选计算机了，还做不做码农了。","text":"注册托福的考试账号，问我下一个希望达成的学历水平，还有学习领域。 就是再给你一次机会，你还选不选计算机了，还做不做码农了。 Accounting 财会Agriculture &amp; Natural Resources 农业与自然资源Architecture 建筑学Art and Design 艺术设计Biological/Life Sciences 生物学/生命科学Build Environment 人工环境Business &amp; Management 商业管理Chemistry 化学Communications and Media 通信与媒体Computing &amp; Information Technology 计算与信息技术Creative Arts 艺术创造Dental Studies 牙科研究Economics 经济学Education &amp; Training 教育与训练Employment Skilles 职业技能English Language/Literature 英语语言与文学Engineering &amp; Technology 工程技术Environmental Studies 环境研究Fashion and Design 时尚与设计Food &amp; Hospitality 饮食与招待Foreign Language/Literature 外语与文学Geography 地理学Health Science/Studies 健康科学与研究Humanities &amp; Social Sciences 人类学与社会科学Journalism 新闻学Language &amp; Literature 语言文学Law 法律学Legal Studies 法律研究学Liberal Arts/General Studies 文科研究Marketing 营销学Mathmatics 数学Medicine 药学Military / Technologies 军事/技术学Multi/Interdisciplinary Studies 多学科/跨学科研究Music 音乐学Nursing 护理学Personal Services 私人服务Pharmacy 药剂学Philosophy and Religion 哲学与宗教Physical Sciences 自然科学Physics 物理学Political Science 政治学Psychology 心理学Public Administration 公共管理Rehabilitation 康复学Sciences 科学Social Sciences/History 社会科学与历史Social Work 社会工作学Sport, Leisure &amp; Recreation 运动休闲娱乐Surveying 测绘学Technology 工艺学Thelogical Studies 逻辑研究Travel and Tourism 旅游学Veterinary Studies &amp; Animal Care 兽医研究与动物护理Visual and Performing Arts Care 视觉表演艺术护理Welfare &amp; Community Services 福利与社区服务 可能我选择的不会那么高雅，我会选 Agriculture &amp; Natural Resources，应该做一个农民也挺好吧。 就当作一个Flag，希望有机会可以挑战下Toefl","categories":[{"name":"英语","slug":"英语","permalink":"https://lison.cc/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[],"author":"Lison"},{"title":"C语言假币问题（分治法）","slug":"c-divide-and-conquer","date":"2019-04-13T09:39:58.000Z","updated":"2023-11-16T06:15:51.590Z","comments":true,"path":"c-divide-and-conquer/","link":"","permalink":"https://lison.cc/c-divide-and-conquer/","excerpt":"分治法，o(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 【假币问题】 有n枚硬币，其中有一枚是假币，已知假币的重量较轻。现只有一个天平，要求用尽量少的比较次数找出这枚硬币。 * * 【分析问题】 将n枚硬币分成相等的两部分： 1.当n为偶数时，将前后两部分，即 1...n/2 * 和n/2+1...0，放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币： 2.当n为奇数时，将前后两部分，即 * 1...(n-1)/2 和 (n+1)/2+1...0，放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币； * 若两端重量相等，则中间的硬币，即第 (n+1)/2 枚硬币是假币。 * * 【调用方式】 int cs[] = &#123;2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2,&#125; * getCounterfeitCoint(cs, cs[0], cs[cs.length-1]) * * @param coins * @param first * @param last * @return */ static int getCounterfeitCoin(int coins[], int first, int last) &#123; int firstSum = 0, lastSum = 0, i; if (first == last - 1) &#123; // 只剩两枚 if (coins[first] &lt; coins[last]) return first; return last; &#125; if ((last - first + 1) % 2 == 0) &#123; // 偶数枚 for (i = first; i &lt; (first + last) / 2; i++) firstSum += coins[i]; for (i = first + (last - first) / 2 + 1; i &lt; last + 1; i++) lastSum += coins[i]; if (firstSum &lt; lastSum) return getCounterfeitCoin(coins, first, first + (last - first) / 2); else return getCounterfeitCoin(coins, first + (last - first) / 2 + 1, last); &#125; else &#123; // 奇数枚 for (i = first; i &lt; first + (last - first) / 2; i++) firstSum += coins[i]; for (i = first + (last - first) / 2 + 1; i &lt; last + 1; i++) lastSum += coins[i]; if (firstSum &lt; lastSum) return getCounterfeitCoin(coins, first, first + (last - first) / 2 - 1); else if (firstSum &gt; lastSum) return getCounterfeitCoin(coins, first + (last - first) / 2 - 1, last); else return (first + last) / 2; &#125; &#125;","text":"分治法，o(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 【假币问题】 有n枚硬币，其中有一枚是假币，已知假币的重量较轻。现只有一个天平，要求用尽量少的比较次数找出这枚硬币。 * * 【分析问题】 将n枚硬币分成相等的两部分： 1.当n为偶数时，将前后两部分，即 1...n/2 * 和n/2+1...0，放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币： 2.当n为奇数时，将前后两部分，即 * 1...(n-1)/2 和 (n+1)/2+1...0，放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币； * 若两端重量相等，则中间的硬币，即第 (n+1)/2 枚硬币是假币。 * * 【调用方式】 int cs[] = &#123;2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2,&#125; * getCounterfeitCoint(cs, cs[0], cs[cs.length-1]) * * @param coins * @param first * @param last * @return */ static int getCounterfeitCoin(int coins[], int first, int last) &#123; int firstSum = 0, lastSum = 0, i; if (first == last - 1) &#123; // 只剩两枚 if (coins[first] &lt; coins[last]) return first; return last; &#125; if ((last - first + 1) % 2 == 0) &#123; // 偶数枚 for (i = first; i &lt; (first + last) / 2; i++) firstSum += coins[i]; for (i = first + (last - first) / 2 + 1; i &lt; last + 1; i++) lastSum += coins[i]; if (firstSum &lt; lastSum) return getCounterfeitCoin(coins, first, first + (last - first) / 2); else return getCounterfeitCoin(coins, first + (last - first) / 2 + 1, last); &#125; else &#123; // 奇数枚 for (i = first; i &lt; first + (last - first) / 2; i++) firstSum += coins[i]; for (i = first + (last - first) / 2 + 1; i &lt; last + 1; i++) lastSum += coins[i]; if (firstSum &lt; lastSum) return getCounterfeitCoin(coins, first, first + (last - first) / 2 - 1); else if (firstSum &gt; lastSum) return getCounterfeitCoin(coins, first + (last - first) / 2 - 1, last); else return (first + last) / 2; &#125; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://lison.cc/categories/c/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lison.cc/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lison"},{"title":"在ubuntu上搭建基于TrinityCore的魔兽私服的踩坑实践","slug":"ubuntu-trinity-core","date":"2019-01-16T09:37:49.000Z","updated":"2023-11-16T06:15:51.861Z","comments":true,"path":"ubuntu-trinity-core/","link":"","permalink":"https://lison.cc/ubuntu-trinity-core/","excerpt":"前人种树，后人乘凉。感谢大神“David栗子”的文章分享《在Ubuntu上搭建基于TrinityCore的魔兽私服》。","text":"前人种树，后人乘凉。感谢大神“David栗子”的文章分享《在Ubuntu上搭建基于TrinityCore的魔兽私服》。 一步一步照着大神的指引来搭建服务器，一切都很顺利，直到将代码clone下来make的时候，不管make多少遍最后100%的时候都会提示错误，最后在股沟的帮助下发现用的是ubuntu16，而官方支持的最低版本的ubuntu是17，ok怪我，我升级一个。 我觉得没有必要抽取所有的地图文件，真心。。。（若不抽取，记得对应修改config文件） 服务端准备就绪，客户端连接成功，服务器也没有显示离线状态，点击服务器之后过一会儿又返回又选择服务器，无线循环，卡在服务器选择页面。排错：修改auth数据库的realmlist表，将ip修改为你的服务器的ip（如果你挂在外网的话）。 安全组要加入允许8085和3724 参考资料：1.在Ubuntu上搭建基于TrinityCore的魔兽私服2.Debian 9下安装测试基于TrinityCore的魔兽世界服务端3.基于TrinityCore在linux上搭建wow私服4.魔兽世界私服Trinity，从源码开始","categories":[],"tags":[],"author":"Lison"},{"title":"记●搭建魔兽私服TrinityCore的折腾实践","slug":"build-wow-server-based-on-trinity-core","date":"2019-01-16T09:28:33.000Z","updated":"2023-11-16T06:15:51.590Z","comments":true,"path":"build-wow-server-based-on-trinity-core/","link":"","permalink":"https://lison.cc/build-wow-server-based-on-trinity-core/","excerpt":"BOM LIST: 一台干净的ubuntu18（字少也是17，不要问我为什么，我脸上还挂着泪） 洗干净的双手 一张帅气的脸","text":"BOM LIST: 一台干净的ubuntu18（字少也是17，不要问我为什么，我脸上还挂着泪） 洗干净的双手 一张帅气的脸 STEP: 0.全程超级用户操作1sudo su - root 1.安装mysql-server1apt-get -y install mysql-server 若安装过程出现不顺畅，不要犹豫切换安装源(清华大学) /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse 2.启动服务及设置开机启动mysql12systemctl start mysqlsystemctl enable mysql 3.mysql安全设置1mysql_secure_installation 参数设置建议：1.不要开启密码插件功能2.移除匿名访问3.禁止root用户远程访问4.移除测试数据库5.搞定后重新载入privileges 4.创建mysql用户并授权1234mysql -u root -pCREATE USER &#x27;mangos&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的密码&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;mangos&#x27;@&#x27;localhost&#x27;;quit 以上就是数据库安装环节，程序猿盆友肯定不会陌生，下面来项目编译环节。 5.获取安装脚本并安装1234cd ~wget https://raw.githubusercontent.com/mangoszero/server/master/linux/getmangos.shchmod 700 getmangos.sh./getmangos.sh 最后执行安装脚本，安装过程中选项尽量默认，用windows的话讲就是一路回车next，中间会有选择游戏版本和编译选项的弹窗。 NO CMAKE_CXX_COMPILER could be found 然而我干净的Ubuntu是默认安装了CMAKE的，为何还没有这个变量？不去管，百度上说这样： 12sudo apt-get updatesudo apt-get install -y build-essential 完成后再执行一遍 ./getmangos.sh 7.开始编译 8.安装与初始化数据库 9.提取游戏数据这一步可不能直接回车，Default也没有默认值，需要填写上面安装时的zero版本魔兽的安装路径，我的一路next下来的路径是：/home/mangos/zero，回车之后选择提取的内容，默认是都选中的 参考资料： 1.CMake error at CMakeLists.txt:30 (project): No CMAKE_C_COMPILER could be found2.CMake错误No CMAKE_CXX_COMPILER could be found3.Installing Mangos on Ubuntu 16.04 LTS","categories":[{"name":"山口山","slug":"山口山","permalink":"https://lison.cc/categories/%E5%B1%B1%E5%8F%A3%E5%B1%B1/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"《瞎子》- 尧十三的电影版音频提取","slug":"melody-mr-nobody","date":"2019-01-08T09:21:26.000Z","updated":"2023-11-16T06:15:51.638Z","comments":true,"path":"melody-mr-nobody/","link":"","permalink":"https://lison.cc/melody-mr-nobody/","excerpt":"","text":"秋天嘞蝉在叫 我在亭子边刚刚下过雨 我难在们我喝不到酒我扎实勒舍不得 豆是们船家喊快点走我拉起你的手 看你眼泪淌出来我让他愤 我讲不出话来我难在们我讲不出话来我要说走喽 这千里的烟雾波浪嘞那黑巴巴的天好大哦 看完《无名之辈》，被十三哥的插曲惊吓到，已经没有办法用牛逼来形容，只能一边又一遍的无限循环原声。 于是找到专辑曲的《瞎子》，并不是一个味道，听两遍可以，无限循环是不行。电影版的只有视频版本，只好自己提取，方法不做描述，音频质量尚可接受，直接放提取后的地址，相信很多人喜欢。 下载链接: https://pan.baidu.com/s/167b0eQ7o2Bzqw8D7XWIJQw 提取码: 5rwy 在线播放","categories":[{"name":"在世","slug":"在世","permalink":"https://lison.cc/categories/%E5%9C%A8%E4%B8%96/"}],"tags":[],"author":"Lison"},{"title":"学习基于链表的队列Queue实现java版","slug":"java-queue","date":"2018-12-23T09:19:18.000Z","updated":"2023-11-16T06:15:51.628Z","comments":true,"path":"java-queue/","link":"","permalink":"https://lison.cc/java-queue/","excerpt":"队列Queue，先进先出 First In First Out (FIFO) 的线性表, 只允许在表的一端插入元素(队尾Rear), 表的另一端删除元素(队首Front)，基本操作有初始化队列，判断空，入队，出队，读取队首元素。","text":"队列Queue，先进先出 First In First Out (FIFO) 的线性表, 只允许在表的一端插入元素(队尾Rear), 表的另一端删除元素(队首Front)，基本操作有初始化队列，判断空，入队，出队，读取队首元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 单个节点 * * @author Lison-Liou * */public class Node&lt;E&gt; &#123; E data = null; Node&lt;E&gt; next; public Node() &#123; &#125; public Node(E data) &#123; this.data = data; &#125; public Node(E data, Node&lt;E&gt; next) &#123; this.data = data; this.next = next; &#125;&#125;/** * 链表队列实现 * @author Lison-Liou * * @param &lt;E&gt; */public class MyQueue&lt;E&gt; &#123; int size; Node&lt;E&gt; front, rear; public void initQueue() &#123; front = rear = null; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void enQueue(int data) &#123; if (isEmpty()) &#123; front = new Node(data); rear = front; &#125; else &#123; Node newRear = new Node(data); rear.next = newRear; rear = newRear; &#125; size++; &#125; public E deQueue() &#123; if (!isEmpty()) &#123; Node&lt;E&gt; f0 = front; Node&lt;E&gt; f = f0.next; front = f; size--; return f0.data; &#125; return null; &#125; public E frontQueue() &#123; return front.data; &#125; public void clear() &#123; while (!isEmpty()) &#123; deQueue(); &#125; &#125;&#125;//// 链表队列测试代码========================================================================== MyQueue&lt;Integer&gt; queue = new MyQueue&lt;Integer&gt;(); queue.initQueue(); System.out.println(&quot;入队列操作--------------------------&quot;); for (int i = 0; i &lt; 7; i++) &#123; int d = random.nextInt(i + 1); System.out.print(d + &quot;\\t&quot;); queue.enQueue(d); &#125;// System.out.println(&quot;\\r\\n出队列操作--------------------------&quot;);// while (!queue.isEmpty()) &#123;// System.err.print(queue.deQueue() + &quot;\\t&quot;);// &#125; System.out.println(&quot;\\r\\n清空队列操作--------------------------&quot;); queue.clear(); System.out.println(&quot;\\r\\nQUEUE SIZE: &quot; + queue.size);","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[],"author":"Lison"},{"title":"学习基于链表的栈Stack实现java版","slug":"java-stack","date":"2018-12-23T09:16:55.000Z","updated":"2023-11-16T06:15:51.629Z","comments":true,"path":"java-stack/","link":"","permalink":"https://lison.cc/java-stack/","excerpt":"“栈” 遵循先进后出的原则，基本操作有：初始化栈，判断栈空，入栈出栈，读取栈顶元素，代码实现如下","text":"“栈” 遵循先进后出的原则，基本操作有：初始化栈，判断栈空，入栈出栈，读取栈顶元素，代码实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 单个节点 * * @author Lison-Liou * */public class Node &#123; int data = 0; Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125;&#125;/** * 后进先出 LIFO LAST IN FIRST OUT * * @author Lison-Liou * */public class MyStack &#123; Node top; int size; public void initStack() &#123; top = null; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void push(int x) &#123; top = new Node(x, top); size++; &#125; public int pop() &#123; Node t = top; top = top.next; size--; return t.data; &#125; public int top() &#123; return top.data; &#125;&#125; 测试代码 1234567891011121314MyStack stack = new MyStack(); stack.initStack(); System.out.println(&quot;入栈操作--------------------------&quot;); for (int i = 0; i &lt; 6; i++) &#123; int d = random.nextInt(10); System.out.print(d + &quot;\\t&quot;); stack.push(d); &#125; System.out.println(&quot;\\r\\n出栈操作--------------------------&quot;); while (!stack.isEmpty()) System.err.print(stack.pop() + &quot;\\t&quot;); 输出结果","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[],"author":"Lison"},{"title":"链式存储单向链表学习java版","slug":"java-linked-list","date":"2018-12-22T09:13:58.000Z","updated":"2023-11-16T06:15:51.628Z","comments":true,"path":"java-linked-list/","link":"","permalink":"https://lison.cc/java-linked-list/","excerpt":"学习学习，不要废话，先上图","text":"学习学习，不要废话，先上图 用C写半天搞不定，回归java就比较可爱了，记录一下线性表的java实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * 单向链表 * * @author Lison-Liou * */public class MyLink &#123; /** * 单个节点 * @author Lison-Liou * */ public class Node &#123; int data = 0; Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; &#125; Node head = null; /** * 获取长度 * @return */ public int size() &#123; if (head == null) return 0; int length = 0; Node tmp = head; while (tmp.next != null) &#123; length += 1; tmp = tmp.next; &#125; return length + 1; &#125; /** * 增加节点, 默认在链表末尾增加 * * @param data */ public void addNode(int data) &#123; Node newNode = new Node(data); if (head == null) &#123; head = newNode; &#125; else &#123; Node tmp = head; while (tmp.next != null) &#123; tmp = tmp.next; &#125; tmp.next = newNode; &#125; &#125; /** * 在指定的索引位置之后增加节点 * @param data * @param position */ public void addNode(int data, int position) &#123; Node newNode = new Node(data); Node find = findNode(position); Node next = find.next; find.next = newNode; newNode.next = next; &#125; /** * 删除指定位置的节点 * * @param position */ public void deleteNode(int position) &#123; Node prev = findNode(position - 1); Node next = prev.next.next; prev.next = next; &#125; /** * 按位置查找节点 * * @param position * @return */ public Node findNode(int position) &#123; if (head == null &amp;&amp; position != 0) return null; else if (head != null &amp;&amp; position == 0) return head; else if (position &gt; size() - 1) &#123; return null; &#125; else &#123; int i = 0; Node tmp = head; while (i &lt; position) &#123; if (i == position) return tmp; if (tmp != null) tmp = tmp.next; i++; &#125; return tmp; &#125; &#125; @Override public String toString() &#123; Node tmp = head; while (tmp != null) &#123; System.out.print(tmp.data + &quot;\\t&quot;); tmp = tmp.next; &#125; System.out.println(&quot;\\r\\n&quot;); return null; &#125;&#125; 测试方法 1234567891011121314151617181920212223242526MyLink link = new MyLink(); //增加10个节点, 随机数 for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); link.addNode(random.nextInt(10)); &#125; System.out.println(&quot;\\r\\nLENGTH: &quot; + link.size()); System.out.println(&quot;链表数据&quot;); link.toString(); System.out.println(&quot;查找索引位置为5的节点&quot;); MyLink.Node find = link.findNode(5); if (find != null) System.out.println(find.data); else System.out.println(&quot;NOT FOUND&quot;); System.out.println(&quot;删除索引位置为2的节点&quot;); link.deleteNode(2); link.toString(); System.out.println(&quot;在指定位置增加节点&quot;); link.addNode(99,2); link.toString();","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[],"author":"Lison"},{"title":"Say it Again 再谈记忆的盘尼西林","slug":"penicillin-say-it-again","date":"2018-12-19T09:06:19.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"penicillin-say-it-again/","link":"","permalink":"https://lison.cc/penicillin-say-it-again/","excerpt":"随便写，乱七八糟的写。","text":"随便写，乱七八糟的写。 Open my eyes in the morning rainAnd gently find out black shoesClouds are slowly drifting by, Who is crying under the sky It may be the slowest bus, Which color for her is rightI see all the teenagers eyes, Tell me they are tough and red Say say it againSometimes the memory was winding my mindSay say it againYou know the past things cloud set me free Put up you in sandwiches handsOh I think it not really coolYou tell me truth will not be here 倒也习惯，或许很多人会觉得奇怪。 我有很多爱的歌都会忘记名字和作者；但有的会在清晨的雾气里萦绕，有的会在漫天的冰冻里记起。 可不可以永远不问你的名字，就这样每天相见，每天说说话。","categories":[{"name":"上班","slug":"上班","permalink":"https://lison.cc/categories/%E4%B8%8A%E7%8F%AD/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"使用XN Rootkit配合Magisk Manager为小米平板4 Plus获取Root超级用户","slug":"android-xn-rootkit-magisk-manager-get-root","date":"2018-12-17T08:36:23.000Z","updated":"2023-11-16T06:15:51.370Z","comments":true,"path":"android-xn-rootkit-magisk-manager-get-root/","link":"","permalink":"https://lison.cc/android-xn-rootkit-magisk-manager-get-root/","excerpt":"按照之前写的root小米平板4的文章进行后续设备的root，无论怎么尝试，使用Magisk还是SuperSu，切换各种版本，都会最终卡在开机界面，无奈只能另辟蹊径。使用XN Rootkit配合Magisk实现小米平板4的root工作。","text":"按照之前写的root小米平板4的文章进行后续设备的root，无论怎么尝试，使用Magisk还是SuperSu，切换各种版本，都会最终卡在开机界面，无奈只能另辟蹊径。使用XN Rootkit配合Magisk实现小米平板4的root工作。 本文使用的工具列表 XN Rootkit By XN Logos MagiskManage-v6.1.0.apk 小米平板4 Plus已刷开发板MIUI 10 8.9.20 并且已经解锁，查看如何解锁？ ES文件浏览器 Adb Magisk-v18.0(18000).zip MIUI 10 8.11线刷包里的文件 boot.img 对应压缩包里的文件 XN+Rootkit+by+XN+Logos.zip MagiskManager-v6.1.0(165).apk 无 com.estrongs.android.pop_10006.apk adb在XN Rookit的解压包中可以找到 MagiskManager app中会进行下载, 或者对应 boot.img 所有文件已打包至文章末尾。 准备工作 将ES文件浏览器app与MagiskManager.apk安装到pad上 boot.img 拷贝的pad上 将XN Rootkit By XN Logos解压 步骤 在pad上打开MagiskManager，可以看到显示“未安装Magisk”，如图： 点击安装，选择第二项修补Boot镜像文件。然后选择使用ES文件浏览器打开，定位到准备工作中拷贝的boot.img的位置，方式选择“标准安卓方式”，失败的话回头再用“文件方式”尝试一次，一般第一种就可以，确定之后开始刷入，如下图： 成功之后，会有提示 Pached image is placed in/storage/emulated/0/Download/patched_boot.img – All done! 将上面加粗的pached_boot.img（使用ES文件浏览器查找）拷贝到电脑的XN Rootkit目录中，不要修改文件名。在PC端打开XN Rootkit目录中的XN Rootkit.exe，选择44项：Root Right Now 回车之后进入一键root工具箱如下： 然后点击回车，按电源+音量减小键进入fastboot模式，自动开始root，如下： 过程很快，root成功后pad会自动重启。 重启之后的pad在界面上是没有什么区别，但是打开MagiskManger看一下，跟刚开始安装的Magisk Manager不一样吧，已经显示“已安装版本：v18.0”了 而菜单项也增加了#超级用户，模块等内容 此时打开adb输入adb shell，再切换su模式，Magisk Manager会提示超级用户请求 （图文不符，应该显示的是com.android.shell请求超级用户，只做说明）允许之后可以看到Terminal中的$变成了# 而在超级用户菜单中可以看到已授权的包列表。 至此Root成功完成。 另外给ES文件浏览器授权root的话，打开ES选择菜单项中的Root工具箱，同样会出现上述超级用户请求授权对话框，选择允许之后再回头查看ES文件浏览器的根目录，差别就很明显了 用到的文件 https://pan.baidu.com/s/1unwnPBxo9D4LE6fwOSEUNw 提取码: 33si 参考文章： XN Rootkit Universal Systemless Root for any android Phone XN Rootkit universal Systemless Root for Android with twrp Porter","categories":[{"name":"刷机","slug":"刷机","permalink":"https://lison.cc/categories/%E5%88%B7%E6%9C%BA/"}],"tags":[{"name":"root","slug":"root","permalink":"https://lison.cc/tags/root/"}],"author":"Lison"},{"title":"Android5.0屏幕固定功能，如何开机只能运行当前app不能退出","slug":"android-app-pin","date":"2018-10-17T07:58:36.000Z","updated":"2023-11-16T06:15:51.352Z","comments":true,"path":"android-app-pin/","link":"","permalink":"https://lison.cc/android-app-pin/","excerpt":"需求接上回，还是那台小米平板4，终于拿到了root权限。并且实现了开机启动某app，现在的需求是：要求只能运行这个app，不能退出，不能回退到主屏幕，不能Home键，重启之后还是我的app，你不能退出，除非你输入万能密码。。。 背景然而之前用的是ScreenPin功能（也有翻译成报刊亭模式），这是Android自5.0开始系统内置的一个功能，主要用作商场演示等的场景，就是设定好之后，手机只能运行这个app（比如这个app是介绍手机的一个广告app，或者某工厂内的一个办公app，比如扫码，只能扫码用，别的干不了，因为你不能回到主屏幕，只能操作这一个）。这个系统内置功能长这个样子","text":"需求接上回，还是那台小米平板4，终于拿到了root权限。并且实现了开机启动某app，现在的需求是：要求只能运行这个app，不能退出，不能回退到主屏幕，不能Home键，重启之后还是我的app，你不能退出，除非你输入万能密码。。。 背景然而之前用的是ScreenPin功能（也有翻译成报刊亭模式），这是Android自5.0开始系统内置的一个功能，主要用作商场演示等的场景，就是设定好之后，手机只能运行这个app（比如这个app是介绍手机的一个广告app，或者某工厂内的一个办公app，比如扫码，只能扫码用，别的干不了，因为你不能回到主屏幕，只能操作这一个）。这个系统内置功能长这个样子 可以看到有两个可操作项：“知道了”和”不用了“，那么这个时候如果点击”不用了“是不会激活ScreenPin的，跟操作普通app一样，想退出就退出，想结束任务就结束，没有任何限制。那么这一定不是我想要的。PS. 如果进入了固定屏幕模式，除了重启手机之外另外一种方法是adb执行命令：adb shell am force-stop xx.xx.xx 后面是你的包名。 步骤一如果不想让用户看到上面的固定屏幕提示而直接固定了屏幕的话，你的应用必须要成为设备拥有者来自StackoverFlow大神的解答：https://stackoverflow.com/questions/28437529/how-to-pin-an-app-without-a-dialog-android这让我想起早年间用安卓机装某60安全卫士的时候提示绑定设备的场景，应该就是这里了。 那么问题来，如何将我的app注册为设备拥有者，直接搞之。 AndroidManifest.xml注册一个继承自android.app.admin.DeviceAdminReceiver的receiver 1234567891011121314&lt;receiver android:name=&quot;.DeviceAdminReceiver&quot; android:description=&quot;@string/device_admin_desc&quot; android:label=&quot;@string/device_admin&quot; android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&gt; &lt;meta-data android:name=&quot;android.app.device_admin&quot; android:resource=&quot;@xml/device_admin&quot; /&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt; &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_DISABLE_REQUESTED&quot;/&gt; &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_DISABLED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; /rex/xml/device_admin内容： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;device-admin&gt; &lt;uses-policies&gt; &lt;limit-password /&gt; &lt;watch-login /&gt; &lt;reset-password /&gt; &lt;force-lock /&gt; &lt;wipe-data /&gt; &lt;expire-password /&gt; &lt;encrypted-storage /&gt; &lt;disable-camera /&gt; &lt;disable-keyguard-features /&gt; &lt;/uses-policies&gt;&lt;/device-admin&gt; DeviceAdminReceiver里毛都不用写 123456789101112public class DeviceAdminReceiver extends android.app.admin.DeviceAdminReceiver&#123; void showToast(Context context, String msg) &#123; String status = context.getString(R.string.admin_receiver_status, msg); Toast.makeText(context, status, Toast.LENGTH_SHORT).show(); &#125; @Override public void onEnabled(Context context, Intent intent) &#123; showToast(context, context.getString(R.string.admin_receiver_status_enabled)); &#125;&#125; ok代码部分到这里，然后adb shell进入到设备，切换su执行命令 1dpm set-device-owner cc.lison.qis_shell/.DeviceAdminReceiver 然而我却得到了这样的提示 也是，都MIUI了，设备拥有者肯定不会空闲出来，但是打开设置却怎么也找不到绑定设备拥有者的地方，一定是雷总故意隐藏起来了。 其他注册设备拥有者的方法，既然已经获取了root权限，那么系统目录简直我是畅行无阻，/data/system/device_owner.xml，创建这个文件，写入如下内容： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;&lt;device-owner package=&quot;your.owner.app.package.id&quot; name=&quot;Your app name&quot; /&gt; 然后reboot。挖槽还是不好死，而新建的device_owner.xml也不翼而飞，看来是遇到了鬼，于是便把目光投向了/system/app里的其他文件/夹，其中有一个叫XiaoMiFramework之类的名字，我居然删除了它，然后程序各种报错，然后reboot，然后再次执行 1dpm set-device-owner cc.lison.qis_shell/.DeviceAdminReceiver 居然出现了下面的提示： 后来的故事大家都知道了，白雪公主和七个小矮人从此过上了幸福快乐的生阿活。。。 参考链接：1.How to pin an app without a dialog android2.HOW TO TURN YOUR ANDROID APPLICATION INTO A KIOSK3.Android Kiosk Mode Without Root4.DeviceAdmin简单实践 #文章做折腾过程记录，不对任何变砖与异常负责","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"记录我是怎样把小米平板4（MIUI9.6）刷成开发板+获取root的","slug":"xiaomi-root","date":"2018-10-15T07:43:53.000Z","updated":"2023-11-16T06:15:51.875Z","comments":true,"path":"xiaomi-root/","link":"","permalink":"https://lison.cc/xiaomi-root/","excerpt":"需求实现一个app在小米平板4（MIUI9.6）上开机自动启动，如此而已。然鹅，折腾的路确很长。","text":"需求实现一个app在小米平板4（MIUI9.6）上开机自动启动，如此而已。然鹅，折腾的路确很长。 尝试一作为一个半生熟的Android开发狗，那么开机启动一个app还不简单？我新建一个BootReceiver，我再申请权限android.permission.RECEIVE_BOOT_COMPLETED，我再声明Activity、Service、Intent什么的blablabla，整个流程做安卓开发的你一定不会不清楚，反正度娘是妥妥儿的告诉我。但是折腾完发现，无论如何就是不好死？开机app不启动，于是打开百度我会搜索这样的关键字“Android app 开机启动”，然后会找到这样的文章: https://blog.csdn.net/mmmccc000/article/details/52626075/ 其中你反复验证启动失败的原因：是不是Fast Boot模式？是不是权限添加的不对？是不是应用默认装到了sd卡里，我怎么样才能不装到sd卡而装到系统空间？各种各样的疑问，各种各样的尝试，但最后的结果就一个：还是不行。 尝试二分割线分割前生，前生事此不再提，也就说使用开机广播那一套不知道是不行，还是还需要另外的协助？自省一下，前提条件是在小米平板4上装可以自动启动的app，那么小米平板4目前运行的是“MIUI9.6稳定版”，小米的系统肯定是深度定制版不知道有多深，但是小米可是有开发板的系统，是支持折腾的，那么问题来了，官网下载开发板地址是多少？此处内心独白：既然前面那套开机广播的脆脆弱弱（我自始至终都没有在模拟器上尝试，不知道为什么，可能是秀逗了），那么我可以不可以直接获取root权限，比如修改个init.d什么的直接就勾起我的Activity？脑回路有些大，但是没大胆就没大产不是。。。所以此处心里想的就是：开发板的系统自带肯定自带root权限，oh yes。。。那刷小米的官方系统倒是很简单啊，直接设置里面手动选择安装包什么的就可以了，可是选来选取，刷来刷去我发现，账号依然不是root，adb连接到设备su依然不可用。 此处的插曲是，刷机之前需要解设备锁，也就是解锁BL（BootLoader），具体查看“更多设置” -&gt; “开发者选项” -&gt; “设备解锁状态“，如果因为下面这种情况卡住的话，告诉你只要在当前设备上换一个注册时间比较长，活跃度高的小米账号绑定设备，然后重新解锁就行。 迷茫时刻可我真的记得有篇文章说的是小米开发板自带root，百度了N多文章，一天下来，脑子里什么都没有，全是这些内容，你只是个开发人员，你明白app生命周期，但系统原理你是无能为力的。要不淘宝上几十块刷一个吧，可是淘宝上问一下，有说能刷的，有说刷不了的。。。屁不就刷个鸡？百度不行谷歌我还不行么。。。 尝试三 刷入TWRP还是Google大法好，让我找到了这篇文章：《How to Install twrp Recovery Root XiaoMi Mi Pad 4》文章清清爽爽，简单易懂，用到的几个文件清单如下，如果你不能下载的话，可以去这里：链接: https://pan.baidu.com/s/1NfYY2RRPmIwTILekDqv25w 提取码: zthz1.TWRP 3.2 Xiaomi Mi Pad 4 对应Try.7z包里的recovery.img2.SuperSu/Magisk3.adb fast driver Try.7z包里没有这项，adb我觉得你自己能搞定4.No-verity-opt-Entrypt5.adb fastboot tools 参考3** 参照着大神的文章，终于一步一步装上了TWRP，中间的过程如： 安装完成后手机是这样的： 然后adb shell进入设备，敲入su，发现$符号变成了#号才明白，root特么的成功了。 尝试四 怎么样把app安装到/system/app中（以下操作在成功安装TWRP后进行）** 既然机器已经root，那么我就可以乱来了是不是，我就可以直接（以下操作在重启按住音量增大键+电源键进入TWRP后，选择Advanced-&gt;Terminal后进行，直接adb shell是没有vi等功能的）1.vi init.d2.GG 回车 a 回车 am start cc.lison.locked3.Esc :wq4.reboot不好意思，轻度vim党，第二步的意思是翻到文件最后并加入am那句命令，然后保存重启，不好死，还是不好死，重启进入TWRP的Terminal发现刚才修改的init.d的内容没有了，改写的内容被覆盖掉了。。。怪不得一直提示我FileSystem read-only之类的，然后在TWRP中尝试文件管理器直接修改文件权限为755，还是不好死。。。又尝试了很多Magisk里的模块，不好死不好死。。。 尝试五**这一步尝试已经忘了搜索百度的什么关键字，总之是摸石头过河摸到了石头，详参这里：https://www.androidauthority.com/install-user-app-as-system-app-how-to-93522/既然已经拿到了root权限，adb root + adb remount却不行，但是直接adb shell，然后切换su却可以（adb进入shell之后无法使用vi等工具），这是前提条件。于是又下载了一个ES 文件浏览器，安卓玩家对这个肯定不陌生，Magisk对其进行root授权（好像打开进入app就自动授权root权限），打开ES文件浏览器，把你要开机启动的app拷贝到/system/app目录，然后点击安装，世界就如此美好了。。。 PS。如果要删除安装在/system/app的app的话，只需要删除这个apk文件即可。 # 文章做折腾过程记录，不对任何变砖与异常负责","categories":[{"name":"刷机","slug":"刷机","permalink":"https://lison.cc/categories/%E5%88%B7%E6%9C%BA/"}],"tags":[{"name":"root","slug":"root","permalink":"https://lison.cc/tags/root/"}],"author":"Lison"},{"title":"Private： 记录一种科学上网的方法，查资料时可用Detour IOS配置实践","slug":"ios-detour","date":"2018-09-26T07:34:21.000Z","updated":"2023-11-16T06:15:51.625Z","comments":true,"path":"ios-detour/","link":"","permalink":"https://lison.cc/ios-detour/","excerpt":"需求是能够科学上网。","text":"需求是能够科学上网。 原材料：1.IOS手机2.DetourAPP，APPStore下载地址3.一堆的SSR/SS账号，不要问我这是什么，问百度。https://www.ssrtool.com/tool/free_ssr，或者直接百度搜索：免费ss账号 Detour创建两种规则，一种国内直连（Direct），一种全局代理（使用SSR、SS账号）。 具体方法如下： 在 Detour 配置页面, 点击添加新代理，类型选择 Direct，标题随便写（写直连），保存。 在 Detour 配置页面, 点击添加新代理，类型选择 ShadowSocks，其他信息也依次填入并保存。 在 Detour 配置页面，点击添加新规则，类型选择 Country，国家代码写 CN，是否匹配选择是，标题写直连，代理选择刚刚新建的直连，保存。 在 Detour 配置页面，点击添加新规则，类型选择 All，代理选择你刚刚新建的 ShadowSocks代理，标题随便写全局。 （先建立的规则会先匹配，所以先创建直连规则） 添加代理按钮右侧有扫码按钮，部分网站分享的免费SS账号可直接扫码获取填充，比较方便。","categories":[{"name":"vpn","slug":"vpn","permalink":"https://lison.cc/categories/vpn/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://lison.cc/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"author":"Lison"},{"title":"證悟、佛心與凡夫心 讀記《西藏生死書》","slug":"tibet-life-opinion","date":"2018-09-25T07:32:19.000Z","updated":"2023-11-16T06:15:51.859Z","comments":true,"path":"tibet-life-opinion/","link":"","permalink":"https://lison.cc/tibet-life-opinion/","excerpt":"我們雖然也想佛陀一般具有佛性，卻未認出來，因爲它被我們的凡夫心包得密不透風。試著觀想這裏有一隻花瓶，瓶内的空間與瓶外的空間一模一樣，卻被脆弱的瓶壁分隔。我們的佛心被包在凡夫心的瓶壁内。儅我們證悟時，就好像花瓶破成碎片，“裏面”的空間與“外面”的空間結合爲一。它們合而爲一。當下我們才發現，它們從未分離也并無二緻，他們是永遠相同的。","text":"我們雖然也想佛陀一般具有佛性，卻未認出來，因爲它被我們的凡夫心包得密不透風。試著觀想這裏有一隻花瓶，瓶内的空間與瓶外的空間一模一樣，卻被脆弱的瓶壁分隔。我們的佛心被包在凡夫心的瓶壁内。儅我們證悟時，就好像花瓶破成碎片，“裏面”的空間與“外面”的空間結合爲一。它們合而爲一。當下我們才發現，它們從未分離也并無二緻，他們是永遠相同的。 摘自《西藏生死书》 索甲仁波切郑振煌 译","categories":[{"name":"在世","slug":"在世","permalink":"https://lison.cc/categories/%E5%9C%A8%E4%B8%96/"}],"tags":[],"author":"Lison"},{"title":"记●TENCENT-CLOUD迁移.doc","slug":"tencent-cloud-migrate","date":"2018-09-21T07:27:25.000Z","updated":"2023-11-16T06:15:51.856Z","comments":true,"path":"tencent-cloud-migrate/","link":"","permalink":"https://lison.cc/tencent-cloud-migrate/","excerpt":"新主机信息 网络 公网IP 119.28.195.204 内网 10.144.75.71 MariaDB 10.1、nginx 1.10.3、php7.0","text":"新主机信息 网络 公网IP 119.28.195.204 内网 10.144.75.71 MariaDB 10.1、nginx 1.10.3、php7.0 迁移网站文件 /var/www/aixiadianying /var/www/cert /var/www/lisonliou /var/www/Tieba-Cloud-Sign-master /var/www/wanjuancangshu /var/www/ya2ya2 使用scp命令做内网服务器之间数据对拷，命令如下：scp -r -iid_rsa_tencentcloud /var/www/aixiadianying/ &#114;&#x6f;&#x6f;&#116;&#64;&#49;&#48;&#x2e;&#x31;&#x34;&#52;&#x2e;&#55;&#x35;&#46;&#x37;&#49;:/var/www/aixiadianying/ 迁移数据库 MariaDB Tieba_cloud aixiadianying lisonliou wanjuancangshudb wordpress ya2ya2 使用PhpStorm或HeidiSQL导出DDL 重新创建数据库用户，并重新分配数据库权限，导出语句，并到新库执行 使用mysqldump命令导出sql语句 迁移nginx文件 /etc/nginx/nginx.conf /etc/nginx/sites-available/ /etc/nginx/sites-enabled/ php.ini修改 Fix_path_info=0 Short_open_tag=On","categories":[{"name":"云","slug":"云","permalink":"https://lison.cc/categories/%E4%BA%91/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"Windows平台64位ipfs分布式文件系统go语言版本下载包","slug":"windows-ipfs-x64","date":"2018-09-18T07:24:21.000Z","updated":"2023-11-16T06:15:51.872Z","comments":true,"path":"windows-ipfs-x64/","link":"","permalink":"https://lison.cc/windows-ipfs-x64/","excerpt":"由于你看我比较帅等比较奇怪的原因，ipfs.io官网打不开，所以路过的好心人就提供一下。 包内文件为Windows平台64位压缩文件版。下载完成之后cmd进入文件夹执行./install.sh即可安装。其他文档及说明请八仙过海，各显神通。 好东西不多说，直接下 链接: https://pan.baidu.com/s/1GBaccaPR5L-7ilPs5Zpmnw提取码: gsv6","text":"由于你看我比较帅等比较奇怪的原因，ipfs.io官网打不开，所以路过的好心人就提供一下。 包内文件为Windows平台64位压缩文件版。下载完成之后cmd进入文件夹执行./install.sh即可安装。其他文档及说明请八仙过海，各显神通。 好东西不多说，直接下 链接: https://pan.baidu.com/s/1GBaccaPR5L-7ilPs5Zpmnw提取码: gsv6","categories":[{"name":"分布式","slug":"分布式","permalink":"https://lison.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"ipfs","slug":"ipfs","permalink":"https://lison.cc/tags/ipfs/"}],"author":"Lison"},{"title":"分享一个在线的免费图片压缩网站 ● ya2ya2.com","slug":"ya2ya2-com","date":"2018-07-30T07:14:47.000Z","updated":"2023-11-16T06:15:51.876Z","comments":true,"path":"ya2ya2-com/","link":"","permalink":"https://lison.cc/ya2ya2-com/","excerpt":"在线压缩图片的服务已经很多了，很多收费的。这个也是收费的，不过初次使用可以免费30张，对于不是从事设计工作的朋友使用应该是足够了。 后续怎么收费还没有明确，我用业余时间开发的，压缩效率和速度感觉还可以。好多功能都还没有做，先用用看啊～ 点此传送 鸭兔压图 ya2ya2.com","text":"在线压缩图片的服务已经很多了，很多收费的。这个也是收费的，不过初次使用可以免费30张，对于不是从事设计工作的朋友使用应该是足够了。 后续怎么收费还没有明确，我用业余时间开发的，压缩效率和速度感觉还可以。好多功能都还没有做，先用用看啊～ 点此传送 鸭兔压图 ya2ya2.com","categories":[{"name":"前端","slug":"前端","permalink":"https://lison.cc/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"图片压缩","slug":"图片压缩","permalink":"https://lison.cc/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"}],"author":"Lison"},{"title":"BootstrapValidator 页面验证多个form","slug":"bootstrap-validator-multi-form","date":"2017-10-25T07:11:34.000Z","updated":"2023-11-16T06:15:51.588Z","comments":true,"path":"bootstrap-validator-multi-form/","link":"","permalink":"https://lison.cc/bootstrap-validator-multi-form/","excerpt":"只做记录，没什么技术含量。 每个页面多个form，没问题，form id不同，name不同，然后“标识”不同，所谓标识就是放一个&lt;input type=”hidden” 指定比如name=”type” ，那么多个form在action到同一个method的时候，就使用type判断当前提交的是哪个form；那bootstrapValidator里绑定的内容如下：","text":"只做记录，没什么技术含量。 每个页面多个form，没问题，form id不同，name不同，然后“标识”不同，所谓标识就是放一个&lt;input type=”hidden” 指定比如name=”type” ，那么多个form在action到同一个method的时候，就使用type判断当前提交的是哪个form；那bootstrapValidator里绑定的内容如下： 1234567891011121314151617181920212223242526272829$(&quot;form&quot;).bootstrapValidator(validator_config).on(&#x27;success.form.bv&#x27;, function (e) &#123; e.preventDefault(); $(&quot;button[id*=&#x27;submit_&#x27;]&quot;).attr(&quot;disabled&quot;, &quot;disabled&quot;); $.scojs_message.delay = $.scojs_message.delay * 10; $.scojs_message(&#x27;请稍候...&#x27;, $.scojs_message.TYPE_WAIT); $.ajax(&#123; type: &quot;POST&quot;, data: $(this).serialize(), success: function (response) &#123; var dataObj = $.parseJSON(response); if (dataObj.status) &#123; $.scojs_message(&#x27;操作成功,3秒后将返回...&#x27;, $.scojs_message.TYPE_OK); aci.GoUrl(SITE_URL + folder_name + &#x27;/resource/edit/&#x27; + movie_id); &#125; else &#123; $.scojs_message(dataObj.tips, $.scojs_message.TYPE_ERROR); $(&quot;button[id*=&#x27;submit_&#x27;]&quot;).removeAttr(&quot;disabled&quot;); &#125; &#125;, error: function (request, status, error) &#123; $.scojs_message(request.responseText, $.scojs_message.TYPE_ERROR); $(&quot;button[id*=&#x27;submit_&#x27;]&quot;).removeAttr(&quot;disabled&quot;); &#125; &#125;); &#125;).on(&#x27;error.form.bv&#x27;, function (e) &#123; $.scojs_message(&#x27;带*号不能为空&#x27;, $.scojs_message.TYPE_ERROR); $(&quot;button[id*=&#x27;submit_cover&#x27;]&quot;).removeAttr(&quot;disabled&quot;); &#125;); 第一行jQuery选择器匹配所有form并添加bootstrapValidator，然后post时使用this传递form data，其他的form处理都一样，就四酱。","categories":[{"name":"前端","slug":"前端","permalink":"https://lison.cc/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://lison.cc/tags/bootstrap/"}],"author":"Lison"},{"title":"迟来的回复","slug":"water-under-the-bridge","date":"2017-10-20T07:07:15.000Z","updated":"2023-11-16T06:15:51.863Z","comments":true,"path":"water-under-the-bridge/","link":"","permalink":"https://lison.cc/water-under-the-bridge/","excerpt":"","text":"今天刚发现的帖子。 我给他的回复。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"openshift配置http跳转https并且www域名跳转不带www域名的apache rewrite规则","slug":"openshift-apache-rewrite","date":"2017-09-22T07:03:22.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"openshift-apache-rewrite/","link":"","permalink":"https://lison.cc/openshift-apache-rewrite/","excerpt":"不说原因直接开，需求就是搞了个https免费证书，要求所有http请求都跳转到https，并且www域名跳转到不到www的域名，比如请求www.lison.cc跳转到http://lison.cc，而请求lison.cc跳转到http://lison.cc，全站https嘛。","text":"不说原因直接开，需求就是搞了个https免费证书，要求所有http请求都跳转到https，并且www域名跳转到不到www的域名，比如请求www.lison.cc跳转到http://lison.cc，而请求lison.cc跳转到http://lison.cc，全站https嘛。 1.首先设置DNS. 我用的cloudflare的CDN，DNS设置看起来是这样的： **2.设置openshift你的application的alias。**默认的有lisonliou-osrd.rhcloud.com，然后再添加lison.cc，www.lison.cc，这是域名绑定？不是很清楚，我就是卡在这里好几个钟头。。。 **3.设置转发规则。**我用的apache服务器，所以只需要修改.htaccess文件，添加如下行： 123456789&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteCond %&#123;HTTP_HOST&#125; !^aixiadianying.com$ [NC] RewriteRule ^(.*)$ https://aixiadianying.com/$1 [L,R=301] RewriteCond %&#123;HTTP:X-Forwarded-Proto&#125; !https RewriteRule .* https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R,L] 第一个rewrite规则是将带www（或者其他，因为已经做了泛解析）的网址跳转到https://aixiadianying.com; 第二个rewrite是将http请求定向到https，实现全站https，就是这样。 最后为业余时间做的站露个脸：爱下电影网 – 一个可以下载电影的网站~ ! Happy Holiday~","categories":[{"name":"apache","slug":"apache","permalink":"https://lison.cc/categories/apache/"}],"tags":[],"author":"Lison"},{"title":"javascript使用persistjs跨页面存储读取数据","slug":"js-persistjs","date":"2017-08-11T07:01:10.000Z","updated":"2023-11-16T06:15:51.630Z","comments":true,"path":"js-persistjs/","link":"","permalink":"https://lison.cc/js-persistjs/","excerpt":"折腾记： 两个html文件html1和html2，要求使用js在html1中保存数据在html2中能够读取出来，不用数据库、不用session、不用xxx。 用PersistJs这个js库。","text":"折腾记： 两个html文件html1和html2，要求使用js在html1中保存数据在html2中能够读取出来，不用数据库、不用session、不用xxx。 用PersistJs这个js库。 html1文件的内容： 12345678910111213&lt;input type=&quot;text&quot; id=&quot;txt&quot;/&gt;&lt;button onclick=&quot;save()&quot;&gt;STORE&lt;/button&gt;&lt;script src=&quot;&lt;?php echo BASE_JS_PATH ?&gt;persist-min.js&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt; function save() &#123; var store = new Persist.Store(&#x27;store_name&#x27;); console.log(store.set(&#x27;data&#x27;, document.getElementById(&#x27;txt&#x27;).value)); &#125; &lt;/script&gt; html2文件内容： 1234567&lt;script src=&quot;&lt;?php echo BASE_JS_PATH ?&gt;persist-min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var store = new Persist.Store(&#x27;store_name&#x27;); console.log(store.get(&quot;data&quot;));&lt;/script&gt; 剩下的就在控制台查看效果吧。 本文严重符合伸手COPY党口味，之前有见到大神的PersistJs Demo文章，虽然就几句话，但是一直调试不通，自己折腾了十好几分钟才ok，记下。 据说这厮跨浏览器通用，而且若不支持html5，则自动使用cookie存储（我没验证），真是居家旅行、杀人放火必备之精品啊。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lison.cc/categories/javascript/"}],"tags":[],"author":"Lison"},{"title":"PHP框架ACI动态设置页面SEO信息","slug":"php-aci-seo","date":"2017-08-10T06:51:13.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"php-aci-seo/","link":"","permalink":"https://lison.cc/php-aci-seo/","excerpt":"背景PHP框架 CI 不多说，ACI框架同样不多说，说一下如何为ACI框架的每个页面设置单独的SEO信息。直接说源码部分（本文做折腾记录，面向php技能比较生的手，或者出家时不是修行的php，而是半路改行的家伙）。","text":"背景PHP框架 CI 不多说，ACI框架同样不多说，说一下如何为ACI框架的每个页面设置单独的SEO信息。直接说源码部分（本文做折腾记录，面向php技能比较生的手，或者出家时不是修行的php，而是半路改行的家伙）。 需求1.为每个页面设置固定的SEO信息2.为单个页面动态设置SEO信息，例如产品详情页，动态展示产品名称，参数（对应title、keyword等内容）** 涉及到的文件1. application/config/seo.php2. application/core/MY_Controller.php3. application/views/template/header.php4. 自定义的Controller 折腾ACI安装完成之后，要为单独页面设置SEO，先来看下源码目录结构，大约找到了这个文件：application/config/seo.php，打开之后将$config[‘seo’][‘default’] 修改成我们自己的title, keyword,description之后果然生效了，OK, 这是第一步。 上面的修改之所以能够生效，原因在于application/views/template/header.php这个文件，打开之后发现head中有如下代码： 123456&lt;meta name=&quot;description&quot; content=&quot;&lt;?php echo $description?&gt;&quot;&gt; &lt;meta name=&quot;keyword&quot; content=&quot;&lt;?php echo $keyword?&gt;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;autocodeigniter.com&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt; &lt;title&gt;&lt;?php echo $title?&gt;&lt;/title&gt; 很明显$title, $keyword, $description都是动态设置的（废了个话），然后就应该找到每个页面对应的Controller，于是第二步顺藤摸瓜，找到welcome.php的controller页面，发现controller里面没有任何关于设置title、keyword的东西。然后看一下Welcome的继承关系（ -&gt;代表继承关系）：Welcome -&gt; Front_Controller-&gt; MY_Controller -&gt; CI_Controller 看一下MY_Controller的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class MY_Controller extends CI_Controller&#123; private $is_load_captcha; public $aci_config; public $aci_status; public $all_module_menu; protected $page_data = array( &#x27;module_name&#x27; =&gt; &#x27;&#x27;, &#x27;controller_name&#x27; =&gt; &#x27;&#x27;, &#x27;method_name&#x27; =&gt; &#x27;&#x27;, ); function __construct()&#123; parent::__construct(); $this-&gt;load-&gt;driver(&#x27;cache&#x27;,array(&#x27;adapter&#x27;=&gt;&#x27;file&#x27;)); $this-&gt;load-&gt;helper(array(&#x27;global&#x27;,&#x27;url&#x27;,&#x27;string&#x27;,&#x27;text&#x27;,&#x27;language&#x27;,&#x27;auto_codeIgniter_helper&#x27;,&#x27;member&#x27;)); $this-&gt;page_data[&#x27;folder_name&#x27;]=trim(substr($this-&gt;router-&gt;directory, 0, -1)) ; $this-&gt;page_data[&#x27;controller_name&#x27;]= trim($this-&gt;router-&gt;class); $this-&gt;page_data[&#x27;method_name&#x27;]= trim($this-&gt;router-&gt;method); $this-&gt;page_data[&#x27;controller_info&#x27;]= $this-&gt;config-&gt;item($this-&gt;page_data[&#x27;controller_name&#x27;],&#x27;module&#x27;); $this-&gt;config-&gt;load(&#x27;aci&#x27;); $this-&gt;aci_config = $this-&gt;config-&gt;item(&#x27;aci_module&#x27;); $this-&gt;aci_status = $this-&gt;config-&gt;item(&#x27;aci_status&#x27;); $_pageseo = $this-&gt;config-&gt;item($this-&gt;router-&gt;class,&#x27;seo&#x27;); $_default_pageseo = $this-&gt;config-&gt;item(&#x27;default&#x27;,&#x27;seo&#x27;); $this-&gt;page_data[&#x27;title&#x27;] = isset($_pageseo[&#x27;title&#x27;])?$_pageseo[&#x27;title&#x27;] : $_default_pageseo[&#x27;title&#x27;]; $this-&gt;page_data[&#x27;keyword&#x27;] = isset($_pageseo[&#x27;keywords&#x27;])?$_pageseo[&#x27;keywords&#x27;] : $_default_pageseo[&#x27;keywords&#x27;]; $this-&gt;page_data[&#x27;description&#x27;] = isset($_pageseo[&#x27;decriptions&#x27;])?$_pageseo[&#x27;decriptions&#x27;] : $_default_pageseo[&#x27;decriptions&#x27;]; unset($_pageseo); unset($_default_pageseo); //如果未安装，执行安装 if(!$this-&gt;aci_status[&#x27;installED&#x27;]&amp;&amp;$this-&gt;page_data[&#x27;folder_name&#x27;]!=&quot;setup&quot;) die(&quot;未安装&quot;); $this-&gt;all_module_menu = getcache(&quot;cache_module_menu_all&quot;); $this-&gt;load-&gt;vars($this-&gt;page_data); $this-&gt;_check_module(); &#125; 主要看标红的部分，$_default_pageseo是没有设置seo信息时默认的内容，就是第一步seo.php里修改的文字，若设置了seo信息，则从$_pageseo里获取，$_pageseo的内容来自哪里？来自seo.php，新增一个的话： 123$config[&#x27;seo&#x27;][&#x27;movie&#x27;][&#x27;title&#x27;]= &#x27;title movie&#x27;;$config[&#x27;seo&#x27;][&#x27;movie&#x27;][&#x27;keywords&#x27;]= &#x27;keyword movie&#x27;;$config[&#x27;seo&#x27;][&#x27;movie&#x27;][&#x27;decriptions&#x27;]= &#x27;description movie&#x27;; movie是对应的controller名字，这样实现的是固定的页面seo内容。 我的问题是，动态的SEO内容，就像打开一个产品页面，显示每一个具体产品的SEO信息，而不是一个固定的。 OK，解决方法是在Front_Controller中加入方法： 12345678910111213141516/** * 自定义页面seo内容，子页面在渲染页面之前调用(view之前) * @param $title * @param $keyword * @param $description */ function seo($title, $keyword, $description) &#123; $_default_pageseo = $this-&gt;config-&gt;item(&#x27;default&#x27;, &#x27;seo&#x27;); $this-&gt;page_data[&#x27;title&#x27;] = empty($title) ? $_default_pageseo[&#x27;title&#x27;] : $title; $this-&gt;page_data[&#x27;keyword&#x27;] = empty($keyword) ? $_default_pageseo[&#x27;keywords&#x27;] : $keyword; $this-&gt;page_data[&#x27;description&#x27;] = empty($description) ? $_default_pageseo[&#x27;decriptions&#x27;] : $description; $this-&gt;load-&gt;vars($this-&gt;page_data); &#125; 上面代码不做解释，然后在每个Controller的action中，渲染页面之前（$this-&gt;view()），调用$this-&gt;seo($title, $keyword, $description)。 就是这样，中午没睡好，脑子不灵，语言组织不搭。。。","categories":[{"name":"php","slug":"php","permalink":"https://lison.cc/categories/php/"}],"tags":[{"name":"seo","slug":"seo","permalink":"https://lison.cc/tags/seo/"},{"name":"aci","slug":"aci","permalink":"https://lison.cc/tags/aci/"}],"author":"Lison"},{"title":"现在还能听到的那个","slug":"sound-of-flute","date":"2017-06-21T03:24:26.000Z","updated":"2023-11-16T06:15:51.689Z","comments":true,"path":"sound-of-flute/","link":"","permalink":"https://lison.cc/sound-of-flute/","excerpt":"","text":"现在还能听到的那个应该是笛声，断断续续，应该是在说些感谢跟祝福的话。开始的时候我还以为是卖水的，吃饭的中间一直在响，开窗望去原来是一对老夫妇在沿街乞讨。 他们走的非常缓慢。 我想如果是职业的选手的话，这个点应该也下班了。老婆说要不下去给他们几块，我说这种事，不要刻意为之。 结果吃完饭家里没有水了，要下去打些水，就是小区里打卡出水的那种。于是便带上钱包，穿上背心拖着鞋，出了门。 九月。今天下了雨，虽然很多人还是穿着短袖，但是外面已经满是冷冷的空气了，何况已经是夜里了。 路上想，会有几个人会施舍怜悯，是仅有？还是没有。 因为住在这里虽然不能说饱受诟病，但也有很多事会让人生气了。狗仗人势的门卫，一个气球能卖十块的”老大爷“，车子无故被从头划到尾，都让我时刻提醒自己，生活在别人的村庄里。 是的，这里就是这样。 远远走过去，老头子拄着双拐好像是吹笙；老妇在喊着帮帮我们，老天爷保佑你们的话。 有路过的人给了钱就走了，我走过去的时候老妇转过去那边喊，我拿出20块递给老头，他停下笙，接过钱，我没有等他说话，径直走了，后面传来老妇的话：”谢谢弟弟“。很多时候，不知道为什么，我不敢看他们的眼睛。 我打满水往后走，他们依然走的很慢。零星的有人地给他们钱。 那个女生又走过来，递过两包方便面，然后打开怀里的铁盒子，说这里还有些什么东西。 我没有听清。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"旧事重提","slug":"旧事重提","permalink":"https://lison.cc/tags/%E6%97%A7%E4%BA%8B%E9%87%8D%E6%8F%90/"}],"author":"Lison"},{"title":"去年的新年愿望，实现了吗？","slug":"plan-annual","date":"2017-05-19T03:17:23.000Z","updated":"2023-11-16T06:15:51.643Z","comments":true,"path":"plan-annual/","link":"","permalink":"https://lison.cc/plan-annual/","excerpt":"","text":"地球再度绕着太阳运行到了一个固定位置。为了让这一刻具备仪式感，人类名之为“新年”，定了些固定的庆祝仪式，吃饺子喝酒，放烟火办晚会，在微信上互发复制来的祝语和表情，以及，自欺欺人地立志实现几个新年愿望。 我握拳，下定决心，前年许下而去年没做的愿望，绝不能拖到明年，今年一定要实现。 最简单有时又最奢侈的愿望，是保持呼吸，不要断气。除此外，最常见的愿望有四——减肥、戒烟、还清债务，和亲友共度更多时间。 然而，大概只有十分之一的人能达成愿望。英国赫福郡大学的心理学者理查德·魏斯曼 (Richard Wiseman)研究3000 人后发现， 88%的决心最终失败。决心湮没在时光里，就像石子沉没在长河中，激起的涟漪只是一瞬，此后河水汤汤，依然如故。 这次必须不一样！我决心打破“无志之人常立志”的怪圈，成为“有志之人立长志”。不过首先，我要搞清楚，为什么我去年的新年志向没有实现？ 失败原因一：许下的愿，不是真正志向你以为你想要的就是你所需要的吗？ 很多时候，你并不知道什么能让自己幸福。 中大奖等于变幸福？菲利普 •布里克曼（Philip Brickman ）的研究显示，彩票大奖得主的幸福程度很快就归于平常。好天气能让人心情舒畅？丹尼尔 •卡尼曼(Daniel Kahneman) 发现，阳光明媚的加州人，和天气一般的美国中西部人，其生活满意度大抵相当。买下这样商品就能让我更快乐？结果商品在墙角积灰，而瘪瘪的钱包令人郁郁不乐。 “不快乐往往不是缘于我们没能得到想要的，而是缘于我们不想要我们真正喜欢的。”哈佛心理学家丹尼尔·吉尔伯特（Daniel Gilbert）如是说。他和心理学家蒂莫西·威尔逊（Tim Wilson）曾找来一群美国助理教授（assistant professor），问他们一个简单的问题，“你认为，拿到终身教职对你的幸福有多大影响”？ 所有助理教授都认为，会影响深远。他们遥想未来，若能拿到铁饭碗，自己肯定日日笑口常开，走路带风。若拿不到，自己必然天天愁眉不展，惨淡度日。 后续追踪发现，教授们错了。在未来几年里拿到终身教职的，和未拿到终身教职的，主观幸福程度相差无几——即使智力出类拔萃，也不太擅长预测“什么能让自己更幸福”。吉尔伯特和威尔逊为此造了个新词——“错误渴求（ miswanting）”，专指“错误预测了自己的需求，错误地估计了自己要得到什么才会快乐，因而做出了差劲的决策。” 当你不太费力就能实现愿望时，问题一般不大，无非是“得到了却发现不过如此 ”。但当你许下的愿望需要付出很多才能实现时，你就会在付代价时踟蹰犹豫，不断拖延，或者干脆只是将这个愿望挂在嘴上，一点不开展积极行动。 解决方案一：连问自己五次，“为什么我想要”有个简单办法，能帮你找出潜藏在心中的真正愿望。 先写出自己心目中的愿望，接着自问“为什么我想要这个？” 得到答案后，继续追问“为什么这么想？” 如此连续发问，一般5次内即可发现你真正的渴望。 也许你第一个自然浮出的愿望是“戒烟”，但不要止步于此，要继续追问下去——为什么想戒烟？因为希望更健康。为什么希望更健康？因为健康可以活得长久。为什么想要活久一点？因为想多照顾家人一段时光。为什么想多照顾家人？因为我想成为负责的人…… 很多戒烟的人之所以失败，是因为他们错误地估计了自己的愿望——或许你不想戒烟，你真正想要的，是成为家人的可靠支撑。在“吸烟”和“不吸”之间，你会选择能带来快感的吸烟。然而，当你将“烟”视为自己照顾家人的阻碍时，你会选择“照顾家人”。村上春树一度日抽60支烟，后来戒烟，不是因为他厌倦了烟草，是因为他发觉写小说需要体能，于是决心锻炼，于是开始跑步，于是渴望跑得更多——而烟草，作为跑步的阻碍，就被自然而然地放弃了。 失败原因二：四类愿望，注定无法实现一个典型的的新年愿望是这样的—— “我希望新年里，事业上个新台阶，财富多个数量级，全家和睦亲密，故旧健康平安，多联系老友，多认识新友，行万里路，读万卷书，看尽佳片，吃遍美食，到了年末还要瘦上二十斤！ ” 四个字总结——这不科学。问题在哪 ? 一，愿望不要太多。多到记都记不住，时间不够分配，谈何实现？ 二，愿望不要自相矛盾。有的职业，注定无法天天和家人相处。要甩肉，就得泪别诸多美食。想健康，就得关掉电视放下书，甩开膀子迈开腿。 三，愿望不要太难。从难度来说，愿望应该尽量设成“有难度，但努力后很可能达成 ”。 最难实现的目标是什么？ Daniel Kahneman认为，是“在演员之路上大获成功”。不过，假如这恰是你的心之所向，祝你新年好运。 四，愿望不要太大。大到任何一项拿出来，都必须投入大量时间精力。 作家 Nigel Marsh说，“平衡工作和家庭很简单，只要我不工作就得了。”他辞职，赋闲一年，专职陪妻子和四个儿子。“当然了，”他补充说，“在缺钱的时候，这招不怎么好用。”大部分人没有余闲去享受这种奢侈。也就是说，我们未来一年里的将近三成时间已经卖给了买家——不信就把工作合同拿出来多看几遍。 还有四成时间也有了去处，吃喝拉撒睡。人要正常运作，就得满足基本需求。 然后，我要在剩下的三成时间里，用我软弱的意志力，驱动我迟缓的身体，完成彩衣娱亲呼朋引伴环球旅行看书看电影山珍海味锻炼减肥……请容我再说一遍——这不科学。 那么，如果我们只许一个新年愿望。有没有“最好的新年愿望 ”呢？ 解决方案二：愿望一个足矣，养成“楔石习惯”楔石，是拱桥顶部的一块石头，这块石头是整个架构保持稳定的关键所在。当查尔斯·杜希格 (Charles Duhigg)创造出“楔石习惯（keystone habits）” 这个词时，他指的是一种关键习惯，它能改变大脑的神经模式，能促成其他好习惯蓬勃生长，能引发链式反应，令你的生活发生巨变。 习惯很重要。改变习惯，就能改变行动。改变行动，就能改变最终的结果。一次行动看似微不足道，但你若能从天天下午自动吃蛋糕，变成天天下午自动去慢跑，一年内体型就会出现巨大区别。 每天大概 45%的行动不是出自“决定” ，而是出自 “习惯” 。决定出自前额叶皮质（ prefrontal cortex），懂理性，能自省。习惯出自基底核 (Basal Ganglia)，被线索触发，受欲望支配。明明想去别处，却惯性地走了每天上班的路，这就是习惯给你导的航。习惯帮我们不假思索地料理诸多日常琐事。没有习惯，大脑很快会不堪重负。然而，将重责大任托付给习惯也有坏处 ——有时我们的理性下了决心，而习惯往往拒绝配合。 习惯是顽固的，但同时，习惯也是可以被改动、消灭、创造的——你必须对这点抱有信心，事实上，你必须对这点抱有近乎盲目的信仰。这是改变的关键之一。 什么是典型的楔石习惯？ 一是锻炼。 锻炼能改变你的体型，改变你的大脑 ——包括供血、神经递质和营养因子，另外，锻炼还能改变你的自我认知。你将把自己视为一个有自制力的人 ——毕竟，你都能定期运动了！一旦人们开始锻炼，他们不但身材变好了，分心减少了，而且拖延症往往得到大幅改善——连每天洗碗的时间都提前了 23分钟。 二是记录。 记录是一种提醒，提醒你注意到 “我正在做什么”。记录可以用于回顾，反省“我都做了些什么 ”。另外，一旦养成记录的习惯，在行动开始就有一种清晰的自我意识，因此后续的行为和决策也会受到影响。 2009年，美国国立卫生研究院（ NIH）找来1600 名肥胖者，要求他们试着记录自己吃下的每样东西 ——哪怕一周只记一天也成。六个月后，那些养成了记录习惯的人，减去的重量是未记录者的两倍。原因很简单，记录这个动作，能帮助发现自己的习惯，再也不会 “不知不觉地吃下大量食物 ”。通过天天记录，有些人发现自己会在上午 10点吃上一块小甜饼，在睡前一小时吃掉一袋薯片。现在，他们决定事先做好准备。此后，在同样的时刻，他们习惯性地伸手——拿到并吃掉的是一个苹果。 如果你渴望减重，就记录你吃的每一样东西。如果你总是入不敷出，就记录你的每一项花费。如果你总不知道 “时间都到哪去了”，就记录自己每时每刻的行为（ Rescuetime、atimelogger、爱今天 ）。如果你想修正自己的一个不良习惯，就记录你每次 “犯老毛病” 时的时间、地点、自己情绪、周围有什么别人、之前自己刚刚做了什么。这五样记录能帮助发现，是什么线索触发了你 “走老路” 的习惯。 最后还有一点很重要，不论你选择养成什么楔石习惯，都记得给你的新好习惯设计一个仪式化的结尾 ——我们需要仪式。仪式提供一种即时的回馈，让你感到所做的一切收到了回报。这个仪式可以是一个动作，一块糖果，甚至只是在行事历上的一个五角星标记——只要简单易行、能令你感到愉悦就行。别小看这点奖赏，它将决定你能否养成习惯。而一旦养成楔石习惯，你就能说服自己，我可以改变，我可以有更大的改变。 失败原因三：障碍出现，未曾备好对策你必须意识到一点，在养成习惯的过程中，你一定会失败的——不止一次。 当你在新年假期里压力全无地计划着 “来年我要这么这么做”时，你已经忘了，一旦假期结束，你立刻会进入与此刻完全不同的状态 —— 现实是什么？现实是体力有限。精力有限。脑力有限。斯坦福的神经经济学教授巴巴·希夫（ Baba Shiv）证明，如你需要费心记住一个 7位数字，你在挑选食物时就更容易选择巧克力蛋糕，而非水果沙拉——就好像我们一天能干的 “好事” 有个上限。一旦到了这个限度，你就只想抽根烟来杯酒吞下一桶炸鸡腿，然后摊在床上刷手机刷到睡着。 现实是，改变很难。养成好习惯很难。做正确的事很难。传说养成一个习惯需要 21天—— 错，许多人需要的时间远不止此。 2009年，英国伦敦大学学院的一项研究发现，养成一个习惯最短需要 18天，最长则花了差不多8个半月。 现实是，我们不喜欢改变，事实上，我们抵触改变，哪怕我们明知这改变对我们有益。我们还是会故态复萌，一次，一次，又一次。 80%的戒烟者在成功戒烟前，会复吸 8到10 次。 我们失败。这很正常。致命的是我们对于失败的反应 ——我们选择自毁，因为我们被失败压垮，我们相信自己无法改变，只能顺从本能的渴望。我们习惯偷懒，习惯放弃，习惯对自己失望，习惯了设定目标又从不达到，最后索性习惯了没有目标。我们告诉自己，人生就是这么丧，我就是这么烂，放弃吧，我将躺在泥潭中，边下沉，边宣布星空只是幻象。 怎么办？首先，你得接受“倒退”是进步的一部分。你得相信，一次失败不代表你达不到你的目标。如果我在成功之前需要失败 100次，那么现在，就只剩下 99次。 此外，你还需要一个预先定好的 “失败应对方案”。 解决方案三： WOOP，假如遇到障碍A，我就执行计划B比方说，你的愿望是 “我要每天早上晨跑一小时 ”。 你闭目想象，闹钟一响，自己掀被而起，套进跑鞋，冲出家门，沐浴在金色阳光中，呼吸着清冷透亮的空气，你像羚羊在非洲草原上奔跑，啊，奔跑。 想象结束，你感觉棒极了。 事实上，这样的 “成功幻想” 一次就能降低血压 5毫米汞柱，简直堪称无毒无害无副作用的舒缓放松良方。 一切都好，除了一点 ——这种幻想对你实现愿望只有阻碍，毫无帮助。 当你在想象中已经体验过了成功的甘美，何必还在现实中为之辛苦拼搏呢？纽约大学的心理学家加布里埃尔 •奥丁根（Gabriele Oettingen）发现，学生在对学业进行乐观幻想后，在未来一周内反而会减少投入学业；那些对自己的自制力最有信心的减重女士，偏偏是一年后减重最少的人。 别做梦了，醒醒吧。对比一下美好理想和现实中的重重阻碍，通过这种对比，找出克服障碍、接近理想的道路。这种方法，叫“ WOOP”。 WOOP分四步。 一、愿望（ Wish），别等了，现在就抓张白纸，写下一个对你深具意义、具体可执行的愿望——譬如说，每天早晨晨跑一小时。 第二步，想象成果（ Outcome），想象达到目标后你将如何从中获益——譬如说，好看，不抑郁，治疗拖延症。在未来的懈怠时刻，你就可以翻出这三条，提醒自己当初许愿的初心。 第三步是真正难点——寻找障碍（ Obstacle）。你可能前一晚睡不着觉，第二天起不了床。可能你明明打算跑步，起床后却不知不觉刷了一小时手机。可能窗外北风呼啸，而你发现自己瞬间皈依了回笼教。没准你跑了两天就感冒，再跑一周已濒危。或许你挣扎半响垂死病中惊坐起，却发现窗外白茫茫一片雾霾已爆表…… 第四步，计划（ Plan）。计划必须是如下形式 ——“假如处在X 状况下，我就采取 Y行动”。假如我睡不着，我就闭眼平躺练习冥想。假如我起不了床，我就告诉自己，我可以做到。假如空气糟到不适合跑步，我就在室内进行力量训练。假如我觉得不想跑步，我对自己说， “这是我发自内心的愿望”…… 诸如此类。 针对不同的障碍，你可以做出一张张 WOOP小卡片，存在电脑里，写在本子中，最重要的，是牢记在心底。在一些困难的抉择时刻，在一些不确定的时刻，我们会忘记自己的理想和初衷，你需要一次次地自动提醒自己，我的心愿是什么，我想去到的地方在哪里，这一年，我一定能养成我的楔石习惯，而更大的改变也将近在咫尺，不再遥不可及。 参考资料 Duhigg, Charles. The power of habit: Why we do what we do in life and business. Vol. 34. No. 10. Random House, 2012. Kahneman, Daniel. Thinking, fast and slow. Macmillan, 2011. Lehrer, Jonah. How we decide. Houghton Mifflin Harcourt, 2010. Oettingen, Gabriele. Rethinking positive thinking: Inside the new science of motivation. Penguin, 2014. O’Connor, Richard. Rewire: Change Your Brain to Break Bad Habits, Overcome Addictions, Conquer Self-destructive Behavior. Penguin, 2014. Evans, Olga, and Andrew Steptoe. “Social support at work, heart rate, and cortisol: a self-monitoring study.” Journal of occupational health psychology 6.4 (2001): 361. Lally, Phillippa, et al. “How are habits formed: Modelling habit formation in the real world.” European Journal of Social Psychology 40.6 (2010): 998-1009. Shilts, Mical Kay, Marcel Horowitz, and Marilyn S. Townsend. “Goal setting as a strategy for dietary and physical activity behavior change: a review of the literature.” American Journal of Health Promotion 19.2 (2004): 81-93. 作者：游识猷链接：http://www.guokr.com/article/441938/来源：果壳本文版权属于果壳网（guokr.com，微信公众号：Guokr42）","categories":[{"name":"生人","slug":"生人","permalink":"https://lison.cc/categories/%E7%94%9F%E4%BA%BA/"}],"tags":[],"author":"Lison"},{"title":"树莓派学习使用入门资料整理 – Raspberry PI","slug":"hello-raspberrypi","date":"2017-05-15T03:14:52.000Z","updated":"2023-11-16T06:15:51.611Z","comments":true,"path":"hello-raspberrypi/","link":"","permalink":"https://lison.cc/hello-raspberrypi/","excerpt":"关于[Python]，人生苦短，我用python Python2.x 与Python3.x 存在严重的兼容性问题 python快速教程 python初级教程 关于opencv OpenCV 编程简介（矩阵/图像/视频的基本读写操作）Emgu cv Tutorial 关于Linux学习 树莓派与Linux Debian 学习笔记 鸟哥的Linux私房菜 Quick Start Guide for those more experienced with UNIX 关于树莓派 树莓派入门指南用python让树莓派说话树莓派吧树莓派官方社区Python讨论版极客工仿树莓派板块树莓派中文站Mike’s Electric Stuff 查设备sheet树莓派I2C接口扩展树莓派GPIO使用探索Wiring PiWiringpi.com 官网CaféAllDatasheetSearch DatasheetHandbook of hardware schemes, cables layouts and connectors pinoutsAll PinoutsAdaFruitAsterisk搭建VoIP树莓派学习索引","text":"关于[Python]，人生苦短，我用python Python2.x 与Python3.x 存在严重的兼容性问题 python快速教程 python初级教程 关于opencv OpenCV 编程简介（矩阵/图像/视频的基本读写操作）Emgu cv Tutorial 关于Linux学习 树莓派与Linux Debian 学习笔记 鸟哥的Linux私房菜 Quick Start Guide for those more experienced with UNIX 关于树莓派 树莓派入门指南用python让树莓派说话树莓派吧树莓派官方社区Python讨论版极客工仿树莓派板块树莓派中文站Mike’s Electric Stuff 查设备sheet树莓派I2C接口扩展树莓派GPIO使用探索Wiring PiWiringpi.com 官网CaféAllDatasheetSearch DatasheetHandbook of hardware schemes, cables layouts and connectors pinoutsAll PinoutsAdaFruitAsterisk搭建VoIP树莓派学习索引","categories":[{"name":"raspberry pi","slug":"raspberry-pi","permalink":"https://lison.cc/categories/raspberry-pi/"}],"tags":[],"author":"Lison"},{"title":"Android WebView JS 与 Java Native 相互调用示例","slug":"android-webview-java-native","date":"2017-04-11T03:12:08.000Z","updated":"2023-11-16T06:15:51.368Z","comments":true,"path":"android-webview-java-native/","link":"","permalink":"https://lison.cc/android-webview-java-native/","excerpt":"直接上代码，有注释，学习Android过程记录。 Android Activity代码","text":"直接上代码，有注释，学习Android过程记录。 Android Activity代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758，并暴露对象名为ntv，js使用window.ntv.functionName()方式调用 wv.addJavascriptInterface(new JsCall(), &quot;ntv&quot;); ws = wv.getSettings(); ws.setJavaScriptEnabled(true); //不使用缓存 ws.setCacheMode(WebSettings.LOAD_NO_CACHE); //支持缩放 ws.setSupportZoom(true); //自适应屏幕 ws.setUseWideViewPort(true); ws.setLoadWithOverviewMode(true); &#125; //js调用的类及方法 class JsCall &#123; @JavascriptInterface public String tost(String msg) &#123; Toast.makeText(activity, &quot;toast: &quot; + msg, Toast.LENGTH_SHORT).show(); return &quot;JsCalled Native: &quot; + msg; &#125; &#125; //回退栈（WebView页面） @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack();//返回上一浏览页面 return true; &#125; else &#123; finish();//关闭Activity &#125; &#125; return super.onKeyDown(keyCode, event); &#125; //ActionBar菜单 @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.main, menu); return super.onCreateOptionsMenu(menu); &#125; //ActionBar菜单响应 @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_item: Toast.makeText(this, &quot;Menu Item&quot;, Toast.LENGTH_SHORT).show(); return true; default: return super.onOptionsItemSelected(item); &#125; &#125;&#125; 布局文件LinearLayout布局，orentation=vertical，一个EditText，一个Button一个WebView，长什么样子的话想象一下就好了。 html文件，同样非常简单 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt; &lt;title&gt;DEMO TEST&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fill(val) &#123; var txt=document.getElementById(&#x27;txtinput&#x27;); txt.value=val; alert(val); &#125; function native() &#123; var txt=document.getElementById(&#x27;txtinput&#x27;); alert(window.ntv.tost(txt.value)); &#125; &lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt;body&#123; font-size: 20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;txtinput&quot; /&gt;&lt;br /&gt; &lt;button onclick=&quot;native()&quot;&gt;CALL JAVA NATIVE&lt;/button&gt;&lt;/body&gt; 参考资料：developer.android.com WebView 源码下载：WebViewNJs","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"Python 文件内容读取示例 Python open打开操作文件","slug":"python-readfile","date":"2017-04-10T03:09:52.000Z","updated":"2023-11-16T06:15:51.647Z","comments":true,"path":"python-readfile/","link":"","permalink":"https://lison.cc/python-readfile/","excerpt":"整理了一些数据需要批量更新到数据库，内容如： 001 009002 008003 007 要生成的语句：update table_name set column=009 where id=001 使用python一共三行语句：","text":"整理了一些数据需要批量更新到数据库，内容如： 001 009002 008003 007 要生成的语句：update table_name set column=009 where id=001 使用python一共三行语句： 123for line in open(&quot;data&quot;, &#x27;r&#x27;): arr = str(line).split() print(&#x27;update xx set region=\\&#x27;&#x27; + arr[1] + &#x27;\\&#x27; where no=\\&#x27;&#x27; + arr[0] + &#x27;\\&#x27;&#x27;) open方法是内置方法（Build-in function），文档解释为：Open file and return a corresponding file object，打开文件并且返回该文件对象。 将line转换为string并分割成数组，split方法若不加任何参数则默认使用任何空白字符（空格，制表符等）进行分割，并且自动去处数组内的空白元素，太方便了，split官方说明： S.split(sep=None, maxsplit=-1) -&gt; list of strings Return a list of the words in S, using sep as thedelimiter string. If maxsplit is given, at most maxsplitsplits are done. If sep is not specified or is None, anywhitespace string is a separator and empty strings areremoved from the result. 这行就是组织sql语句了 人生苦短，我用python","categories":[{"name":"python","slug":"python","permalink":"https://lison.cc/categories/python/"}],"tags":[],"author":"Lison"},{"title":"肥美的我 | 中国业余无线电操作证书","slug":"radio-license","date":"2017-04-05T03:02:29.000Z","updated":"2023-11-16T06:15:51.660Z","comments":true,"path":"radio-license/","link":"","permalink":"https://lison.cc/radio-license/","excerpt":"终于拿到牌照，下一步购机、验机拿CALL SIGN。要不要入YAESU FT-857D。。。","text":"终于拿到牌照，下一步购机、验机拿CALL SIGN。要不要入YAESU FT-857D。。。","categories":[{"name":"radio","slug":"radio","permalink":"https://lison.cc/categories/radio/"}],"tags":[],"author":"Lison"},{"title":"The Connoisseur of Great Excuse","slug":"the-connoisseur-of-great-excuse","date":"2017-02-13T02:50:33.000Z","updated":"2023-11-16T06:15:51.857Z","comments":true,"path":"the-connoisseur-of-great-excuse/","link":"","permalink":"https://lison.cc/the-connoisseur-of-great-excuse/","excerpt":"","text":"Damien Rice Of all the foolish things to do我曾做过令自己悔恨的事I became a connoisseur of great excuse却拼命为自己寻找堂皇的托词And my pessimistic past the blame所发生的一切都已于事无补Will never make this go away我的悲观令我永远无法释怀Of all the foolish things I’ve said曾说了许多令自己抱歉的话That keep me sleepy almost dead我逃避到睡梦中昏沉至死 I’m sorry if I’ve let you down万分抱歉若曾令你失望My eyes were closed, they’re open now现在我逐渐睁开我曾紧闭的双眼 I’m waking up我正在逐渐醒来I am waking up我在逐渐醒来I am waking up逐渐醒来I awake清醒过来 And this has all been said before是的曾有人向我指出我的疏忽I’ve listened but then I ignored自大的我却选择充耳不闻My ears grew deaf现在面对着责难我不愿意去听My head gave up也不愿意去想The junkie knows not when to stop如瘾君子一般逃避不已Of all the foolish alibis人们对我编造出的蹩脚借口The constipated push for why并不买账I’ve had a blanket pulled over my eyes我的确曾蒙上双眼假装这一切都没发生过Oh hush now baby don’t you cry但亲爱的你不要再哭了 I’m waking up我正在逐渐醒来I am waking up我正逐渐醒来I am waking up逐渐醒来I’m awake清醒过来I’m waking up我正在逐渐醒来Coming快I am waking up我正逐渐醒来I’m ready我准备好了I am waking up要清醒过来I’m awake我醒过来了Dada da da da daaa","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"生命是一次奇遇","slug":"life-is-an-adventure","date":"2017-01-18T02:43:03.000Z","updated":"2023-11-16T06:15:51.631Z","comments":true,"path":"life-is-an-adventure/","link":"","permalink":"https://lison.cc/life-is-an-adventure/","excerpt":"我只能向前走收集所有美丽所有哀愁也许会在平庸里耗尽我最后一丝气力 我知道黑夜仍让我孤寂我知道欲望不会停息我知道跋涉千里并不要原因生命是一次奇遇","text":"我只能向前走收集所有美丽所有哀愁也许会在平庸里耗尽我最后一丝气力 我知道黑夜仍让我孤寂我知道欲望不会停息我知道跋涉千里并不要原因生命是一次奇遇","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"初识野狗（WildDog）之数据增删改查 – 野狗REST api使用","slug":"wilddog-api","date":"2016-12-02T10:26:59.000Z","updated":"2023-11-16T06:15:51.871Z","comments":true,"path":"wilddog-api/","link":"","permalink":"https://lison.cc/wilddog-api/","excerpt":"","text":"试用了一下野狗云，感觉好到非常。这种开发方式对传统数据库（sql）必然造成很大影响（程序狗一定要居安思危），或者说新的云时代真正来临了。 我所理解的野狗云，就是云端的数据库，但不是传统的mysql，oracle，sqlserver，而是基于key-value存储的文档数据库，或者叫no-sql？不知道这样说准不准确。访问方式基于的http协议，get、post、put、delete等（当然有验证机制）。这样来讲，我们就可以通过其他的url访问工具，例如curl进行数据的增删改查了，官方的文档正是这样写的。 官方文档中使用REST方式操作数据同样使用的是curl工具，感觉写的不是很详细。 今天使用了postman模拟http请求野狗数据的整个过程，包括增加、追加、更新、删除、查询数据的简单操作（不要问我为什么把顺序写成这样），记录一下。 **概念：**数据，或者说一张表，野狗中都叫做节点，可以看下野狗的基础概念文档 先来个官方的简短说明，数据操作包含以下五种请求类型： 方法 说明 PUT 向指定 节点写入数据。若此节点已存在数据，会覆盖原有数据。 POST 向指定节点添加 子节点。子节点的 key 自动生成并保证唯一。 PATCH 更新指定子节点。 DELETE 删除指定节点。 **增加数据（节点）：**使用http请求put方式，请求https://wild-sheep-1485.wilddogio.com/movie.json上面的movie.json就是节点名称，将创建一个名为movie的节点，如下图： 需要注意的是Headers中要增加Content-Type=application/json键值对，并且Body选项卡要设置raw格式，点击Send将创建movie节点，并为其增加一个movie1的子节点（一条数据），可以看到使用了两个字段（节点，一切皆节点）name和actor。注意：put操作会先清空指定节点，再写入数据。 追加数据（这个非常有必要说明）传统的sql中插入数据不管表里有没有数据，只要闭着眼睛执行insert into行了。那么既然put操作会先清空指定节点，然后再写入数据，那么我追加数据的时候总不能先把以前的数据取出来，然后再加上一条，然后再put吧（对不对，讲道理嘛）。所以搞了半天，弄明白追加数据是这样的，如图： 可以看到这次使用的patch方法，节点名称movie.json等都没有改变，就为movie增加了一个movie3子节点，并且actor写成了集合形式。 **更新数据**更新数据与追加数据一样，也是使用的patch方法，如图： 比如我要更新movie节点下movie3的name（从铁达尼号变成泰坦尼克号），就要使用patch方式，注意请求的地址（野狗中叫路径） 删除数据比如要把上图中的actor中的0（迪卡普里奥删掉），那么需要执行delete请求，请求地址为：https://wild-sheep-1485.wilddogio.com/movie/movie3/actor/0.json（可以看到节点查找方式，即路径名称），删除之后的节点为： 查询数据你以为查询数据最简单了？Oh no，虽然执行get是很简单，比如获取所有的数据（节点），我又新增了user节点和数据： 注意路径是以 .json结尾，标识获取所有节点，若要获取某个确定的节点，只需指定节点名即可，比如user.json 查询数据官方还支持orderBy和过滤等操作，暂时没详细看传送门。 先写到这里，感谢野狗两位大牛 @六金、@董笑飞的热心解答。 学习新知识是自我蜕变的过程，如果你在刻标记的地方捞剑，你可能捞到的不是剑 (:P 技术知识积累分享, 应用地址未打码, 请勿黑 .原创文章，转载请注明出处。","categories":[{"name":"云","slug":"云","permalink":"https://lison.cc/categories/%E4%BA%91/"}],"tags":[],"author":"Lison"},{"title":"虚度","slug":"xudu","date":"2016-11-16T10:25:15.000Z","updated":"2023-11-16T06:15:51.875Z","comments":true,"path":"xudu/","link":"","permalink":"https://lison.cc/xudu/","excerpt":"“我三分之一的人生 就这样浑浑噩噩的过去了 时间渐渐模糊了那些美丽而又可笑的往事 逝去的残酷青春还未来得及留下任何痕迹 世俗已将我变得丑陋不堪 于是我常常怀疑生活的意义 大概 你也曾与我一样迷茫吧 但我一直坚信 在每个人的内心深处 总有一个未曾沉沦的理想世界 我想 也许我们 一直都活在那里”","text":"“我三分之一的人生 就这样浑浑噩噩的过去了 时间渐渐模糊了那些美丽而又可笑的往事 逝去的残酷青春还未来得及留下任何痕迹 世俗已将我变得丑陋不堪 于是我常常怀疑生活的意义 大概 你也曾与我一样迷茫吧 但我一直坚信 在每个人的内心深处 总有一个未曾沉沦的理想世界 我想 也许我们 一直都活在那里” 看漂浮的人群 听忘记名字的歌曲 想昨夜梦中的情景 让我感觉清晰却突然忘记 天也渐渐的暗下去 高楼上的霓虹开始窃窃私语 似乎有风吹过我的头顶 我还在飘飘荡荡 别问我在哪里 别问我在哪里 别问我在哪里","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"Solidworks PDM：如何查找PDM文件在服务器中的物理路径","slug":"solidworks-find-pdm","date":"2016-11-08T10:19:06.000Z","updated":"2023-11-16T06:15:51.684Z","comments":true,"path":"solidworks-find-pdm/","link":"","permalink":"https://lison.cc/solidworks-find-pdm/","excerpt":"PDM允许用户在使用它的文档节点（vaults）管理各种各样类型的文件，并且通过EPDM接口可以方便的查找和修改这些文件。但是作为EPDM文档管理员的你可能想要得到EPDM文件的真实物理路径（资源定位符路径，例如：C:/new.txt），用来找回丢失的文件，或者其他目的。要找到他们并不是很困难，只需要在SQL中执行以下几个步骤。","text":"PDM允许用户在使用它的文档节点（vaults）管理各种各样类型的文件，并且通过EPDM接口可以方便的查找和修改这些文件。但是作为EPDM文档管理员的你可能想要得到EPDM文件的真实物理路径（资源定位符路径，例如：C:/new.txt），用来找回丢失的文件，或者其他目的。要找到他们并不是很困难，只需要在SQL中执行以下几个步骤。 现在我们来假设一下在文档节点中有一个名为：170-012-011.sldprt的文件，我们想知道它具体存在于哪个文档目录中。需要在SQL中查询Documents表。 打开SQL Server Management Studio，连接好SQL实例。执行下面的select语句. 1SELECT DocumentID, CONVERT(varbinary,DocumentID) as ID_Hex_Value, Filename FROM Documents where Filename like ‘170-012-011%’ 会得到如图的结果： 我们来看下查询语句，我们从Documents表（FROM Documents）查询了document ID字段（SELECT Document ID），并且把查询到的Document ID转换成了一个16进制值（CONVERT(varbinary,DocumentID) as ID_Hex_Value）（稍候我们会看到为什么要这样做），然后还有一个文件名，Filename字段（where Filename like’170-012-011%‘） 现在有趣的来了，EPDM如何知道文件的具体位置呢？ 可以看到Document ID：3228的16进制值是C9C。现在把C9C组成一个8位数字，左边空白补0，就变成了00000C9C。那么我们要查找的文件目录就是：\\C\\00000C9C。’\\C\\’定义了文件存储在名称为C的目录中，而00000C9C则是子目录的名称，如图。 然后打开目录就能看到。通常目录里会有一个index.xml文件。 然后要查找的170-012-011.sldprt文件就是 00000001.SLDPRT。要验证是否正确的话，就打开index.xml可以看到filename。 ok，就是这样，要注意的是，不要手动修改这些文件，这样会对数据库产生影响。 本文翻译自：CAPUniversity《How To Find Your Enterprise PDM Files Within the Archives Directory》","categories":[{"name":"t-sql","slug":"t-sql","permalink":"https://lison.cc/categories/t-sql/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"Wings – Birdy","slug":"birdy-wings","date":"2016-10-27T10:17:19.000Z","updated":"2023-11-16T06:15:51.588Z","comments":true,"path":"birdy-wings/","link":"","permalink":"https://lison.cc/birdy-wings/","excerpt":"","text":"Sunlight comes creeping in Illuminates our skin We watch the day go by Stories of all we did It made me think of you It made me think of you Under a trillion stars We danced on top of cars Took pictures of the stage So far from where we are They made me think of you They made me think of you Oh lights go down In the moment we’re lost and found I just want to be by your side If these wings could fly For the rest of our lives I’m in a foreign state My thoughts they slip away My words are leaving me They go another place Because I thought of you Just from the thought of you Oh lights go down In the moment we’re lost and found I just want to be by your side If these wings could fly Oh damn these walls In the moment we’re ten feet tall And how you told me after it all We remember tonight For the rest of our lives If these wings could fly Oh lights go down In the moment we’re lost and found I just want to be by your side If these wings could fly Oh damn these walls In the moment we’re ten feet tall And how you told me after it all We remember tonight For the rest of our lives","categories":[{"name":"Literature Library","slug":"Literature-Library","permalink":"https://lison.cc/categories/Literature-Library/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"apktool反编译与重新打包学习，apk反编译与重新签名学习，keytool-jarsigner","slug":"android-apktool","date":"2016-09-18T10:12:07.000Z","updated":"2023-11-16T06:15:51.351Z","comments":true,"path":"android-apktool/","link":"","permalink":"https://lison.cc/android-apktool/","excerpt":"有个玩无线电的朋友问我会不会破解软件，我说太难的搞不了，有些是混淆过的；他说有个好像是测无线电天线的设备（天调？）是绑定蓝牙mac的让我给搞定下，安卓的app。","text":"有个玩无线电的朋友问我会不会破解软件，我说太难的搞不了，有些是混淆过的；他说有个好像是测无线电天线的设备（天调？）是绑定蓝牙mac的让我给搞定下，安卓的app。 于是完成之后记录下。之前没事时候用过apktool，jd-gui，dex2jar等工具还有在线的，不过玩着玩着就扔掉了，这次答应了人家，起码弄出个123吧。 本次用到的工具： apktool2.2 keytool，位于jdk/bin目录 jarsigner，位于jdk/bin目录 最初使用的直接apk包改扩展名zip，拿出classex.dex，然后dex2jar，拿到java文件之后想把源码直接拿出来复制到一个新工程里去，跟重新做差不多，因为看到里面只有四个Activity : DeviceListActivity.java DrawChart.java MainActivity.java MyApplication.java 比较简单，字面意思都能猜出是干嘛的，设备列表Activity，显示匹配/未匹配的蓝牙设备吧？DrawChart绘制曲线的吧？MainActivity和MyApplication都不用说了，主界面和入口，哇塞我敏锐的直觉囧。。。然后软件运行截图是这样的： 玩无线电的就是高大上，直接看不懂。。。 打开设备列表Activity之后就能看到写死的蓝牙地址，于是数组里再加入一个 1private static String[] xx2009Address = &#123; &quot;98:D3:31:B0:F2:FD&quot;, &quot;98:D3:31:B0:29:B3&quot;, &quot;98:D3:31:B0:F2:FC&quot;, &quot;98:D3:31:B0:F2:FD&quot; &#125;; 但是复制到新工程之后就各种报错，比如do{ return;xxx;xxx; }while(1)；这种，do里面直接return，肯定是不对的，然后各种重新反编译最后都不能直接拿来用，是不是我想的太简单了。。。虽然拿到了源码，但是有错误，尤其DrawChart里面的代码，gdi编程的错误真心搞不了。 然后又使用apktool d xxx.apk反编译得到smali文件列表（smali语法也玩不转）找到DeviceListActivity直接替换掉数组里面的蓝牙mac地址，ok第一步算完成了； 接着使用apk b xxx（xxx代表刚才反编译得到的文件路径），重新打包，在xxx/dist目录下会生成新的apk文件；这个时候apk是没有签名的，也不能安装到安卓手机中，需要对apk文件进行签名，过程如下： 1.首先生成签名文件，直接切换至**%JAVA_HOME%/bin目录，使用**keytool -genkey -alias new.keystore -keyalg RSA -validity 20000 -keystore new.keystore命令生成文件，中间不断下一步，输入密码填信息什么的，上面的语句就会在当前目录生成的签名文件new.keystore 2.使用jarsigner签名apk，将apk拷贝至%JAVA_HOME%/bin目录，输入命令：jarsigner -verbose -keystore new.keystore -signedjar Mini60X-signed.apk Mini60X.apk new.keystore new.keystore就是1步生成的签名文件，Mini60X-signed.apk就是要生成的签名之后的文件名，Mini60X.apk是你的apk文件名，运行结果如下： 就会在当前目录生成Mini60X-signed.apk，下面的Warning我没管它，然后就安装到手机上吧。 声明：本文只为学习安卓打包与签名机制使用，不针对任何app生产厂商，本文及作者不承担任何法律内外责任。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"js随机生成双色球奖券代码","slug":"js-lotty","date":"2016-08-24T10:06:14.000Z","updated":"2023-11-16T06:15:51.630Z","comments":true,"path":"js-lotty/","link":"","permalink":"https://lison.cc/js-lotty/","excerpt":"","text":"源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;LOTTY WINNER~&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html &#123; font-size: 12px; font-family: &quot;sans serif&quot;, tahoma, verdana, helvetica; &#125; body &#123; text-align: center; padding-top: 20%; &#125; #pool &#123; padding: 10px; border: dashed 1px orangered; width: 40%; min-height: 200px; margin-left: auto; margin-right: auto; max-height: 200px; overflow: auto; overflow-y: yes; &#125; #pool span &#123; font-size: 24px; line-height: 36px; &#125; #pool .red &#123; color: indianred; &#125; #pool .blue &#123; color: dodgerblue; &#125; .title &#123; &#125; .red &#123; color: indianred &#125; .blue &#123; color: dodgerblue &#125; .green &#123; color: forestgreen &#125; .purple &#123; color: mediumpurple &#125; .pink &#123; color: deeppink &#125; .dark &#123; color: black &#125; .yellow &#123; color: yellowgreen &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //红色选择六个数 1-33里选 //蓝色选择一个数 1-16里选 var ticket = &#123;&#125;; window.onload = function () &#123; var btn = document.getElementById(&#x27;lotty&#x27;); //摇奖按钮事件 btn.addEventListener(&#x27;click&#x27;, function () &#123; reset_ticket(); for (var i = 0; i &lt; 6; i++) &#123; ticket[&#x27;red&#x27;].push(Math.floor(Math.random() * 33 + 1)); &#125; ticket[&#x27;blue&#x27;] = Math.floor(Math.random() * 16 + 1); append_pull(ticket); &#125;); //自动滚动生成 var scroll = document.getElementById(&quot;scroll&quot;); var interval; scroll.addEventListener(&#x27;click&#x27;, function () &#123; if (scroll.innerHTML == &#x27;SCROLL@&#x27;) &#123; scroll.innerHTML = &quot;PAUSE-&quot;; //开始滚动 interval = setInterval(function () &#123; btn.click(); &#125;, 1000); &#125; else &#123; scroll.innerHTML = &quot;SCROLL@&quot;; clearInterval(interval); &#125; &#125;); var clear = document.getElementById(&#x27;clear&#x27;); clear.addEventListener(&#x27;click&#x27;, function () &#123; var pool = document.getElementById(&#x27;pool&#x27;); pool.innerHTML = &#x27;&#x27;; &#125;); blink(); &#125;; //title变换颜色class组 var colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;purple&#x27;, &#x27;pink&#x27;, &#x27;dark&#x27;, &#x27;yellow&#x27;]; //闪烁标题 var blink = function () &#123; var title = document.getElementById(&#x27;title&#x27;); var titles = title.innerHTML.split(&#x27;&#x27;); setInterval(function () &#123; var html = &#x27;&#x27;; for (var i = 0; i &lt; titles.length; i++) &#123; html += &#x27;&lt;span class=&#x27; + colors[Math.floor(Math.random() * 7)] + &#x27;&gt;&#x27; + titles[i] + &#x27;&lt;/span&gt;&#x27;; &#125; title.innerHTML = html; &#125;, 1000); &#125;; //生成结果滚动展示 function append_pull(ticket) &#123; var pool = document.getElementById(&#x27;pool&#x27;); pool.innerHTML = pool.innerHTML + &quot;&lt;span class=\\&#x27;red\\&#x27;&gt;&quot; + ticket[&#x27;red&#x27;].join(&quot; &quot;) + &quot;&lt;/span&gt;&lt;span class=\\&#x27;blue\\&#x27;&gt; (&quot; + ticket[&#x27;blue&#x27;] + &quot;)&lt;/span&gt;&lt;br /&gt;&quot;; setInterval(scroll_end(pool), 100); reset_ticket(); &#125; //重置ticket function reset_ticket() &#123; ticket = &#123;&#125;; ticket[&#x27;red&#x27;] = []; ticket[&#x27;blue&#x27;] = null; &#125; //滚动到对象底部 function scroll_end(e) &#123; e.scrollTop = e.scrollHeight; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;h1 class=&quot;title&quot; id=&quot;title&quot;&gt;LOTTY WINNER~!&lt;/h1&gt;&lt;/div&gt;&lt;br/&gt;&lt;div id=&quot;pool&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;button id=&quot;lotty&quot;&gt;LOTTY ME~!&lt;/button&gt;&lt;button id=&quot;scroll&quot;&gt;SCROLL@&lt;/button&gt;&lt;button id=&quot;clear&quot;&gt;CLEAR^&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lison.cc/categories/javascript/"}],"tags":[],"author":"Lison"},{"title":"The Gift – Gregorian","slug":"the-gift","date":"2016-08-19T10:12:07.000Z","updated":"2023-11-16T06:15:51.857Z","comments":true,"path":"the-gift/","link":"","permalink":"https://lison.cc/the-gift/","excerpt":"不知道是宗教乐还是教堂乐，不知不觉已repeat几十遍。不管了，让我的翻译水平来抹杀一下经典。","text":"不知道是宗教乐还是教堂乐，不知不觉已repeat几十遍。不管了，让我的翻译水平来抹杀一下经典。 Forgive is a word that I am learning我正在学习“原谅”这个词 If only to pass the time如果只通过过去的时间 I love you for all your weakness我爱你爱所有你喜欢的东西 I love you for all your lies我爱你爱你所有的谎言 Will you grow你是否会成长 Will you understand你是否会明白 The damage you caused in time现在你造成的伤害 The past is behind we are facing我们面对的过去已过去 A punishment for the crime为罪恶接受的惩罚 The gift you gave me你给我的礼物 Our sweet encounter我们邂逅的甜蜜 Became so fragile and flow with the night变得如此脆弱然后随夜晚流走 I will be witness我将见证I will not falter不会害怕Till we are risen again to the light直到我们再次升华 Would you forgive me你会原谅我吗My heart was broken我的心已经碎了But I will mend I will be as before但我会修补它我会跟以前一样Just give me one chance请给我一次机会To make it better让它变得更好Uhh let me be yours让我成为你的 Without you I’m weak and I’m listless没有你我是脆弱，我是颓废的Without you I find I’m blind没有你我发现我是盲目的 I watch you alone are you dreaming我看到你一个人你梦见Of happines left behind被我们扔下的幸福了吗Do you drift in your heart at night夜晚你的心在游荡吗Walk through the rooms of your mind经过你心神的房间Open the door I’ll be waiting打开门我会在等待Remember this is your life记住这就是你的人生 The gift you gave meOur sweet encounterBecame so fragile and flew with the nightI will be witnessI will not falterTill we are risen again to the light Would you forgive meMy heart was brokenBut I will mend I will be as beforeJust give me chanceTo make it betterUhh let me be yours The gift you gave meOur sweet encounterBecame so fragile and flew with the nightI will be witnessI will not falterTill we are risen again to the light Would you forgive meMy heart was brokenBut I will mend I will be as beforeJust give me on chanceTo make it betterUhh let me be yours","categories":[{"name":"reading","slug":"reading","permalink":"https://lison.cc/categories/reading/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"Android Studio 启动 Device Monitor报错：An error has occurred. See the log file...","slug":"android-studio-startup-error-device-monitor-error","date":"2016-08-04T09:46:51.000Z","updated":"2023-11-16T06:15:51.367Z","comments":true,"path":"android-studio-startup-error-device-monitor-error/","link":"","permalink":"https://lison.cc/android-studio-startup-error-device-monitor-error/","excerpt":"","text":"D:\\xxx\\sdk是我的sdk路径，于是到此目录下查看日志文件，描述如下： 1234567891011121314151617181920!ENTRY org.eclipse.osgi 4 0 2016-08-04 11:21:12.845!MESSAGE Application error!STACK 1java.io.IOException: The folder &quot;C:\\Users\\Lison%20Liou\\.android\\monitor-workspace\\.metadata&quot; is read-only. at org.eclipse.core.runtime.internal.adaptor.BasicLocation.lock(BasicLocation.java:206) at org.eclipse.core.runtime.internal.adaptor.BasicLocation.set(BasicLocation.java:164) at org.eclipse.core.runtime.internal.adaptor.BasicLocation.set(BasicLocation.java:137) at com.android.ide.eclipse.monitor.MonitorApplication.start(MonitorApplication.java:53) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) at org.eclipse.equinox.launcher.Main.run(Main.java:1438) 错误信息说目录是只读的，但目录只有C:/Users/Lison Liou/.android，后面就没有了，于是干脆给目录加上Everyone用户的Full Control权限，结果还是不行。 后来在StackOverFlow上找到答案，Android DDMS (Monitor) does not start if user profile contains a space in it，说DDMS不会启动如果用户名包含空格，我的用户名的确包含空格，但是之前也是好用的，不解。 解决方法如下：以管理员身份运行cmd（必须），输入如下： 123cd c:/usersmklink /d &quot;Lison%20Liou&quot; &quot;Lison Liou&quot; 将带空格的用户与正常用户名建立链接（软连接或者硬链接就不知道了），Lison Liou是我的计算机用户，成功后会提示： symbolic link created for Lison%20Liou &lt;&lt;===&gt;&gt; Lison Liou 搞定。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"北方女王","slug":"the-queen-of-north","date":"2016-07-19T09:39:35.000Z","updated":"2023-11-16T06:15:51.859Z","comments":true,"path":"the-queen-of-north/","link":"","permalink":"https://lison.cc/the-queen-of-north/","excerpt":"","text":"这里的秋天 开始变得寒冷孤独了忙碌的人总会有一些 善良的狗心中藏着秘密我在黑夜里 听见你的歌唱是我没有听过的歌我会用一千个夜晚陪伴着湖北的江 你和我一样 都是说谎的人拥抱城市的灰尘请你轻轻的 摘下我的面具亲吻这短暂时光我会在每个 柔软的黄昏喝一杯温柔的酒管他是与非 管他忧和愁只要你还在我的北方 这里的秋天 忽然下起雨打湿了我的头发我想我只能 给你说这些话已经是我的全部我会在每个 柔软的黄昏唱一首悲伤的歌管他时光流逝管他四季变换只要你还在我的北方后来在一个 慌张的夜晚我找见了憔悴的人我想你一定 也不能结婚岁月啊 那就这样吧 《北方女王》 – 尧十三","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"人海","slug":"people-crowd","date":"2016-06-22T09:37:13.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"people-crowd/","link":"","permalink":"https://lison.cc/people-crowd/","excerpt":"","text":"想见却还在等的人 不太多 连起来也让人心碎 碎成河 沧桑中独自向前行 说要好好活 但再忙碌也解不了 爱的渴 遇见了就不说值得 不值得 擦肩后就成全彼此 做过客 沧桑中独自向前行 说要好好活 但再忙碌也解不了 爱的渴 穿山跃海 哼你的歌 踏浪飘帆 忘记你更忘记我 从此江河只是传说 天地融化 星辰吞没 穿山跃海 哼你的歌 踏浪飘帆 忘记你更忘记我 从此江河只是传说 天地融化 星辰吞没 温柔被你唱成歌 彼岸的你影影绰绰 风中造舟 不再回头 哪怕想征服的不过是沙漠 珍惜最是难得 爱你让生命变辽阔 温柔被我唱成了歌 伴你人山人海不停留 穿山跃海 哼你的歌 踏浪飘帆 忘记你更忘记我 从此江河 只是传说 天地融化 星辰吞没 穿山跃海 哼你的歌 踏浪飘帆 忘记你更忘记我 从此江河 只是传说 天地融化 星辰吞没","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"生人","slug":"生人","permalink":"https://lison.cc/tags/%E7%94%9F%E4%BA%BA/"}],"author":"Lison"},{"title":"java byte[] 字节数组按份分割拆分成多个数组","slug":"java-split-byte","date":"2016-05-24T09:31:44.000Z","updated":"2023-11-16T06:15:51.629Z","comments":true,"path":"java-split-byte/","link":"","permalink":"https://lison.cc/java-split-byte/","excerpt":"java byte[] split 简单的字节数组分割方法，输入要拆分的数组及要按几个拆成一份即可，返回二维数组byte[]，做记录直接上代码了。","text":"java byte[] split 简单的字节数组分割方法，输入要拆分的数组及要按几个拆成一份即可，返回二维数组byte[]，做记录直接上代码了。 12345678910111213141516171819202122232425262728293031/** * 拆分byte数组 * * @param bytes * 要拆分的数组 * @param copies * 要按几个组成一份 * @return */ static byte[][] split_bytes(byte[] bytes, int copies) &#123; double split_length = Double.parseDouble(copies + &quot;&quot;); int array_length = (int) Math.ceil(bytes.length / split_length); byte[][] result = new byte[array_length][]; int from, to; for (int i = 0; i &lt; array_length; i++) &#123; from = (int) (i * split_length); to = (int) (from + split_length); if (to &gt; bytes.length) to = bytes.length; result[i] = Arrays.copyOfRange(bytes, from, to); &#125; return result; &#125; 测试代码： 1234567891011121314151617byte[] sum = &#123; 23, 4, 23, 42, 34, 2, 34, 2, 34, 2, 54, 3, 4, 56, 4, 7, 56, 7, 8, 5, 15, 2, 34, 2, 41, 2, 32, 3, 3, 3, 33 &#125;; //按四个分成一组 byte[][] bytes = split_bytes(sum, 4); System.out.println(bytes.length); System.out.print(&quot;\\r\\n\\r\\n==========================================\\r\\n&quot;); for (int i = 0; i &lt; bytes.length; i++) &#123; for (int j = 0; j &lt; bytes[i].length; j++) &#123; System.out.print(bytes[i][j] + &quot; &quot;); &#125; System.out.println(&quot;&quot;); &#125; 输出结果： 823 4 23 4234 2 34 234 2 54 34 56 4 756 7 8 515 2 34 241 2 32 33 3 33","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[],"author":"Lison"},{"title":"使用Netty进行Android与Server端通信实现文字发送接收与图片上传 – 原创","slug":"hello-android-netty","date":"2016-05-18T09:20:23.000Z","updated":"2023-11-16T06:15:51.611Z","comments":true,"path":"hello-android-netty/","link":"","permalink":"https://lison.cc/hello-android-netty/","excerpt":"Let’s use netty to achieve text send and receive and image transfer to server based on android and jdk1.7 就让我来Rap，使用netty进行安卓端发送接收文字，并且附带发送图片功能，折腾了几天的netty总算有点眉目了，做下记录。","text":"Let’s use netty to achieve text send and receive and image transfer to server based on android and jdk1.7 就让我来Rap，使用netty进行安卓端发送接收文字，并且附带发送图片功能，折腾了几天的netty总算有点眉目了，做下记录。 需求是安卓端拍照上传到服务器，服务器返回上传成功或失败bla bla bla，需求比较简单。最初使用的传统的post加multipart/form-data，一般的手机照片大小1-2M，测试没问题，但实际情况是有的用户使用3G网络，有的4G，有的WIFI还有的使用2G，网络环境稍微有点差的上传图片时间持续到十多分钟（我都不好意思说了），然后想到了使用socket，然后google到了netty，有的大神说这样的需求没必要上netty啊，其实我就是想通过这个需求学习下关于socket，关于netty，关于channel，关于byte[]，关于NIO，多学习点总是没坏处的，后面我也可以牛逼点说玩过高性能基于事件的异步网络框架了。 刚开始直接啃的netty.io的document，照葫芦画瓢抄完了TimeServer之后就满世界的google其他的netty知识，比较零散，然后入手了《Netty权威指南第二版》，啃了几章之后怎么也是TimeServer，不过对NIO一些基本组件有了一个初步的认识。 OK，入正题，我要实现一个Demo，就说是个Netty的聊天室吧（群聊，没有单聊的功能，demo味儿十足），不过客户端换成了安卓，一个服务器对多个客户端，所有数据经过服务器端，要定义中间信息交换组件。关于Google的Protobuf还有MessagePack和JBoss Marshalling这些编解码中间件都没有玩过，似乎有点看不懂，我的需求很简单，如下图（抱歉键盘党多年手已废掉，可能只有我自己看得懂）： 一共包含三个对象： Echo-Pojo，信息交换中间对象，用于Android端与Server端封装byte[]之后的序列化对象。 Let’s Chat，安卓客户端，构建EchoMessage或EchoFile对象，然后发送到channel；EchoMessage与EchoFile用于服务端判断信息对象的类别。 Echo-Server，服务端。ChannelRead时判断信息对象类型，决定是广播到所有用户还是保存文件。 对于ByteBuf对象一直没有弄很明白，所以上述也就没有使用。 来张安卓端(小米PAD)Let’s Chat的运行截图： 三星手机Let’s Chat运行截图： 服务端(Echo-Server)的运行截图： 上传的文件： 文件名格式为：Build.MANUFACTURE+UUID.randomUUID()+”.jpg”，第二张图片为12.9M，上传时间六七秒钟，应该还有优化的空间。 Echo-Pojo的代码就不截图了，直接下载查看就可以，或者也可以继续扩展，目前只是图片跟文字。 上述功能一共分为三个程序，Echo-Pojo信息交换对象使用eclipse-Mars2开发，Echo-Server使用Intellij idea开发，Let’s Chat使用Android Studio2，有点蛋疼，但好在实现了功能，中间折腾的很多，尤其公司电脑跟家里电脑jdk不一致，一个1.8，一个1.7，因为这个出了很多莫名的错误，也浪费了很多时间，中间的各种折腾各种烦躁就不记录了。 代码注释比较少，也有很多废弃的没有删掉，只是实现了功能可以运行，没有做完全整理，有问题可以直接回复或者@EMAIL ME 借鉴刘源的NettyFileTransfer，只是我把客户端修改成了Android，然后Netty版本我用的是4.0.36Final，感谢大神。 剩下的就是把功能揉进项目里了，Keep Fighting ! 项目开源地址：https://github.com/LisonLiou/netty-learning.git","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"netty","slug":"netty","permalink":"https://lison.cc/tags/netty/"}],"author":"Lison"},{"title":"sqlserver生成字符串获取ASCII码","slug":"sqlserver-ascii","date":"2016-04-26T09:18:47.000Z","updated":"2023-11-16T06:15:51.855Z","comments":true,"path":"sqlserver-ascii/","link":"","permalink":"https://lison.cc/sqlserver-ascii/","excerpt":"给APP上加个彩蛋，又不想那么明目张胆，用char吧，得生成ASCII码。 鱼饰就有了下面的代码，循环字符串长度并且substring，有点搓，还能用吧。","text":"给APP上加个彩蛋，又不想那么明目张胆，用char吧，得生成ASCII码。 鱼饰就有了下面的代码，循环字符串长度并且substring，有点搓，还能用吧。 123456789101112declare @msg varchar(255)set @msg=&#x27;Hey man, What is the fuck r u doing ?&#x27;declare @i intset @i=0declare @result varchar(255)while @i&lt;=len(@msg)begin print &#x27;,&#x27; + str(ASCII(substring(@msg,@i,1))) set @i=@i+1end","categories":[{"name":"t-sql","slug":"t-sql","permalink":"https://lison.cc/categories/t-sql/"}],"tags":[],"author":"Lison"},{"title":"远方 让我大闹一场 悄然离去的故乡","slug":"yanchi-keconghechulai","date":"2016-04-22T09:15:29.000Z","updated":"2023-11-16T06:15:51.876Z","comments":true,"path":"yanchi-keconghechulai/","link":"","permalink":"https://lison.cc/yanchi-keconghechulai/","excerpt":"客从何处来 - 燕池","text":"客从何处来 - 燕池 风里藏着秘密 遇山散了花里喃着耳语 迎雾没了怀里拥着温度 沾露凉了手里攥着船票 入水化了散落的繁星谱给无眠旅人的安眠曲松软的土地呼吸青草芳香悦然前行故乡的过客 远方的归人无意间我说起的故事你又是否相信远方 让我大闹一场悄然离去的故乡故乡 让我收藏荣耀戏谑人生的远方不辞而别的朋友一见如故的路人轻声问起 客往何处去风里藏着秘密 遇山散了花里喃着耳语 迎雾没了怀里拥着温度 沾露凉了手里攥着船票 入水化了我若问自己 客从何处来被湮灭的理想被阐释的爱情我若问自己 客从何处来被所相信的相信被所否定的否定月应有圆缺 日不惧升落被所崇拜的崇拜被所怀疑的怀疑客从何处来 客往何处去转身即是远方前路亦是故乡故乡远方 让我大闹一场悄然离去的故乡故乡 让我收藏荣耀戏谑人生的远方不辞而别的朋友一见如故的路人轻声问起 客往何处去远方 让我大闹一场悄然离去的故乡故乡 让我收藏荣耀戏谑人生的远方不辞而别的朋友一见如故的路人轻声问起 客往何处去轻声问起客往何处去","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"},{"name":"旅行","slug":"旅行","permalink":"https://lison.cc/tags/%E6%97%85%E8%A1%8C/"}],"author":"Lison"},{"title":"“是谁人？” “是翠翠！” “翠翠又是谁？” “是碧溪岨撑渡船的孙女。”","slug":"shencongwen-biancheng","date":"2016-04-01T04:27:00.000Z","updated":"2023-11-16T06:15:51.681Z","comments":true,"path":"shencongwen-biancheng/","link":"","permalink":"https://lison.cc/shencongwen-biancheng/","excerpt":"-摘《边城》沈从文节选 – 岳云见翠翠","text":"-摘《边城》沈从文节选 – 岳云见翠翠 两个水手还在谈话，潭中那只白鸭慢慢地向翠翠所在的码头边游过来，翠翠想：“再过来我就捉住你！” 于是静静地等着，但那鸭子将近岸边三丈远时，却有个人笑着，喊那船上水手。原来水中还有个人，那人已把鸭子捉到手，却慢慢的“踹水”游进岸边的。船上人听到水面的喊声，在隐约里也喊道：“二老，二老，你真能干！你今天得了五只吧？” 那水上人说：“这家伙狡猾的很，现在可归我了。” “你这时捉鸭子，将来捉女人，一定有同样的本领。” 水上那一个不再说什么，手脚并用地拍着水傍了码头。湿淋淋地爬上岸时，翠翠身旁的黄狗，仿佛警告水中人似的，汪汪地叫了几声，那人方注意到翠翠。码头上已无别的人，那人问：“是谁人？”“是翠翠！”“翠翠又是谁？”“是碧溪岨撑渡船的孙女。”“你在这儿做什么？”“我等我爷爷。我等他来。”“等他来他可不会来，你爷爷一定到城里军营里喝了酒，醉倒后被人抬回去了！”“他不会这样子。他答应来找我，他就一定会来的。”“这里等也不成，到我家里去，到那边点了灯的楼上去，等爷爷来找你好不好？”。 翠翠误会了邀她进屋里去的那个人的好意，心里记着水手说的妇人丑事，她以为那男子就是要她上有女人唱歌的楼上去，本来从不骂人，这时正因等候祖父太久了，心中焦急的很，听人要她上去，以为欺侮了她，就轻轻的说：“悖时砍脑壳的！”话虽轻轻的，那男的却听得出，且从声音上听得出翠翠的年纪，便带笑说：“怎么，你骂人！你不愿意上去，要待在这儿，回头水里大鱼来咬了你，可不要叫喊！”翠翠说：“鱼咬了我也不关你的事。”那只黄狗好像明白翠翠被人欺侮了，又汪汪地吠起来。那男子把手中白鸭举起，向黄狗吓了一下，便走上河街去了。黄狗为了自己被欺侮还想追过去，翠翠便喊：“狗，狗，你叫人也看人叫！” 翠翠意思仿佛只在告给狗 “那轻薄男子还不值得叫”，但男子听去的却是另外一种好意，男的以为是她要狗莫向好人乱叫，放肆地笑着，不见了。 又过了一阵，有人从河街拿了一个废缆做成的火炬，喊叫着翠翠的名字来找寻她，到身边时翠翠却不认识那个人。那人说老船夫回到家中，不能来接她，故搭了过渡人口信来告翠翠，要她即刻就回去。翠翠听说是祖父派来的，就同那人一起回家，让打火把的在前引路，黄狗时前时后，一同沿了城墙向渡口走去。翠翠一面走一面问那拿火把的人，是谁告他就知道她在河边。那人说是二老告他的，他是二老家家里的伙计，送翠翠回家后还得回转河街。翠翠说：“二老他怎么知道我在河边？”那人便笑着说：“他从河里捉鸭子回来，在码头上见你，他说好意请你上家里坐坐，等候你爷爷，你还骂过他！你那只黄狗不识吕洞宾，只是叫！”翠翠带了点儿惊讶轻轻地问：“二老是谁？”那人也带了点儿惊讶的说：“二老你还不知道？就是我们河街上的傩送二老！就是岳云！他要我送你回去！” 傩送二老在茶峒地方不是一个生疏的名字。翠翠想起自己先前骂人那句话，心里又吃惊又害羞，再也不说什么，默默地随了那火把去。翻过了小山岨，望得见对溪家中火光时，那一方面也看见了翠翠方面的火把，老船夫即刻把船拉过来，一面拉船一面哑声儿问：“翠翠，翠翠，是不是你？” 翠翠不理会祖父，口中却轻轻地说：“不是翠翠，不是翠翠，翠翠早被大河中鲤鱼吃去了。“ 翠翠上了船，二老派来的人，打着火把走了，祖父牵着船问：“翠翠，你怎么不答应我，生我的气了吗？”翠翠站在船头还是不作声。翠翠对祖父那一点儿埋怨，等到把船拉过了溪，一到了家中，看明白了醉倒的另一个老人后，就完事了。但另一件事，属于自己不关祖父的，却使翠翠沉默了一个夜晚。 -摘《边城》沈从文节选 – 岳云见翠翠","categories":[{"name":"Literature Library","slug":"Literature-Library","permalink":"https://lison.cc/categories/Literature-Library/"}],"tags":[{"name":"读沈从文《边城》","slug":"读沈从文《边城》","permalink":"https://lison.cc/tags/%E8%AF%BB%E6%B2%88%E4%BB%8E%E6%96%87%E3%80%8A%E8%BE%B9%E5%9F%8E%E3%80%8B/"}],"author":"Lison"},{"title":"ITU – Radio Band","slug":"radio-itu","date":"2016-04-01T04:24:13.000Z","updated":"2023-11-16T06:15:51.656Z","comments":true,"path":"radio-itu/","link":"","permalink":"https://lison.cc/radio-itu/","excerpt":"123456789101112131415161718ITU Radio Bands(国际电信联盟) -- From wiki pedia https://en.wikipedia.org/wiki/Extremely_low_frequencyName Frequency F.Unit(hertz) Wave Length Full NameELF 3-30 Hz 100km~10km Extremely Low FrequencySLF 30-300 Hz 10km~1km Super Low FrequencyULF 300-3000 Hz 1km~100m Ultra Low FrequencyVLF 3000-30000 Hz 100m~10 Very Low FrequencyLF 30-300 MHz 10~1km Low FrequencyMF 300~3000 MHz 1000~100m Medium FrequencyHF 3000~30000 MHz High Frequency VHF 30~300 GHz Ultra High FrequencyUHF 300~3000 GHz Super High FrequencySHF 3000~300000 GHz Very High FrequencyEHF 300000~3000000 GHzTHF 3000000~30000000 GHz Terahertz High Frequency https://en.wikipedia.org/wiki/Radio_spectrum#ITU","text":"123456789101112131415161718ITU Radio Bands(国际电信联盟) -- From wiki pedia https://en.wikipedia.org/wiki/Extremely_low_frequencyName Frequency F.Unit(hertz) Wave Length Full NameELF 3-30 Hz 100km~10km Extremely Low FrequencySLF 30-300 Hz 10km~1km Super Low FrequencyULF 300-3000 Hz 1km~100m Ultra Low FrequencyVLF 3000-30000 Hz 100m~10 Very Low FrequencyLF 30-300 MHz 10~1km Low FrequencyMF 300~3000 MHz 1000~100m Medium FrequencyHF 3000~30000 MHz High Frequency VHF 30~300 GHz Ultra High FrequencyUHF 300~3000 GHz Super High FrequencySHF 3000~300000 GHz Very High FrequencyEHF 300000~3000000 GHzTHF 3000000~30000000 GHz Terahertz High Frequency https://en.wikipedia.org/wiki/Radio_spectrum#ITU","categories":[{"name":"radio","slug":"radio","permalink":"https://lison.cc/categories/radio/"}],"tags":[],"author":"Lison"},{"title":"无线电术语、基本概念学习整理","slug":"radio-learning","date":"2016-03-28T04:22:00.000Z","updated":"2023-11-16T06:15:51.658Z","comments":true,"path":"radio-learning/","link":"","permalink":"https://lison.cc/radio-learning/","excerpt":"无线电，是一个音译过来的中文缩写。英文全称应该叫做Radio Wave，无线电波，还有Radio Frequency（无线频率）；Air Wave等叫法。 这篇文章将持续更新，以记录我在认识无线电过程中的知识学习和整理。","text":"无线电，是一个音译过来的中文缩写。英文全称应该叫做Radio Wave，无线电波，还有Radio Frequency（无线频率）；Air Wave等叫法。 这篇文章将持续更新，以记录我在认识无线电过程中的知识学习和整理。 术语解释：CW Continuous Wave 字面意思是连续波，在发射领域内，通常简称CW方式，译为等幅（无线电）波发射机。一般利用摩尔斯电码发送信息——它通过电键控制发信机产生短信号”.”（点）和长信号”–”（划），并利用其不同组合表示不同的字符，从而组成单词和句子。与其他无线电通信方式相比，CW优点是所需设备简单、占用频带窄、发射效率高、在同等条件下通信距离更远。摘自矿石收音机在无线电术语，CW是什么意思呢？ 无线电频段（摘自百度百科-无线电频段）段，是个范围词，类似10-90这种，英文原意为Band（波段），Frequency Band，还有直接说MHZ，GHZ的。频段分类（各频段是干什么的）ELF极低频 330HzSLF超低频30300HzULF 特低频3003000HzVLF甚低频330kHzLF低频 30300kHz 长波MF中频3003000kHz100m1000m中波 AM广播HF高频330MHz10100m 短波 短波广播VHF 甚高频 30300MHz110m 米波 FM广播UHF 特高频 3003000MHz 0.11m 分米波SHF超高频330GHz 1cm10cm厘米波EHF极高频30300GHz1mm1cm毫米波国际无线电管理会议规定的无线电频段代号HF1030MHzVHF 30100MHzA100250MHzB250500MHzC5001000 MHzD12 GHzE23 GHzF34 GHzG46 GHzH68 GHzI810 GHzJ1020 GHzK2040 GHzL4060 GHzM60100 GHz甚低频VLF 3-30KHz 超长波1KKm-100Km 空间波为主海岸潜艇通信；远距离通信;超远距离导航低频 LF 30-300KHz 长波10Km-1Km 地波为主越洋通信；中距离通信;地下岩层通信；远距离导航中频 MF 0.3-3MHz 中波1Km-100m 地波与天波船用通信;业余无线电通信；移动通信;中距离导航高频 HF 3-30MHz 短波100m-10m 天波与地波远距离短波通信；国际定点通信甚高频 VHF 30-300MHz 米波10m-1m 空间波电离层散射（30-60MHz）;流星余迹通信；人造电离层通信（30-144MHz）;对空间飞行体通信；移动通信超高频 UHF 0.3-3GHz 分米波1m-0.1m 空间波小容量微波中继通信;（352-420MHz）；对流层散射通信（700-10000MHz）;中容量微波通信（1700-2400MHz）特高频 SHF 3-30GHz 厘米波10cm-1cm 空间波大容量微波中继通信（3600-4200MHz）；大容量微波中继通信（5850-8500MHz）;数字通信；卫星通信;国际海事卫星通信（1500-1600MHz）极高频 EHF 30-300GHz 毫米波10mm-1mm 空间波再入大气层时的通信；波导通信 ISM频段ISM频段即工业，科学和医用频段，无需许可证，只需要遵守一定的发射功率(一般低于1W)，并且不要对其它频段造成干扰即可。最初是由美国联邦通信委员会(FCC)分配的不必许可证的无线电频段（功率不能超过1W）。在美国分为为工业（902-928MHz），科学研究（2.42-2.4835GHz）和医疗（5.725-5.850GHz）三个频段。而在欧洲900MHz的频段则有部份用于GSM通信，用于ISM的低频段为868MHZ和433MHz。2.4GHz为各国共同的ISM频段。因此无线局域网，蓝牙，ZigBee等无线网络，均可工作在2.4GHz频段上。","categories":[{"name":"radio","slug":"radio","permalink":"https://lison.cc/categories/radio/"}],"tags":[{"name":"无线电频率","slug":"无线电频率","permalink":"https://lison.cc/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E9%A2%91%E7%8E%87/"}],"author":"Lison"},{"title":"Radio Monitoring record log","slug":"radio-monitoring-record-log","date":"2016-03-28T04:15:28.000Z","updated":"2023-11-16T06:15:51.660Z","comments":true,"path":"radio-monitoring-record-log/","link":"","permalink":"https://lison.cc/radio-monitoring-record-log/","excerpt":"","text":"0 AM silent 153.09AM music Russia Radio 160.00AM Russia Radio Quite Clearly 183.02 AM 198.00 AM English Radio 234.00 AM 407.62 CW Morse -… — – BOT log time 2016-03-27 19:39 ~ 20:11 Band: 80m Frequency: 3629.97kHz CW Morse -… –… – B7T","categories":[{"name":"radio","slug":"radio","permalink":"https://lison.cc/categories/radio/"}],"tags":[],"author":"Lison"},{"title":"作为鞭策Shame转载《面试感悟 一名3年工作经验的程序员应该具备的技能》","slug":"android-career","date":"2016-03-18T04:10:05.000Z","updated":"2023-11-16T06:15:51.354Z","comments":true,"path":"android-career/","link":"","permalink":"https://lison.cc/android-career/","excerpt":"前言因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个程序员群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。","text":"前言因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个程序员群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。 简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于： 1、阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试 2、另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队 至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。 关于程序员的几个阶段每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。 LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）： 第一阶段—-三年 我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段 第二阶段—-五年 五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物 第三阶段—-十年 十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你 第一部分总结一下，我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题： 1、我到底适不适合当一名程序员？ 2、我到底应不应该一辈子以程序员为职业？ 3、我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？ 最终，明确自己的职业规划，对自己的规划负责并为之努力。 关于项目经验LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。 关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好： 1介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？ 我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点： 1、明确你的项目到底是做什么的，有哪些功能 2、明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用 3、明确你的模块在整个项目中所处的位置及作用 4、明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术 在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。 补充一点，在面试中聊你的项目的时候，有一个问题90%是绕不过的：谈一下你在项目中解决过的比较复杂的问题。这需要在工作中不断去发现和探索，不需要多，在你自己目前的项目中只要你找到一两个能说的问题就行。一个小技巧是，即使问题不是你解决的而是别人解决的，但是你把这个问题弄懂、搞透了，在面试的时候你一样可以把这个问题当作是你自己解决的来说—-毕竟，谁来管这个问题当时到底是不是你解决的呢？ 关于专业技能写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。 1、基本语法这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。 最深入的一次，LZ记得面试官直接问到了我volatile关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度**优先、广度次之**为标准的，切记。 2、集合非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。 集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向： （1）ConcurrentHashMap的锁分段技术 （2）ConcurrentHashMap的读是否要加锁，为什么 （3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器 3、设计模式本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。 当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向： （1）你的项目中用到了哪些设计模式，如何使用 （2）知道常用设计模式的优缺点 （3）能画出常用设计模式的UML图 4、多线程这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思： 1假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？ 聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。 另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。 最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看40个Java多线程问题总结。 5、IO再次补充IO的内容，之前忘了写了。 IO分为File IO和Socket IO，File IO基本上是不会问的，问也问不出什么来，平时会用就好了，另外记得File IO都是阻塞IO。 Socket IO是比较重要的一块，要搞懂的是阻塞/非阻塞的区别、同步/异步的区别，借此理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型，Socket IO如何和这四种模型相关联。这是基本一些的，深入一些的话，就会问NIO的原理、NIO属于哪种IO模型、NIO的三大组成等等，这有些难，当时我也是研究了很久才搞懂NIO。提一句，NIO并不是严格意义上的非阻塞IO而应该属于多路复用IO，面试回答的时候要注意这个细节，讲到NIO会阻塞在Selector的select方法上会增加面试官对你的好感。 如果用过Netty，可能会问一些Netty的东西，毕竟这个框架基本属于当前最好的NIO框架了（Mina其实也不错，不过总体来说还是比不上Netty的），大多数互联网公司也都在用Netty。 6、JDK源码要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码： （1）List、Map、Set实现类的源代码 （2）ReentrantLock、AQS的源代码 （3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的 （4）线程池的实现原理 （5）Object类中的方法以及每个方法的作用 这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。 7、框架老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。 如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~ 8、数据库数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。 不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。 9、数据结构和算法分析数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我： 1你知道索引使用的是哪种数据结构实现吗？ LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？ 至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。 10、Java虚拟机出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。 言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容： （1）Java虚拟机的内存布局 （2）GC算法及几种垃圾收集器 （3）类加载机制，也就是双亲委派模型 （4）Java内存模型 （5）happens-before规则 （6）volatile关键字使用规则 也许面试无用，但在走向大牛的路上，不可不会。 11、Web方面的一些问题Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是： 1谈谈分布式Session的几种实现方式 常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是： 1讲一下Session和Cookie的区别和联系以及Session的实现原理 这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。 噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是MemCache超详细解读和对一致性Hash算法，Java代码实现的深入研究，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。 最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。 关于HR面试如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。 所以，这轮的面试也必须重视起来，HR面试主要问的是几点： 1、简历中写的过去工作经历的离职原因 2、当前公司薪资待遇 3、期望能到怎样的一家公司 4、个人未来的发展方向 我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。 HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。 关于面试心态这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求： 1、不紧不慢，平心静气 2、条理清晰 表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？ 除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。 因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。 另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。 关于Java网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。 这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。 1、易学部分Java易学我认为有两部分的原因： （1）很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面。 （2）Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000行+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势。 2、难精部分接着咱们聊聊难精的部分。 Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？ 凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。 Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。 结语文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。 在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论： 就以这段话自勉、共勉吧。越努力、越幸运，如果你不是官二代、富二代、红二代，那么请记住：勤奋才是改变你命运的唯一捷径。 ================================================================================== 我不能保证写的每个地方都是对的，但是至少能保证不复制、不黏贴，保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后，希望都能看到自己对于技术、对于生活的态度。 我相信乔布斯说的，只有那些疯狂到认为自己可以改变世界的人才能真正地改变世界。面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。 其实我想说的是，我只是一个程序员，这就是我现在纯粹人生的全部。 文章转载自博客园“五月的仓颉”： 《面试感悟—-一名3年工作经验的程序员应该具备的技能》 http://www.cnblogs.com/xrq730/p/5260294.html 后记作为能抄会抄的所谓“程序员”，看到这样的文章首先是愧，感觉没脸见人，同样是码农，差距会如此之大，但也不必惊讶，因为我没有静下心，潜行修行。所谓程序员是吃青春饭有太多人说过，现在想想，应该是出自外行人的口。我是半路出家的java程序猿，会一点点安卓，java web还没有开始学习。抱着拥抱开源的态度，学习大牛们的思想，继续崇拜着Linus Torvalds，继续蛮横的说： TALK IS CHEEP, SHOW ME THE CODE.","categories":[{"name":"人生","slug":"人生","permalink":"https://lison.cc/categories/%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"职业规划","slug":"职业规划","permalink":"https://lison.cc/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"}],"author":"Lison"},{"title":"Android Camera： start preview failed; API10. Android 2.3 startPreview失败解决方法","slug":"android-camera-start-preview-failed","date":"2016-03-11T04:06:10.000Z","updated":"2023-11-16T06:15:51.353Z","comments":true,"path":"android-camera-start-preview-failed/","link":"","permalink":"https://lison.cc/android-camera-start-preview-failed/","excerpt":"代码中使用了开源项目(OSChina 客户端2.0)的源码，zxing做二维码扫描识别。搬过来之后在Android 2.3机器运行报错：Unexpected error initializing camera java.lang.RuntimeException: startPreview failed","text":"代码中使用了开源项目(OSChina 客户端2.0)的源码，zxing做二维码扫描识别。搬过来之后在Android 2.3机器运行报错：Unexpected error initializing camera java.lang.RuntimeException: startPreview failed startPreview失败报错详细如下： 123456789101112131415161718192021222324252627282930313233343536373839Unexpected error initializing camera java.lang.RuntimeException: startPreview failed at android.hardware.Camera.startPreview(Native Method) at com.dtr.zxing.camera.CameraManager.startPreview(CameraManager.java:149) at com.dtr.zxing.utils.CaptureActivityHandler.&lt;init&gt;(CaptureActivityHandler.java:57) at com.dtr.zxing.activity.CaptureActivity.initCamera(CaptureActivity.java:285) at com.dtr.zxing.activity.CaptureActivity.surfaceCreated(CaptureActivity.java:179) at android.view.SurfaceView.updateWindow(SurfaceView.java:574) at android.view.SurfaceView.updateWindow(SurfaceView.java:411) at android.view.SurfaceView.dispatchDraw(SurfaceView.java:355) at android.view.ViewGroup.drawChild(ViewGroup.java:1644) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:1373) at android.view.View.draw(View.java:6883) at android.view.ViewGroup.drawChild(ViewGroup.java:1646) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:1373) at android.view.View.draw(View.java:6883) at android.widget.FrameLayout.draw(FrameLayout.java:357) at android.view.ViewGroup.drawChild(ViewGroup.java:1646) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:1373) at android.view.View.draw(View.java:6883) at android.support.v7.widget.ActionBarOverlayLayout.draw(ActionBarOverlayLayout.java:442) at android.view.ViewGroup.drawChild(ViewGroup.java:1646) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:1373) at android.view.ViewGroup.drawChild(ViewGroup.java:1644) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:1373) at android.view.View.draw(View.java:6883) at android.widget.FrameLayout.draw(FrameLayout.java:357) at com.android.internal.policy.impl.PhoneWindow$DecorView.draw(PhoneWindow.java:1921) at android.view.ViewRoot.draw(ViewRoot.java:1526) at android.view.ViewRoot.performTraversals(ViewRoot.java:1262) at android.view.ViewRoot.handleMessage(ViewRoot.java:1863) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:130) at android.app.ActivityThread.main(ActivityThread.java:3687) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:507) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:878) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:636) at dalvik.system.NativeStart.main(Native Method) 找到了一些文章，有的说Camera的open与startPreview不能多次调用，需要设置标记，查看OSChina的源码之后发现有标记，不是这个。 后来找到说低版本的SDK需要setType一下，设置成：SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS，尝试后依然没有解决问题。 最后是借鉴了这篇文章（不知道是不是原始链接）解决了问题，holderView要放在holder的allCallback前面，完整如下： 1234567891011121314151617181920212223242526272829303132@Override protected void onResume() &#123; super.onResume(); // CameraManager must be initialized here, not in onCreate(). This is // necessary because we don&#x27;t // want to open the camera driver and measure the screen size if we&#x27;re // going to show the help on // first launch. That led to bugs where the scanning rectangle was the // wrong size and partially // off screen. cameraManager = new CameraManager(getApplication()); handler = null; if (isHasSurface) &#123; // The activity was paused but not stopped, so the surface still // exists. Therefore // surfaceCreated() won&#x27;t be called, so init the camera here. initCamera(scanPreview.getHolder()); &#125; else &#123; // Install the callback and wait for surfaceCreated() to init the // camera. if (Build.VERSION.SDK_INT &lt; 11) scanPreview.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); scanPreview.getHolder().addCallback(this); &#125; inactivityTimer.onResume(); &#125; 就是这两句： if(Build.VERSION.SDK_INT&lt;11)**scanPreview.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);** scanPreview.getHolder().addCallback(this); OSChina客户端的2.0支持的最低版本是15，已经不再支持API10，不能PullRequest一下了。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"android camera","slug":"android-camera","permalink":"https://lison.cc/tags/android-camera/"}],"author":"Lison"},{"title":"java中的观察者/订阅者模式实践 - Observable、Observer","slug":"java-observer-observable","date":"2016-01-28T04:02:08.000Z","updated":"2023-11-16T06:15:51.628Z","comments":true,"path":"java-observer-observable/","link":"","permalink":"https://lison.cc/java-observer-observable/","excerpt":"这方面的资料搜索一下很多，但是自己一直没有实践过。今天用到了，做下记录。名词解释： 观察者，Observer被观察者，Observable 举例，过年放烟花，烟花放在中间一直燃烧，就是被观察者；而大家在周围看，就是观察者（哇~~~猴赛雷）直接上代码：","text":"这方面的资料搜索一下很多，但是自己一直没有实践过。今天用到了，做下记录。名词解释： 观察者，Observer被观察者，Observable 举例，过年放烟花，烟花放在中间一直燃烧，就是被观察者；而大家在周围看，就是观察者（哇~~~猴赛雷）直接上代码： 1234567891011121314151617181920212223242526272829303132333435/** * 作为被观察者也作为被订阅源 * * @author Administrator * */ static class Fireworks extends Observable &#123; void setFire() &#123; System.out.println(&quot;I am fired, check on that&quot;); //事件變化,通知所有觀察者 super.setChanged(); this.notifyObservers(&quot;qiu...qiu...qiu...&quot;); &#125; &#125; /** * 觀察者 * * @author Administrator * */ static class People implements Observer &#123; String name = &quot;&quot;; public People(String name) &#123; this.name = name; &#125; public void update(Observable o, Object arg) &#123; System.out.println(name + &quot; watched: &quot; + arg); &#125; &#125; 测试一下： 123456789Fireworks f = new Fireworks(); // 注冊觀察者 f.addObserver(new People(&quot;XiaoMing&quot;)); f.addObserver(new People(&quot;XiaoQiang&quot;)); f.addObserver(new People(&quot;XiaoHong&quot;)); f.addObserver(new People(&quot;XiaoLi&quot;)); f.setFire(); 输出： I am fired, check on thatXiaoLi watched: qiu…qiu…qiu…XiaoHong watched: qiu…qiu…qiu…XiaoQiang watched: qiu…qiu…qiu…XiaoMing watched: qiu…qiu…qiu… 之前使用的是直接new一个Observable对象，导致无法调用父类的setChanged方法。 见-&gt;java 订阅者模式不执行update","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lison.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Lison"},{"title":"热河 李志","slug":"rehe-lizhi","date":"2016-01-18T03:59:30.000Z","updated":"2023-11-16T06:15:51.675Z","comments":true,"path":"rehe-lizhi/","link":"","permalink":"https://lison.cc/rehe-lizhi/","excerpt":"","text":"热河路就像 八十年代的金坛县梧桐垃圾灰尘和各式各样的杂货店人们总是早早的离开拉上卷帘门在天黑前穿上毛衣点一根烟热河路有一家开了好多年的理发店不管剪什么样的发型你只要付五块钱老板和她的妹妹坐在椅子上对着镜子一言不发他们的老家在身后在岸边在安徽全椒县没有人在热河路谈恋爱总有人在天亮时伤感如果年轻时你没来过热河路那你现在的生活是不是很幸福纪念碑旁有一家破旧的电影院往北走五百米就是南京火车西站每天都有外地人在直线和曲线之间迷路气喘嘘嘘眼泪模糊奔跑跌倒奔跑秋林龙虾换了新的地方32路还是穿过挹江门高架桥拆了修了新的隧道走来走去走不出我的盐仓桥来到城市已经八百九十六天热河路一直是相同的容颜偶尔有干净的潘西路过她不会说你好再见没有人在热河路谈恋爱总有人在天黑时伤感如果年轻时你来过热河路那你现在是不是已经被他们淹没没有新的衣服能让你爱恋总有一种天气让我怀念醒来或者吃饱又是一年相遇然后分别就在一天热河词曲：李志演唱：李志","categories":[{"name":"记忆","slug":"记忆","permalink":"https://lison.cc/categories/%E8%AE%B0%E5%BF%86/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"}],"author":"Lison"},{"title":"Android控件之带清空按钮(功能)的AutoCompleteTextView自动提示","slug":"android-autocompletetextview-with-clear-button","date":"2016-01-13T03:56:57.000Z","updated":"2023-11-16T06:15:51.352Z","comments":true,"path":"android-autocompletetextview-with-clear-button/","link":"","permalink":"https://lison.cc/android-autocompletetextview-with-clear-button/","excerpt":"功能折腾完了记录一下。带删除按钮的AutoCompleteTextView，普通的自动提示控件用起来比较简单，准备好数组给控件setAdapter一下行了，这里要说的是提取sqlite中的数据绑定并且加上清空按钮，先来张图片。","text":"功能折腾完了记录一下。带删除按钮的AutoCompleteTextView，普通的自动提示控件用起来比较简单，准备好数组给控件setAdapter一下行了，这里要说的是提取sqlite中的数据绑定并且加上清空按钮，先来张图片。 最初没有用过AutoCompleteTextView的时候，就直接百度了下，想必都会得到这样一段代码： 123456789101112131415public class MainActivity extends Activity &#123;private AutoCompleteTextView autotext;private ArrayAdapter&lt;String&gt; arrayAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.test); autotext =(AutoCompleteTextView) findViewById(R.id.autotext); String [] arr=&#123;&quot;aa&quot;,&quot;aab&quot;,&quot;aac&quot;&#125;; arrayAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1,arr); autotext.setAdapter(arrayAdapter); &#125;&#125; 上面的代码简单，但是不大实用，比如我的需求就是，要有清空按钮。然后继续百度，又找到了这篇文章（继承AutoCompleteTextView自定义控件ClearableAutoCompleteTextView，自定义adapter方式实现） 1https://gist.github.com/mderazon/6700044 然后就闭着眼抄了一下，修改一点，满足了需求。其实碰上问题就百度这种方式是很不对的，所有的控件使用方法在Android Develop Docs中都有介绍：/sdk/docs/reference/android/widget/AutoCompleteTextView.html。哎，我们都是应用程序猿，但我们又连API都不看。。。或许你觉得密密麻麻的英文看着头疼？或许你又翻不了墙？或许吧，还是那句老话，成功的人找方法，而失败的人嘛，对吧。 今天想给AutoCompleteTextView加个图标，就是上图左侧那个放大镜按钮，于是找好素材，设置drawableLeft，运行，发现没有效果。于是查看自定义控件的源码（就是上面使用自定义adapter的那个链接里提到的），发现是在init方法中绑定了setOnTouchListener, 然后onTouchListener中又通过MotionEvent判断触摸的区域，而触摸的对象使用的是setCompoundDrawablesWithIntrinsicBounds，这不就是drawableLeft、drawableRight所对应的方法嘛，果断删除自定义控件ClearableAutoCompleteTextView，使用原生AutoCompleteTextView，加入drawableLeft放大镜按钮，drawableRight使用删除小图标，然后对控件setOnTouchListener，代码如下： 123456789101112131415161718actvCityLetter.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (actvCityLetter.getCompoundDrawables()[2] == null) return false; if (event.getAction() != MotionEvent.ACTION_UP) return false; //触摸点位置判断 if (event.getX() &gt; actvCityLetter.getWidth() - actvCityLetter.getPaddingRight() - getResources().getDimension(R.dimen.space_4_touch)) &#123; actvCityLetter.setText(&quot;&quot;); &#125; return false; &#125; &#125;); 一下子就腰不疼腿不酸了。注意“触摸点位置判断”那行，意思是当前触摸点如果大于AutoCompleteTextView的宽度减去paddingRight的值再剪掉一个固定值（R.dimen.space_4_touch,我这里是10dip），就算触摸到了删除小图标；固定值是多少根据情况来，值越大可以触摸的空间越大，相反越小，用户可能就点击不到那块区域（删除小图标的区域）从而激发不了事件，这也算是优化用户体验的一种手段吧。 所以，按照上述代码，也可以举一反三为放大镜按钮加上事件，或者为删除小图标设置隐藏/显示条件，比如文本框没有内容时删除图标隐藏，有内容则显示等。 文章内容中的代码没有单独整理摘除，部分源码文件","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"一个短片から腰","slug":"yao-yigeduanpian","date":"2016-01-13T03:55:12.000Z","updated":"2023-11-16T06:15:51.877Z","comments":true,"path":"yao-yigeduanpian/","link":"","permalink":"https://lison.cc/yao-yigeduanpian/","excerpt":"","text":"旋轉 跳躍喔他感到每條路都在頭痛新鮮的帕特里克满脑子都是開拓的自慰器那些男人愛的男人愛市政市政愛市民 市民愛流連 旋轉 跳躍喔他感到飛鳥們也在頭痛冒牌的帕特里克满脑子都是穩妥的獨角戲那些男孩愛的男人愛機器機器愛法律 法律是你 深夜裏辛蒂蕾拉们倒下的地方 促成整片血紅的高樓在搞与不搞之間泛起淡淡的哀伤 他的來頭已經腐朽別擔心沒有哪一首歌能夠 把这个現實唱到地狱去當你還能享有這種靜默我的老爺 這爛攤就不會收場 旋轉 跳躍吧他感到連晚風也在頭痛狗娘養的帕特里克满脑子關於體態的滑翔機他說過那些女人愛的男人愛蘿莉蘿莉愛包包 包包愛货币 他在高级堡垒的方陣里走出 带来大會的消息在幼犬和地皮商的征程里 他是發達的肯定句等他和他們 他們和所有人之間都搞不來信任的時候只有冬和她的姨媽从沒有熄灯的窗口 無聲眺望 這夜派對 就要散場 幽暗的最高頻道還在為全城遮盖下一百年的昂貴谜底他倚靠在令人害羞的禮品堆裡冉冉睡去","categories":[{"name":"生人","slug":"生人","permalink":"https://lison.cc/categories/%E7%94%9F%E4%BA%BA/"}],"tags":[],"author":"Lison"},{"title":"Private： 分享一个代理软件hide me VPN，小白专用","slug":"hide-me-vpn","date":"2015-12-24T03:50:14.000Z","updated":"2023-11-16T06:15:51.613Z","comments":true,"path":"hide-me-vpn/","link":"","permalink":"https://lison.cc/hide-me-vpn/","excerpt":"如何科学的上网已经成为至少像我这种CV（复制黏贴）级程序猿（自嘲一下）必须要面临的问题，因为android.google.com上不了，sdk更新不了，有时候github也上不去；很多一手的外国人资料看不到，每日坐井观天，接触不到新鲜东西，每天看新闻联播。。。bla bla bla","text":"如何科学的上网已经成为至少像我这种CV（复制黏贴）级程序猿（自嘲一下）必须要面临的问题，因为android.google.com上不了，sdk更新不了，有时候github也上不去；很多一手的外国人资料看不到，每日坐井观天，接触不到新鲜东西，每天看新闻联播。。。bla bla bla 之前一直使用freegate，这个好像是政治类的工具，怎么讲，比较偏激吧（但是使用超级简单），用起来怕怕的，所以一直想找一个简简单单的我用就用，但你别想给我灌输什么东西的app。 今天依然使用freegate上google，查找了一下匿名代理软件，找到了http://hide.me（不开代理依然上不去）。 进入之后看到一段视频介绍，然后右下角可以直接连接客服，老外还是比较热情的，虽然我只使用了免费版。 技术细节呢是说他们创建了一个分布式的vpn集群（不依赖公共节点），并且不存储客户数据与日志，貌似你开启了一个hide.me，那么你就是一个节点。 接下来就是注册账号，激活邮箱，下载，安装。下载的时候提供很多版本，window，linux，mac os各个版本应有尽有。然后免费版是支持三个区域的ip，加拿大、荷兰和新加坡。还有些不同例如不支持端口转发等，详见&gt; https://hide.me/en/pricing 来张使用中的hide.me VPN吧。 最后就是YOUTUBE妥妥儿的Tizzy Bac – 抽筋的胃（现场版与专辑并无二样，不喜勿喷）","categories":[{"name":"vpn","slug":"vpn","permalink":"https://lison.cc/categories/vpn/"}],"tags":[],"author":"Lison"},{"title":"可能在我左右","slug":"why","date":"2015-12-22T03:48:58.000Z","updated":"2023-11-16T06:15:51.868Z","comments":true,"path":"why/","link":"","permalink":"https://lison.cc/why/","excerpt":"你才追求孤独的自由","text":"你才追求孤独的自由","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"Android Debug Bridge adb - 安卓调试桥 官方文档汉化记录(原创)","slug":"translate-android-adb-document","date":"2015-12-16T03:46:26.000Z","updated":"2023-11-16T06:15:51.861Z","comments":true,"path":"translate-android-adb-document/","link":"","permalink":"https://lison.cc/translate-android-adb-document/","excerpt":"名词释义：模拟器：指使用ADT或者第三方软件创建的安卓模拟器安卓设备（设备）：指运行安卓系统的硬件、含手机、Pad，TV等","text":"名词释义：模拟器：指使用ADT或者第三方软件创建的安卓模拟器安卓设备（设备）：指运行安卓系统的硬件、含手机、Pad，TV等 Android Debug Bride简称adb，是一个多用途的命令行工具，能够让你与你的安卓模拟器或者安卓设备进行通讯。它是一个包含三个组件的C-S程序： 客户端。运行在你的开发机上。你可以通过shell发送一条adb命令用开调用一个客户端。其他的Android工具例如ADT插件和DDMS也可以创建adb客户端。 服务端。运行在你的开发机的后台进程中，服务端管理客户端与运行在模拟器或设备上的adb守护进程的通信工作。 守护进程。是一个运行在每个模拟器或者设备上的后台进程。 可以在/plateform-tools目录找到adb工具。 当你启动一个adb客户端的时候，客户端会首先检查是否已经有adb服务端进程在运行。如果没有，就开启服务进程。当服务进程开启之后，它会绑定本地TCP的5037端口并且监听来自adb客户端的命令（所有的adb客户端都使用5037端口与服务端进行通信）。 然后服务端与所有正在运行的模拟器/设备建立连接。服务端通过扫描模拟器/设备的开放端口（5555-5585范围内的奇数端口）来定位设备。当服务端发现adb守护进程时，就与这个端口建立连接。需要注意的是模拟器/设备获取的是一对连续的端口号（偶数端口号用于控制台连接，奇数端口号用于adb连接）示例： 模拟器1 控制台端口号：5554模拟器1 adb端口号：5555模拟器2 控制台端口号：5556模拟器2 adb端口号：5557 如上所述，模拟器已经与adb的5555端口建立了连接，与控制台监听5554端口是一样的。 一旦服务器与所有模拟器建立连接，就可以通过adb命令访问这些设备。基于服务端管理着所有模拟器/设备并且处理多个adb客户端的命令，你可以通过任意一个adb客户端控制任意的模拟器/设备（或者通过脚本）。 **Enabling adb Debugging 开启adb调试** 为使用usb连接的设备使用开启adb，需要在设备的系统设置-&gt;开发者选项中开启USB调试。 在Android4.2或者更高版本的系统中，开发者选项默认是隐藏的。显示的话，需要依次点击设置-&gt;关于手机，连续点击内部版本号（Build Number）七次。然后返回上一个界面的底部会出现开发者选项。 在有些设备中，开发者选项界面可能所在的位置或者名称会有不同。 注意：当用电脑连接一个运行着Android4.4.2或者更高版本的系统，系统会弹出一个对话框（显示RSA key）询问是否允许通过这台电脑进行调试。这个安全机制确保用户的设备不会被USB调试或者执行其他adb命令，除非用户点击对话框的确认按钮。这需要你的adb版本是1.0.31（在SDK Plateform-tools r16.0.01或者更高版本中）为了调试运行Android4.2.2或更高版本的系统。更多关于连接一个通过USB连接的设备，请阅读Using Hardware Devices。 **Syntax 语法** 你可以从开发机上通过一个命令行工具发送一条adb命令（或者一个脚本），用法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果当前只连接了一台模拟器/设备，adb命令就会发送到这台默认的设备。如果有多个模拟器/设备在运行并且已连接，就需要使用-d、-e、或者-s选项来指定目标设备并且执行命令。 **Commands 命令** 下面这张表列出了所有adb支持的命令，以及他们的解释及用途。表1 可用的adb命令 类别 命令/选项 描述 注释 Target Device -d 向唯一连接的USB设备执行一条adb命令 如果连接多台设备将返回错误 -e 向唯一连接的模拟器执行一条adb命令 如果正在运行多个模拟器将返回错误 -s 向指定的模拟器/设备执行一条adb命令，模拟器名称例如：emulator-5556 See Directing Commands to a Specific Emulator/Device Instance. General devices 打印所有已经附加的模拟器/设备列表 See Querying for Emulator/Device Instances for more information. help 打印adb支持的命令列表 version 打印adb版本号 Debug logcat [option] [filter-specs] 将log data输出到屏幕 bugreport 将系统信息，状态，logcat数据输出到屏幕 jdwp 在一个给定的设备上打印可用的JDWP进程列表 可以使用端口转发 jdwp: port 转发指定的连接到一个特定的JDWP进程，例如： adb forward tcp:8000 jdwp:472 jdb -attach localhost:8000 Data install 将一个安卓应用程序（指定apk文件的全路径）发送到模拟器/设备 pull 从模拟器/设备拷贝一个指定的文件到开发机。 push 将一个指定的文件拷贝至模拟器/设备上。 Ports and Networking forward 将本地socket连接的指定端口转发至指定的远程模拟器/设备端口 指定端口可以使用这些格式：tcp:``local:``dev:``jdwp: ppp [parm]... 通过USB运行PPP（点对点协议）：`` — the tty for PPP stream. For example dev:/dev/omap_csmi_ttyl.[parm]... — zero or more PPP/PPPD options, such as defaultroute, local, notty, etc.注意不要自动启动一个PPP连接 Scripting get-serialno 打印adb示例的序列号串 查看 Querying for Emulator/Device Instances 获取更多信息 get-state 打印模拟器/设备的adb状态 wait-for-device 在设备上线前阻止命令执行。 可以向adb预置这条命令，这种情况下，adb会等待模拟器/设备连接后才执行adb命令，示例：adb wait-for-device shell getprop注意这条命令不会导致adb一只等待整个系统启动完毕。因此，你不应该预置一条需要等待整个系统完全启动的命令。举例来说，安装命令需要Android Package Manager启动，而Android Package Manager需要整个系统完全启动，类似于这样的命令adb wait-for-device install .apk会发送安装命令当模拟器或设备连接到adb服务端，但之前Android系统已经完全启动，因此会得到一个错误的结果。 Server start-server 检查adb服务端进程是否正在运行，如果没有运行，则运行它。 kill-server 结束adb服务端进程 Shell shell 在目标模拟器/设备上开启一个远端shell 查看 Issuing Shell Commands 获取更多内容 shell [shellCommand] 在目标模拟器/设备上发送一个shell命令执行后退出。 要不先到这儿。 这不是一个翻译计划，也没有很多小组成员，只有一个惺忪着睡眼的程序猿。旨在将自己用到的阅读到的感觉比较有用的官方文档翻译一下供自己或者后来的盆友看，鉴于水平有限，文中不免有些生涩及直译的成分，不及与错误之处倘若有高手看到还请不吝指正。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"未完待续","slug":"未完待续","permalink":"https://lison.cc/tags/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"},{"name":"不列大标题","slug":"不列大标题","permalink":"https://lison.cc/tags/%E4%B8%8D%E5%88%97%E5%A4%A7%E6%A0%87%E9%A2%98/"}],"author":"Lison"},{"title":"素描と模糊","slug":"self-portrait","date":"2015-12-09T03:43:54.000Z","updated":"2023-11-16T06:15:51.681Z","comments":true,"path":"self-portrait/","link":"","permalink":"https://lison.cc/self-portrait/","excerpt":"","text":"模糊的记忆模糊了我的双眼陈了的空气陈了新的一天我在等谁谁在等谁既然已飘远在等谁你很沮丧无力隐藏无力抵抗幻想美丽的晚上丢弃自觉和方向一切就像空气一样没有阻碍和匆忙听到有人对我说你会如愿以偿一切还像从前一样还是愚蠢的匆忙幻想美丽的晚上丢弃自觉和方向一切就像空气一样没有阻碍和匆忙听到有人对我说你会如愿以偿一切还像从前一样还是愚蠢的匆忙模糊的记忆模糊了我的双眼陈了的空气陈了新的一天ahh~~你很沮丧无力隐藏无力抵抗幻想美丽的晚上丢弃自觉和方向一切就像空气一样没有阻碍和匆忙听到有人对我说你会如愿以偿一切还像从前一样还是愚蠢的匆忙","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"匆忙","slug":"匆忙","permalink":"https://lison.cc/tags/%E5%8C%86%E5%BF%99/"}],"author":"Lison"},{"title":"Android解决：The content of the adapter has changed but ListView did not receive a notification","slug":"android-the-content-of-the-adapter-has-changed-but-listview-did-not-receive-a-notification","date":"2015-11-19T03:33:00.000Z","updated":"2023-11-16T06:15:51.367Z","comments":true,"path":"android-the-content-of-the-adapter-has-changed-but-listview-did-not-receive-a-notification/","link":"","permalink":"https://lison.cc/android-the-content-of-the-adapter-has-changed-but-listview-did-not-receive-a-notification/","excerpt":"项目中的错误，记录一下。 完整的错误信息如下： 1The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. [in ListView(2131492991, class android.widget.ListView) with Adapter(class com.impulsefitness.support.ui.WorkOrderDetailActivity$CustomFeedbackListViewAdapter)]","text":"项目中的错误，记录一下。 完整的错误信息如下： 1The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. [in ListView(2131492991, class android.widget.ListView) with Adapter(class com.impulsefitness.support.ui.WorkOrderDetailActivity$CustomFeedbackListViewAdapter)] 大意是说adapter内容已改变，但listview未收到通知，上下文不同步了。 精简一下，我有两个ActivityA和ActivityB。首先打开ActivityA，显示一个列表（listView），然后点击一个按钮startActivityForResult打开了B，B中添加了信息提交后setResult到A。B负责添加数据，添加完数据回到A，通知A重新load一遍远端数据，没问题（不要问我为什么要重新load一遍）。 在Activity A中单独起了一个线程去处理任务（请求远端service获取数据），handler收到message之后启动这个线程t，然后Activity A又startActivityForResult了另一个Activity B（这时候ActivityA已经onPause了，但是线程依然在运行，而且还在handler的callback队列中），当Activity B处理完逻辑setResult给Activity A（并且把自己给finish掉），需要让ActivityA重新请求service数据，也就是说线程t要重新运行一次，这时候handler里面已经有线程t这个对象了，然后就导致了上述的错误（好像这么说很牵强啊），参照CSDN牛人的文章，还是线程与上下文的事。 解决办法，在ActivityA的onPause将线程t从handler的callback中移除（然后handler再次收到同样的请求service的message时会重新将此线程t加入到callback队列中），如下： 123456789101112131415161718192021@Override protected void onPause() &#123; super.onPause(); handler.removeCallbacks(tListFeedback); &#125;Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; //页面加载，loading显示 case 0x00: pbFeedback.setVisibility(View.VISIBLE); Message.obtain(this, 0x01, msg.obj).sendToTarget(); break; //请求service，用于获取反馈列表数据 case 0x01: tListFeedback = new ThreadListFeedback(msg.obj.toString()); ThreadPoolUtils.execute(tListFeedback); break; ActivityA的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338super.findViewById(R.id.tvContactAddress); tvComment2 = (TextView) super.findViewById(R.id.tvComment2); tvPartIdNm = (TextView) super.findViewById(R.id.tvPartIdNm); tvPartAmount = (TextView) super.findViewById(R.id.tvPartAmount); tvPartFee = (TextView) super.findViewById(R.id.tvPartFee); tvCustomerName = (TextView) super.findViewById(R.id.tvCustomerName); tvMobile = (TextView) super.findViewById(R.id.tvMobile); tvContactName = (TextView) super.findViewById(R.id.tvContactName); tvContactMobile = (TextView) super.findViewById(R.id.tvContactMobile); ivCall1 = (ImageView) super.findViewById(R.id.ivCall1); ivCall2 = (ImageView) super.findViewById(R.id.ivCall2); lvFeedback = (ListView) super.findViewById(R.id.lvFeedback); pbFeedback = (ProgressBar) super.findViewById(R.id.pbFeedback); customAdapter = new CustomFeedbackListViewAdapter(activity); lvFeedback.setEmptyView(super.findViewById(R.id.llListViewNoItemFeedbackDetail)); lvFeedback.setAdapter(customAdapter); AddFeedbackListener feedbackListener = new AddFeedbackListener(); btnAddFeedback.setOnClickListener(feedbackListener); FinishListener finishListener = new FinishListener(); ivBack.setOnClickListener(finishListener); llIvBack.setOnClickListener(finishListener); tvTitle.setText(this.getResources().getText(R.string.activity_name_workorder_detail)); Intent i = getIntent(); Bundle b = i.getExtras(); if (null == b) &#123; tost(R.string.activity_workorder_detail_invalid_workorderno); this.finish(); &#125; else &#123; String workOrderNo = b.getString(&quot;workorderno&quot;); if (null == workOrderNo) &#123; tost(R.string.activity_workorder_detail_invalid_workorderno); this.finish(); &#125; else &#123; Message.obtain(handler, 0x00, workOrderNo).sendToTarget(); //通知handler，开始load数据 tvWorkOrderNo.setText(workOrderNo); tvServiceType.setText(b.getString(&quot;serviceType&quot;)); tvBookingTime.setText(b.getString(&quot;bookingTime&quot;)); tvContactAddress.setText(b.getString(&quot;constructAddress&quot;)); tvComment2.setText(b.getString(&quot;comment2&quot;)); tvPartIdNm.setText(b.getString(&quot;partId&quot;) + b.getString(&quot;partName&quot;)); tvPartAmount.setText(b.getString(&quot;partAmount&quot;) + &quot;台&quot;); tvPartFee.setText(b.getString(&quot;partFee&quot;)); tvCustomerName.setText(b.getString(&quot;customerName&quot;)); tvMobile.setText(b.getString(&quot;mobile&quot;)); tvContactName.setText(b.getString(&quot;contactName&quot;)); tvContactMobile.setText(b.getString(&quot;contactMobile&quot;)); ivCall1.setOnClickListener(new CallListener(tvMobile.getText().toString())); ivCall2.setOnClickListener(new CallListener(tvContactMobile.getText().toString())); &#125; &#125; &#125; /** * 自定义ListView Adapter */ class CustomFeedbackListViewAdapter extends BaseAdapter &#123; //对象所在的上下文Activity Activity activity; public CustomFeedbackListViewAdapter(Activity activity) &#123; this.activity = activity; &#125; @Override public int getCount() &#123; return listViewData.size(); &#125; @Override public Object getItem(int position) &#123; return listViewData.get(position); &#125; @Override public long getItemId(int position) &#123; return 0; &#125; class ViewHolder &#123; TextView tvFeedbackContent; ImageView ivArrowLaunch; &#125; @Override public View getView(final int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; LayoutInflater inflater = activity.getLayoutInflater(); if (convertView == null) &#123; convertView = inflater.inflate(R.layout.listview_feedback_detail_item, null); holder = new ViewHolder(); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); if (null == holder) holder = new ViewHolder(); &#125; holder.tvFeedbackContent = (TextView) convertView.findViewById(R.id.tvFeedbackContentCombineStatement); holder.ivArrowLaunch = (ImageView) convertView.findViewById(R.id.ivFeedbackContentArrowLaunch); holder.ivArrowLaunch.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; tost(R.string.btn_txt_ok); &#125; &#125;); HashMap&lt;String, Object&gt; map = listViewData.get(position); holder.tvFeedbackContent.setText( map.get(&quot;employeeName&quot;).toString() + &quot;在&quot; + map.get(&quot;isrtDt&quot;) + &quot;添加了反馈\\&quot;&quot; + map.get(&quot;feedbackContent&quot;) + &quot;\\&quot;&quot; ); return convertView; &#125; &#125; ThreadListFeedback tListFeedback; /** * 消息处理handler */ Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; //页面加载，loading显示 case 0x00: pbFeedback.setVisibility(View.VISIBLE); Message.obtain(this, 0x01, msg.obj).sendToTarget(); break; //请求service，用于获取反馈列表数据 case 0x01: tListFeedback = new ThreadListFeedback(msg.obj.toString()); ThreadPoolUtils.execute(tListFeedback); break; //请求成功，已获取到数据 case 0x02: pbFeedback.setVisibility(View.GONE); Bundle b = msg.getData(); if (null != b) try &#123; SaxJson(b.get(&quot;remoteInfo&quot;)); &#125; catch (JSONException e) &#123; e.printStackTrace(); Message.obtain(this, -0x03, e.getMessage()).sendToTarget(); &#125; else Message.obtain(this, -0x03, &quot;:&quot; + getString(activity, R.string.not_acquired_data)).sendToTarget(); break; //请求失败 case -0x02: pbFeedback.setVisibility(View.GONE); String m = getString(activity, R.string.not_acquired_data) + msg.obj; tost(m); break; //解析json串异常 case -0x03: tost(&quot;parse error&quot; + msg.obj); break; //解析json正常，刷新UI case 0x04: customAdapter.notifyDataSetChanged(); Message.obtain(this, 0x05).sendToTarget(); break; case 0x05: setListViewHeight(lvFeedback); break; &#125; &#125; &#125;; @Override protected void onPause() &#123; super.onPause(); handler.removeCallbacks(tListFeedback); &#125; /** * 请求service获取反馈列表Runnable对象 */ class ThreadListFeedback extends Thread &#123; String workOrderNo; public ThreadListFeedback(String workOrderNo) &#123; this.workOrderNo = workOrderNo; &#125; @Override public void run() &#123; Map&lt;String, Object&gt; requestData = new HashMap&lt;&gt;(); Bundle bundle = new Bundle(); try &#123; requestData.put(&quot;workOrderNo&quot;, workOrderNo); SoapInfo soapInfo = ServiceConstant.getWorkOrderFeedbackList(); soapInfo.setRequestData(requestData); SoapService soapService = new SoapService(soapInfo); String remoteInfo = soapService.getRemoteInfo(); bundle.putString(&quot;remoteInfo&quot;, remoteInfo); if (remoteInfo == &quot;-1&quot;) Message.obtain(handler, -0x02, getString(activity, R.string.activity_workorder_detail_invalid_workorderno)).sendToTarget(); else &#123; Message m = Message.obtain(handler, 0x02); m.setData(bundle); m.sendToTarget(); &#125; Log.i(MainActivity.TAG, &quot;remoteInfo:&quot; + remoteInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); Message.obtain(handler, -0x02, e.getMessage()).sendToTarget(); &#125; &#125; &#125; /** * 解析service返回json串 * * @param objJson */ void SaxJson(Object objJson) throws JSONException &#123; JSONArray jsonArray = new JSONArray(objJson.toString()); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject = (JSONObject) jsonArray.get(i); HashMap&lt;String, Object&gt; item = new HashMap&lt;&gt;(); item.put(&quot;feedbackId&quot;, jsonObject.getString(&quot;feedbackId&quot;).trim()); item.put(&quot;workOrderNo&quot;, jsonObject.getString(&quot;workOrderNo&quot;).trim()); item.put(&quot;repairEmployeeId&quot;, jsonObject.getString(&quot;repairEmployeeId&quot;).trim()); item.put(&quot;employeeName&quot;, jsonObject.getString(&quot;employeeName&quot;).trim()); item.put(&quot;contactName&quot;, jsonObject.getString(&quot;contactName&quot;).trim()); item.put(&quot;contactPhone&quot;, jsonObject.getString(&quot;contactPhone&quot;).trim()); item.put(&quot;contactMobile&quot;, jsonObject.getString(&quot;contactMobile&quot;).trim()); item.put(&quot;contactTime&quot;, jsonObject.getString(&quot;contactTime&quot;).trim()); item.put(&quot;feedbackContent&quot;, jsonObject.getString(&quot;feedbackContent&quot;).trim()); item.put(&quot;isrtDt&quot;, SimpleUtils.DateTimeUtils.parseTime(&quot;yyyy-MM-dd&quot;, jsonObject.getString(&quot;isrtDt&quot;).trim())); listViewData.add(item); &#125; Message.obtain(handler, 0x04).sendToTarget(); &#125; /** * 添加反馈按钮事件监听器 */ class AddFeedbackListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; Intent i = getIntent(); i.putExtra(&quot;workorderno&quot;, tvWorkOrderNo.getText()); i.setClass(WorkOrderDetailActivity.this, WorkOrderFeedbackActivity.class); startActivityForResult(i, 0x00); &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case 0x00: //添加反馈完成，刷新数据 if (null != data) &#123; boolean submitted = data.getBooleanExtra(&quot;submitted&quot;, false); if (submitted) Message.obtain(handler, 0x00, data.getStringExtra(&quot;workOrderNo&quot;)).sendToTarget(); //通知handler，开始load数据 &#125; break; &#125; &#125; /** * 关闭当前Activity单击事件监听器 */ class FinishListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; WorkOrderDetailActivity.this.finish(); &#125; &#125; /** * Call监听器 */ class CallListener implements View.OnClickListener &#123; String telNo; public CallListener(String telNo) &#123; this.telNo = telNo; &#125; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(&quot;tel://&quot; + telNo)); startActivity(intent); &#125; &#125; /** * 自定义actionBar布局文件 * http://www.cnblogs.com/yc-755909659/p/4290784.html * * @param layoutId */ void setActionBarLayout(int layoutId) &#123; if (null != actionBar) &#123; actionBar.setDisplayShowHomeEnabled(false); actionBar.setDisplayShowCustomEnabled(true); actionBar.setDisplayShowTitleEnabled(false); LayoutInflater inflator = (LayoutInflater) this.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflator.inflate(layoutId, null); ActionBar.LayoutParams layout = new ActionBar.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); actionBar.setCustomView(v, layout); &#125; &#125;&#125; 新解： 还是上面的错误信息，注意这句： 1Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. 确保adapter的内容不要在后台线程中修改，只能从UI线程中修改。而我的代码是直接message交给handler去处理的，难道这也算后台线程？于是想到了Runnable对象，它是依附于UI线程的，然后使用了handler.post(new Runnable())的方法，测试成功。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lison.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Lison"},{"title":"《Android坑之java.net.SocketException： Permission denied》","slug":"android-socket-permission-denied","date":"2015-11-06T03:22:50.000Z","updated":"2023-11-16T06:15:51.365Z","comments":true,"path":"android-socket-permission-denied/","link":"","permalink":"https://lison.cc/android-socket-permission-denied/","excerpt":"OK,不知道这算不算是一个坑，记录一下吧，一上午都过去了。。。 先上代码，简单的网路请求上传图片，做了精简，只留关键部分。","text":"OK,不知道这算不算是一个坑，记录一下吧，一上午都过去了。。。 先上代码，简单的网路请求上传图片，做了精简，只留关键部分。 一执行到con.getOutputStream()就报错： 刚开始以为代码抄的不好，各种百度，发现没有加权限： 结果加上也不好使，又陆续加了 都不好使。。。后来单开线程请求也不好使（代码已省略）。 然后各种百度找到的都是那几篇文章， 要么是模拟器忘了开sd卡，可是我用的真机啊。。。然后各种胡思乱想，难道是因为我的手机没root？这倒是跟没有权限的用户执行命令的时候没权限是同样的提示啊。。。难道我的内存卡没有mount？难道我的图片存到了系统空间，我没有权限读？bla bla bla 后来找大神要了段代码，发现跟我写的一样，同样报错。。。知道后来又搜到了这篇文章：《Android之EACCES (Permission denied)与Permission denied异常探密》当中的第二条，permission写的地方不对，检查了我的manifest发现我的permission节写在了application里面（为什么当初我要这么做？我也不知道，为什么别的permission没有报错，我tm怎么知道），然后把所有permission拿出来放到与application平级，终于报的错不一样啦。。。。 另一个坑走起。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[],"author":"Lison"},{"title":"决定今年内暂时先不买书了，手里的啃掉再说","slug":"im-reading","date":"2015-10-27T03:20:48.000Z","updated":"2023-11-16T06:15:51.624Z","comments":true,"path":"im-reading/","link":"","permalink":"https://lison.cc/im-reading/","excerpt":"","text":"《青铜时代》刚刚开始，后面还有《白银时代》和《黄金时代》，小波确实很犀利，可能不属于那个时代，也可能书还没看完，一直不明白他的隐线是什么。 很多时候都是看了书名就买了，比如《从晚清到民国》，还没翻呢。 还有些大师的书要看，K&amp;R的《The C Programming Language》。 《Zen and the art of motorcycle maintanance》、《A Short History of Tractors in Ukrainian》 还有一些电影。。。《The Book Thief》、《Every Thing Will Be Fine》","categories":[{"name":"reading","slug":"reading","permalink":"https://lison.cc/categories/reading/"}],"tags":[],"author":"Lison"},{"title":"以鲁迅先生的口吻，作别青岛的序。简字、图集","slug":"sayonara-qingdao","date":"2015-10-24T03:15:45.000Z","updated":"2023-11-16T06:15:51.678Z","comments":true,"path":"sayonara-qingdao/","link":"","permalink":"https://lison.cc/sayonara-qingdao/","excerpt":"左眼已经连续跳了好些天，也丝毫没有头彩的迹象。 确实不知道怎样开头，就像不知道如何结束。结束眼前，结束现在。","text":"左眼已经连续跳了好些天，也丝毫没有头彩的迹象。 确实不知道怎样开头，就像不知道如何结束。结束眼前，结束现在。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"记@我也来篇eclipse – Maven配置实战-_-","slug":"eclipse-maven","date":"2015-10-22T03:09:41.000Z","updated":"2023-11-16T06:15:51.603Z","comments":true,"path":"eclipse-maven/","link":"","permalink":"https://lison.cc/eclipse-maven/","excerpt":"为了实现一个不可告人的秘密，我在github找到了一个maven项目，我以为pull本地或者import之后就能运行看到效果（因为我是典型的windows程序猿），结果发现，我不能run它。。。","text":"为了实现一个不可告人的秘密，我在github找到了一个maven项目，我以为pull本地或者import之后就能运行看到效果（因为我是典型的windows程序猿），结果发现，我不能run它。。。 Maven到底是什么百科和度娘上解释的都太大牛话，我是看的云里雾里，什么事情我喜欢用一句话解释：Maven就是以前你引用jar都是拷贝到lib目录，或者从项目属性的Build Path中添加jar包，现在不用，你可以从Maven的中央仓库中添加依赖项（dependencies），适合团队协作，各种项目如果都使用某一个版本的jar包，则可以使用对应的dependency。还是不懂？也难怪，谁让我们都在代码作坊中工作，而且本身又是码畜呢。。。 怎么玩Maven？实际上，eclipse中已经嵌入了一个maven，如果你点击Window-&gt;Preferences-&gt;Maven-&gt;Installations可以看到右侧已经有一个Embedded的Maven，OK不管他，我们要自己配置一个。 Maven是apache的项目，主页地址为：http://maven.apache.org左侧有download选项卡，选择适合自己的下载就ok了。下载完成后解压会得到apache-maven-3.3.3这样一个目录，然后配置环境变量。M2_HOME指向F:\\maven\\apache-maven-3.3.3\\（这是我本机的目录）MAVEN_HOME同样指向上述目录|MAVEN_OPTS设置为：-Xms512m -Xmx1024m（这个好像是运行时分配资源的大小，我猜的） 然后cmd-&gt;mvn -v OK,这一步算完成了。 然后安装eclipse的Maven插件，直接传送门一个吧，ps.我的JUNO版本的eclipse的help中没有marketplace项，那就使用Install New Software，eclipse安装maven插件传送门。 接下来，我git下来的项目到底怎么用，比如我git的这个webmagic，首先阅读readme.md，找到如何使用Maven 使用Maven 实际上，这就我们项目所要用的依赖项。 OK，eclipse的maven插件安装好以后，eclipse中就可以新建maven项目了，File-&gt;New-&gt;Project-&gt;Maven Project下一步之后等待Catelog从Nexus Indexer选项中Retrive Indexer，之后选择，Group Id为org.apache.maven.archetypes Artifact Id为maven-archetype-quickstart的这一项（这个我也没大弄懂），下一步，为你的项目指定Group Id，Artifact Id及version（这里是在中央仓库注册自己的项目？类似指定package name？）下一步，创建成功。 之后在项目中会找到pom.xml，将上面使用maven的depencency复制到depencencies节点中，然后右键项目Maven-&gt;Maven Build，可以看到Console中输出为Build Success 如果出现找不到Goles错误的话，就在Goles里填入clean或者test。之后就可以新建class extends或者implements maven项目中的包了，OK，Enjoy it。 引用借鉴了的几篇文章，感谢互联网上的大神们。http://www.cnblogs.com/yjmyzz/p/3495762.htmlhttp://www.iteye.com/topic/1123225","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://lison.cc/tags/maven/"}],"author":"Lison"},{"title":"记@Android Studio使用初体验杂记","slug":"android-studio-helloworld","date":"2015-10-21T03:06:15.000Z","updated":"2023-11-16T06:15:51.366Z","comments":true,"path":"android-studio-helloworld/","link":"","permalink":"https://lison.cc/android-studio-helloworld/","excerpt":"最初时候用eclipse JUNO，谷歌给出的adt-bundle包下载下来什么都有了，sdk manager、plateform-tools、adb等等，只需要自己翻墙下载相应的sdk就可以helloworld了，当时的Android Studio 1.x版本那个难用啊。。。 但是google已经宣布不在支持eclipse了，虽我等已经习惯了eclipse，但是谷歌大法说用新的，用旧的出问题不负责，至少android开发领域，eclipse的用户与资料不会在上升了，于是这两天捣鼓了下Android Studio，杂记下。","text":"最初时候用eclipse JUNO，谷歌给出的adt-bundle包下载下来什么都有了，sdk manager、plateform-tools、adb等等，只需要自己翻墙下载相应的sdk就可以helloworld了，当时的Android Studio 1.x版本那个难用啊。。。 但是google已经宣布不在支持eclipse了，虽我等已经习惯了eclipse，但是谷歌大法说用新的，用旧的出问题不负责，至少android开发领域，eclipse的用户与资料不会在上升了，于是这两天捣鼓了下Android Studio，杂记下。 Android Studio基于IntelliJ IDE，我也没怎么用过，不过响应速度确实是快。 Android Studio可以使用ADT-Bundle包中的sdk目录，若之前已经下载了个版本的SDK，则可以直接指向此目录，无需二次下载，无需费时费力费硬盘。 之前整理代码的快捷键是Ctrl+Shift+F，现已加入肯德基豪华午餐：Ctrl+Alt+L，此热键与QQ锁界面的热键冲突，怎么办自己看着办。 关于Android Studio的默认界面（真是丑的一比）。修改IDE的字体及字号：File&gt;Settings 左上角搜索框输入appearance，找到Appearance &amp; Behavior &gt; Appearance，右边勾选Override default fonts by(not recommended)，然后Name跟Size就自己看着选了。 关于编辑器的字体（主题）设置，我使用的是Darcula。File&gt;Settings&gt;Editor&gt;Colors &amp; Fonts，点击Save As按钮，将当前主题另存一份，确定之后，在点击左侧树菜单Colors &amp; Fonts下的Font，然后选择字体跟字号，OK。 Android Studio的布局实时预览，赞一个。 Android Studio的Develper Services赞一个，好像可以一键增加AD，Analytics还有推送那些东西？暂时还没研究。 对于Gradle的概念还是没有弄的很明白，跟make有什么区别？Groovy更是不懂了。 那么Maven到底是怎么回事，统一各版本jar包集合平台？不冲突依赖解决方案吗。。。 集成的ADT Manager好像比JUNO那个启动快很多。 Android Studio启动时会很卡，其他有些操作有时候也会很卡，多注意看看控制台输出，IDE加入了Gradle自动构建，很多时候都在帮你clean或者rebuild或者render项目文件，所以会卡，但是自动提示功能我觉得比宇宙最强IDE Visual Studio还要强了。 如何删除项目？新建了个hello world删不掉了吧。File&gt;Project Structure，在下面的Modules中选中要删除的项目，点击上面的”减号“按钮。 暂时就这些，hello world去了","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"When people ask where you R from and how long you v been riding","slug":"zen","date":"2015-10-15T02:59:51.000Z","updated":"2023-11-16T06:15:51.878Z","comments":true,"path":"zen/","link":"","permalink":"https://lison.cc/zen/","excerpt":"","text":"Roads with little traffic are more enjoyable, as well as safer. Roads free of drive-ins and billboards are better, Roads where groves and meadows and orchards and lawns come almost to the shoulder, Where kids wave to you when you ride by, Where people look from their porches to see who it is, Where when you stop to ask directions or information the answer tends to be longer than you want rather than short, Where people ask where you’re from and how long you’ve been riding. 摘自《Zen and the art of motorcycle maintenance》","categories":[{"name":"修行","slug":"修行","permalink":"https://lison.cc/categories/%E4%BF%AE%E8%A1%8C/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"https://lison.cc/tags/%E6%97%85%E8%A1%8C/"}],"author":"Lison"},{"title":"再见，86","slug":"sayonara-86","date":"2015-10-12T02:57:06.000Z","updated":"2023-11-16T06:15:51.677Z","comments":true,"path":"sayonara-86/","link":"","permalink":"https://lison.cc/sayonara-86/","excerpt":"","text":"好像我已不知如何表达，或许时间久了，感觉都钝了，慢慢退化了。是的。我总会为自己找到理由。 不要忘记第一次做的事，第一次爱的人。因为他们会从最初的地方陪伴着你，到每一个角落，每一段韶光。难道这就是纯真？ 人是会对人之外的东西产生感情的。一个地方，一条街道，一个书桌，或是一张床。 就叫他86吧，在我想起还没说再见的时候，就注定再也不能相见。对，是这样的，你永远说不出喜欢或恨，但你永远知道后知后觉。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"你的扣肉","slug":"nidekourou","date":"2015-07-17T02:50:30.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"nidekourou/","link":"","permalink":"https://lison.cc/nidekourou/","excerpt":"","text":"风吹柳絮 茫茫难聚随着风吹 飘来飘去我若能够共你停下去我愿似一块扣肉我愿似一块扣肉我愿似一块扣肉扣住你梅菜扣住你手我愿似一块扣肉我愿似一块扣肉我是你一块扣肉扣住你梅菜扣住你手我愿似一块扣肉我愿似一块扣肉我是你一块扣肉你是我梅菜扣住你手啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦爱似是飞花飘絮 愿能紧扣伴你共度余生爱你是一生一世 愿能跟你共扣着度余生啊…啊…啊…啊…啊…似一块扣肉…啊…啊…啊…啊…啊…我愿似一块扣肉我愿似一块扣肉我愿似一块扣肉扣住你梅菜扣住你手我愿似一块扣肉我愿似一块扣肉我是你一块扣肉你是我梅菜扣住你手啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啊…啊…啊…啊…啊…似一块扣肉…啊…啊…啊…啊…啊…似一块扣肉…似一块扣肉…似一块扣肉…似一块扣肉…","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"zhi","slug":"zhi","permalink":"https://lison.cc/tags/zhi/"}],"author":"Lison"},{"title":"从简单的java连接MSSQLSERVER代码中得到的教训","slug":"what-i-got-from-mssql-conn","date":"2015-07-07T02:44:38.000Z","updated":"2023-11-16T06:15:51.864Z","comments":true,"path":"what-i-got-from-mssql-conn/","link":"","permalink":"https://lison.cc/what-i-got-from-mssql-conn/","excerpt":"123456789101112131415161718192021222324252627282930313233343536373839404142String sqlUrl = &quot;jdbc:sqlserver://127.0.0.1:1433;databaseName=Test;user=sa;password=sa&quot;; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // Establish the connection. Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); conn = DriverManager.getConnection(sqlUrl); // Create and execute an SQL statement that returns some data. String SQL = &quot;select * from tableName&quot;; stmt = conn.createStatement(); rs = stmt.executeQuery(SQL); ResultSet excel = readExcel(); while (excel.next()) System.out.println(excel.getString(2)); &#125; // Handle any errors that may have occurred. catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (rs != null) try &#123; rs.close(); &#125; catch (Exception e) &#123; &#125; if (stmt != null) try &#123; stmt.close(); &#125; catch (Exception e) &#123; &#125; if (conn != null) try &#123; conn.close(); &#125; catch (Exception e) &#123; &#125; &#125;","text":"123456789101112131415161718192021222324252627282930313233343536373839404142String sqlUrl = &quot;jdbc:sqlserver://127.0.0.1:1433;databaseName=Test;user=sa;password=sa&quot;; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // Establish the connection. Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); conn = DriverManager.getConnection(sqlUrl); // Create and execute an SQL statement that returns some data. String SQL = &quot;select * from tableName&quot;; stmt = conn.createStatement(); rs = stmt.executeQuery(SQL); ResultSet excel = readExcel(); while (excel.next()) System.out.println(excel.getString(2)); &#125; // Handle any errors that may have occurred. catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (rs != null) try &#123; rs.close(); &#125; catch (Exception e) &#123; &#125; if (stmt != null) try &#123; stmt.close(); &#125; catch (Exception e) &#123; &#125; if (conn != null) try &#123; conn.close(); &#125; catch (Exception e) &#123; &#125; &#125; 一切都没什么好说的，只有那句：**System.out.println(excel.getString(2));** 最初写的是getString(0)，一直报错，怎么写也报错，getArray，getObject都试了一遍，还是报错： java.sql.SQLException: [Microsoft][ODBCat sun.jdbc.odbc.JdbcOdbc.createSQLException(Unknown Source)at sun.jdbc.odbc.JdbcOdbc.standardError(Unknown Source)at sun.jdbc.odbc.JdbcOdbc.SQLColAttributes(Unknown Source)at sun.jdbc.odbc.JdbcOdbcResultSet.getColAttribute(Unknown Source)at sun.jdbc.odbc.JdbcOdbcResultSet.getColumnType(Unknown Source)at sun.jdbc.odbc.JdbcOdbcResultSet.getMaxCharLen(Unknown Source)at sun.jdbc.odbc.JdbcOdbcResultSet.getString(Unknown Source)at com.lison.practise.Main.main(Main.java:39) 最后是查看了getString的源码，看到了注解： 原来这个index是从1开始的， 瞬间清凉到北极啊。。。尼玛不看注解会折寿啊。。。","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"看黑板","slug":"看黑板","permalink":"https://lison.cc/tags/%E7%9C%8B%E9%BB%91%E6%9D%BF/"}],"author":"Lison"},{"title":"TO MYSELF ( WHAT I NEED TO DO FROM NOW )","slug":"to-myself","date":"2015-03-27T02:36:36.000Z","updated":"2023-11-16T06:15:51.861Z","comments":true,"path":"to-myself/","link":"","permalink":"https://lison.cc/to-myself/","excerpt":"给自己的建议","text":"给自己的建议 Quit DIABLO II Exactly A little bit of WORLD WAR CRAFT Keep fit at night Some more pure music Keep coding &amp; leaning java QUIT smoking More time with family Training self Character Keep reading &amp; smiling In peace to everything Keep away from boring More outdoor activity Stay focus, Concentrate Be natural","categories":[{"name":"生活作业","slug":"生活作业","permalink":"https://lison.cc/categories/%E7%94%9F%E6%B4%BB%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"给自己","slug":"给自己","permalink":"https://lison.cc/tags/%E7%BB%99%E8%87%AA%E5%B7%B1/"}],"author":"Lison"},{"title":"startActivityForResult获取不到返回值 – Android","slug":"start-activity-for-result-cant-get-result","date":"2015-03-26T13:50:50.000Z","updated":"2023-11-16T06:15:51.855Z","comments":true,"path":"start-activity-for-result-cant-get-result/","link":"","permalink":"https://lison.cc/start-activity-for-result-cant-get-result/","excerpt":"使用startActivityForResult与setResult通常解决的场景是：A Activity打开B Activity，B执行完业务后返回结果给A。","text":"使用startActivityForResult与setResult通常解决的场景是：A Activity打开B Activity，B执行完业务后返回结果给A。 1234// 弹出区域选择框（辅助GPS与网络自动获取，提示用户打开GPS与网络，不强制；打开后自动获取，供用户选择）Intent i = new Intent(MainActivity.this, ProvinceActivity.class);i.putExtra(&quot;currentPosition&quot;, &quot;&quot;);startActivityForResult(i, 0); 12345678910111213141516171819202122232425/*** 重写onActivityResult，*/@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;switch (resultCode) &#123; // resultCode为回传的标记，我在B中回传的是RESULT_OK case RESULT_OK:// 取出字符串 Bundle bundle = data.getExtras(); String[] result = bundle.getStringArray(&quot;currentPosition&quot;); Log.i(&quot;position&quot;, result.toString()); break; &#125; super.onActivityResult(requestCode, resultCode, data); &#125; Intent i = new Intent(ProvinceActivity.this, MainActivity.class);Bundle b = new Bundle();b.putStringArray(&quot;currentPosition&quot;, new String[] &#123; mCurrentProviceName, mCurrentCityName, mCurrentDistrictName, mCurrentZipCode &#125;);i.putExtras(b);this.setResult(RESULT_OK, i);this.finish(); ​ 结果发现无论如何也不能输出结果，查找网络后发现Activity在Manifest注册时lauchMode不能使用singleInstance模式；将A与B的singleInstance去掉之后，正常获取值。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lison.cc/tags/android/"}],"author":"Lison"},{"title":"Spend all your time waiting for that second chance","slug":"spend-all-your-time-waiting-for-that-second-chance","date":"2015-03-23T13:41:46.000Z","updated":"2023-11-16T06:15:51.852Z","comments":true,"path":"spend-all-your-time-waiting-for-that-second-chance/","link":"","permalink":"https://lison.cc/spend-all-your-time-waiting-for-that-second-chance/","excerpt":"Spend all your time waitingFor that second chanceFor a break that would make it okayThere’s always some reasonTo feel not good enoughAnd it’s hard at the end of the day I need some distractionOh beautiful releaseMemories seep from my veinsLet me be emptyOh and weightless and maybeI’ll find some peace tonight In the arms of the angelFly away from hereFrom this dark cold hotel roomAnd the endlessness that you fear You are pulled from the wreckageOf your silent reverieYou’re in the arms of the angelMay you find some comfort here Sarah McLachlan – Angel So tired of the straight lineAnd everywhere you turnThere’s vultures and thieves at your backThe storm keeps on twistingKeep on building the liesThat you make up for all that you lack It don’t make no differenceEscaping one last timeIt’s easier to believeIn this sweet madnessOh this glorious sadnessThat brings me to my knees In the arms of the angelFly away from hereFrom this dark cold hotel roomAnd the endlessness that you fear You are pulled from the wreckageOf your silent reverieYou’re in the arms of the angelMay you find some comfort here You’re in the arms of the angelMay you find some comfort here Sarah McLachlan – AngelAlbum: Surfacing","text":"Spend all your time waitingFor that second chanceFor a break that would make it okayThere’s always some reasonTo feel not good enoughAnd it’s hard at the end of the day I need some distractionOh beautiful releaseMemories seep from my veinsLet me be emptyOh and weightless and maybeI’ll find some peace tonight In the arms of the angelFly away from hereFrom this dark cold hotel roomAnd the endlessness that you fear You are pulled from the wreckageOf your silent reverieYou’re in the arms of the angelMay you find some comfort here Sarah McLachlan – Angel So tired of the straight lineAnd everywhere you turnThere’s vultures and thieves at your backThe storm keeps on twistingKeep on building the liesThat you make up for all that you lack It don’t make no differenceEscaping one last timeIt’s easier to believeIn this sweet madnessOh this glorious sadnessThat brings me to my knees In the arms of the angelFly away from hereFrom this dark cold hotel roomAnd the endlessness that you fear You are pulled from the wreckageOf your silent reverieYou’re in the arms of the angelMay you find some comfort here You’re in the arms of the angelMay you find some comfort here Sarah McLachlan – AngelAlbum: Surfacing","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"},{"name":"melody","slug":"melody","permalink":"https://lison.cc/tags/melody/"}],"author":"Lison"},{"title":"Arduino AtTiny85 使用SPI驱动8*8 LED点阵","slug":"arduino-spi-led-matrix","date":"2015-02-26T10:29:44.000Z","updated":"2023-11-16T06:15:51.537Z","comments":true,"path":"arduino-spi-led-matrix/","link":"","permalink":"https://lison.cc/arduino-spi-led-matrix/","excerpt":"上次分享了《用Arduino IDE USB 驱动 AtTiny 85》，这次记录一下使用Tiny85点亮LED点阵。","text":"上次分享了《用Arduino IDE USB 驱动 AtTiny 85》，这次记录一下使用Tiny85点亮LED点阵。 准备材料 AtTiny 85芯片一只 8*8 LED Matrix一块 USB数据线一条 先说接线方式VCC——5VGND——GNDDIN——PB1 MISO ( Master in Slave Out )CS——PB3CLK——PB2 SCK/ADC1 接线方式困扰我的是DIN针，之前一直是接在MOSI口上，想当然的理解为主机输出（哎，半路和尚老被欺负），外设输入，却怎么也显示不对；后来换过来试了一下，才正确输出，看来是自己理解的有错误：应该理解为主机（M）负责输出，外设（S）负责接收来自M的输出，不知道这样理解是否正确。 来个接线的图： 如果照着上图接的话，注意对应好颜色就可以了。 再来张运行中的： 目前只是实现了0-9几个数字的变化，并伴有一个刷新的效果程序代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;SPI.h&gt;#define DI 0 // D0, pin 5 Data In#define DO 1 // D1, pin 6 Data Out (this is *not* MOSI)#define USCK 2 // D2, pin 7 Universal Serial Interface clock#define SS 3 // D3, pin 2 Slave Select/** 16进制表示法，也可以写成二进制，例如B00111100（0x3c）* 下为0-9的16进制显示*/byte numbers[11][8]= &#123; &#123;0x3c,0x42,0x42,0x42,0x42,0x42,0x42,0x3c&#125;, &#123;0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x7e&#125;, &#123;0x7e,0x02,0x02,0x7e,0x40,0x40,0x40,0x7e&#125;, &#123;0x7e,0x02,0x02,0x7e,0x02,0x02,0x02,0x7e&#125;, &#123;0x08,0x18,0x28,0x48,0xfe,0x08,0x08,0x1c&#125;, &#123;0x7e,0x40,0x40,0x7e,0x02,0x02,0x02,0x7e&#125;, &#123;0x7e,0x40,0x40,0x7e,0x42,0x42,0x42,0x7e&#125;, &#123;0x7e,0x02,0x04,0x08,0x10,0x10,0x10,0x10&#125;, &#123;0x7e,0x42,0x42,0x7e,0x42,0x42,0x42,0x7e&#125;, &#123;0x7e,0x42,0x42,0x7e,0x02,0x02,0x02,0x7e&#125;, &#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;,&#125;;/*** Matrix寄存器地址常量*/const byte NOOP=0x0; //不运行const byte DECODEMODE=0x9; //译码模式const byte INTENSITY=0xA; //显示强度const byte SCANLIMIT=0xB; //扫描限制const byte SHUTDOWN=0xC; //停机const byte DISPLAYTEST=0xF; //显示器检测void max7219(byte reg,byte data)&#123; digitalWrite(SS,LOW); SPI.transfer(reg); SPI.transfer(data); digitalWrite(SS,HIGH); delay(200);&#125;void setup()&#123; pinMode(SS,OUTPUT); digitalWrite(SS,HIGH); SPI.begin(); initMax();&#125;void initMax()&#123; ////清屏代码，暂不使用 /*for(byte i=0;i&lt;sizeof(numbers[0]);i++)&#123; max7219(i+1,0);&#125;*/ max7219(SCANLIMIT,7); max7219(DECODEMODE,0); max7219(INTENSITY,1); max7219(DISPLAYTEST,0); max7219(SHUTDOWN,1);&#125;byte i,j;void loop()&#123; for(i=0;i&lt;11;i++)&#123; for(j=0;j&lt;8;j++) max7219(j+1,numbers[i][j]); delay(1200); &#125;&#125; AtTiny85是不能直接使用Arduino的SPI库的，这个问题困扰了我很长时间，最后在谷歌找到了答案，并且在github找到了这个类库。 然后分享一下用到的取模软件：LED Matrix Animator，感谢geek-workshop@幻生幻灭，虽然使用的板子不一样 :–) 最后看下动画效果：","categories":[{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/categories/arduino/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"曾经并肩往前的伙伴 , 在举杯祝福后都走散","slug":"lost-friends","date":"2015-02-20T10:49:11.000Z","updated":"2023-11-16T06:15:51.634Z","comments":true,"path":"lost-friends/","link":"","permalink":"https://lison.cc/lost-friends/","excerpt":"","text":"看昨天的我们 走远了在命运广场中央 等待那模糊的 肩膀 越奔跑 越渺小 曾经 并肩往前的 伙伴在举杯 祝福后都 走散只是那个 夜晚 我深深 的都留藏在心坎 长大以后 我只能奔跑我多害怕 黑暗中跌倒明天你好 含着泪微笑越美好 越害怕得到 每一次哭 又笑着奔跑一边失去 一边在寻找明天你好 声音多渺小却提醒我 勇敢是什么 当我朝着反方向走去在楼梯的角落 找勇气抖着肩膀 哭泣 问自己 在哪里 曾经 并肩往前 的伙伴沉默着 懂得我的委屈时间它总说谎 我从 不曾失去 那些肩膀 长大以后 我只能奔跑我多害怕 黑暗中跌倒明天你好 含着泪微笑越美好 越害怕得到每一次哭 又笑着奔跑一边失去 一边在寻找明天你好 声音多渺小却提醒我 勇敢是什么 《明天你好》 词：王海涛 曲：牛奶咖啡 唱：莫茜茜","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"OLD","slug":"OLD","permalink":"https://lison.cc/tags/OLD/"}],"author":"Lison"},{"title":"修复fs解决树莓派系统损坏无法启动，错误信息：unable to mount root fs on unkown block","slug":"raspberry-pi-unable-to-mount-root-fs-on-unkown-block","date":"2015-01-27T10:25:02.000Z","updated":"2023-11-16T06:15:51.673Z","comments":true,"path":"raspberry-pi-unable-to-mount-root-fs-on-unkown-block/","link":"","permalink":"https://lison.cc/raspberry-pi-unable-to-mount-root-fs-on-unkown-block/","excerpt":"树莓派（这个网站）最近的一次瘫痪发生在上周三晚上（大概九点以后），直到昨天晚上周一（大概九点以后）才恢复访问。持续时间已经可以用天算了，中间没有及时的去修复解决，记录一下整个过程。 其中各种罗里吧嗦，不感兴趣的可以直接锚点过去，开始修复。","text":"树莓派（这个网站）最近的一次瘫痪发生在上周三晚上（大概九点以后），直到昨天晚上周一（大概九点以后）才恢复访问。持续时间已经可以用天算了，中间没有及时的去修复解决，记录一下整个过程。 其中各种罗里吧嗦，不感兴趣的可以直接锚点过去，开始修复。 当时是在修一个LED头灯（折腾），树莓派的GPIO连接到了面包板上，来来回回试验头灯的LED板接线。结果树莓派连续闪了几次红灯之后（连续短路，可能有电路回流），ssh失去连接，当时网络灯还亮着，几次ssh之后都连接不上，于是我拔掉了树莓派的电源又重新插上，结果派就只亮电源灯了（This is a terrible mistake）。 心想这下坏了，板子烧了，当时就是这种想法。但又记得树莓派好像有类似过载保护的芯片（自恢复保险丝），这种情况是不是会避免掉呢，于是各种百度，了解到的一个事实是：”树莓派的自恢复保险丝可能没有想象中的那么可靠（主要是针对国产板子说的吧），即使能恢复，也可能需要48小时甚至72小时，有时等多久也恢复不“。看到这个貌似稍微舒坦了一点，感觉好像还有希望。但是手头既没有显示器电视等输出设备，也没有USB转TTL线，怀着无比纠结的心情，睡觉了。 第二天下班回来继续百度，如果是保险丝坏了，是不是可以自己换个呢，于是各种1688，电子件采购论坛，由于不清楚规格，焊接等的条件，这个也就没有继续下去。自恢复保险丝恢复了没？怀着忐忑的心情给树莓派接上电源，结果还是电源灯亮。第三天下班回来又试了一次，还是这样。 中间的碎片时间也会思考，树莓派是不是真完了，但是也没看着冒火花闻着烧焦味儿啊，真是硬件出问题了？会不会是软件，首先得确认这个。于是周六回家的时候，带上树莓派、HDMI线、无线键鼠回家了。回家之后连上电视，开机不到一秒钟，出现的画面： 而且键盘还没有反应，应该是还没启动到加载驱动的位置吧。 心想这下爽了，板子没问题，不过是系统坏了。最次的情况是重新烧系统。 但是辛辛苦苦攒下来的东西就没了，这个我是非常难以接受的，虽然访问量不大，也不盈利，怎么说也是近一年时间积攒的经验全都没了，接受不了。 于是想到求助，拍了张照片存了下来（iPhone的像素怎如此渣，好在能依稀辨别错误信息：unable to mount root fs on unkown-block，不能在未知块上挂载root文件系统）。 昨天上班上班第一件事（为什么不是前天晚上，驱了一路车有点累了，早上都没赶上班车）就是发帖求助，树莓派吧，segmentfault，geek-workshop都发布了，只希望有更多的大神看到小白的求助。 然后晚上收到大神们的回复，先感谢一下。 开始修复 其实基本流程我是清楚的（只不过没有实践经验），系统坏了，要么是引导坏了，要么是文件损坏。需要将SD卡挂载到linux系统，如果能识别，就把文件拷贝出来，该重做系统就重做系统（其中又少不了一番折腾）。 于是（好在有个debian）SD卡插上debian，debian自动挂载了两个文件系统，boot和7.9G文件系统，boot打开之后里面有两个img文件，使用ext2fs读不出来（现在还是没弄明白它是干什么的），还是感谢@fyplus（来自geek-workshop）大神。而7.9G文件系统则挂载失败，提示错误： wrong fs type, bad option, bad superblock on /dev/sda1,missing codepage or helper program, or other errorIn some cases useful info is found in syslog – trydmesg | tail or so 自动挂载失败，手动挂载也失败。等等，bad superblock on /dev/sda1，什么是superblock百度了之后有点明白了，于是又度娘“superblock 修复”，找到了一些文章，提及到的是使用fsck修复superblock。 例如这篇文章，而我的sd卡是ext4格式，所以我使用的命令是： fsck -t ext4 /dev/sdb2 提示修复完成，但仍有错误，一看debian已经把有错误的7.9G文件系统挂载上了，打开一看正是linux的系统文件夹：dev var etc mnt usr var srv（我自己建立的，我太爱你们了），我次奥这是不是好了呢，插上sd卡，接通电源，闪了几下，插上网线，ssh &#x70;&#105;&#x40;&#49;&#57;&#50;&#46;&#49;&#54;&#x38;&#46;&#49;&#x2e;&#49;&#48;&#52; 回车密码，YES!!! 至此，网站又恢复了访问：http://lison.cc真是好事多磨，一拨又三折呀。 感谢百度贴吧：**@qijionly @xiaohuozi88888 geek-workshop: **@fyplus @软件-蹄飞segmentfault: @沙渺 @RobinTang @Simple4Wan 挂载sd卡参考：http://blog.csdn.net/leo115/article/details/7697886 其他参考内容：Repair a broken SD card “superblock” on a #RaspberryPilinux文件系统问题：wrong fs type, bad option, bad superblockSuperBlock损坏修复 顺带解决一个问题：Google Fonts拖慢WordPress访问速度。 这个问题也是困扰了我好久，但我粗暴的把它归结为我的硬件与网络条件问题，因为使用的是电信家庭网、加上渣路由，还有树莓派的处理速度。之前知道有这个问题，不知道当时忙了还是怎么样，没放在心上，直到今天三番五次的打不开文章编辑页面，于是firebug了一下，发现原来我的wp也在连接Google fonts，于是照着这篇文章，给办了。http://devework.com/google-fonts-in-wordpress.html","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"浮生四记 ● 听香记 ● 片","slug":"floating-life","date":"2015-01-17T10:22:59.000Z","updated":"2023-11-16T06:15:51.603Z","comments":true,"path":"floating-life/","link":"","permalink":"https://lison.cc/floating-life/","excerpt":"苍山远 吴山远小舟行遍梦难挽浮生歌几番 思也难 恨也难而今卿我两隔栏春风老少年","text":"苍山远 吴山远小舟行遍梦难挽浮生歌几番 思也难 恨也难而今卿我两隔栏春风老少年","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"OLD","slug":"OLD","permalink":"https://lison.cc/tags/OLD/"},{"name":"老喽","slug":"老喽","permalink":"https://lison.cc/tags/%E8%80%81%E5%96%BD/"}],"author":"Lison"},{"title":"用Arduino IDE USB 驱动 AtTiny 85 (原创）","slug":"arduino-control-attiny85","date":"2015-01-14T09:58:15.000Z","updated":"2023-11-16T06:15:51.528Z","comments":true,"path":"arduino-control-attiny85/","link":"","permalink":"https://lison.cc/arduino-control-attiny85/","excerpt":"网上看到有朋友说心血来潮买了个AtTiny 85，结果不会玩。其实我也是这种情况，有时间会玩玩树莓派，看到这么小巧的板子觉得以后肯定会用到，然后就买了。结果放了几个月后才要拿出来玩一下。属于对硬件嵌入式基本上一窍不通但又比较感兴趣的。","text":"网上看到有朋友说心血来潮买了个AtTiny 85，结果不会玩。其实我也是这种情况，有时间会玩玩树莓派，看到这么小巧的板子觉得以后肯定会用到，然后就买了。结果放了几个月后才要拿出来玩一下。属于对硬件嵌入式基本上一窍不通但又比较感兴趣的。 刚开始玩的时候是直接找了跟手机USB线，连上AtTiny 85，插上电脑（win7 x64系统），就听到发现硬件、断开硬件来回不断的这种声音。 OK，笔记本没有com口，想想应该没关系啊，我这是USB直连的，刚买回来就是这么戳了两下，然后没成功就放起来了。 先来两张AtTiny 85的靓照吧，旁边没有使用一角硬币对比，但是高度真的跟一角硬币直径差不多，如果你的项目对空间要求比较苛刻的话，Tiny 85应该能够很好的满足。 得幸那天加了Arduino DIYer群，请教了一下大神，就把过程记录一下，感谢@dq。 开始记录点亮AtTiny 85的折腾： 首先下载DigisparkArduino-Win32，ok，我认为这是修改过的Arduino IDE。 下载完成后直接解压，得到如下目录。 第一个是Digispar-Arduino的主程序目录。 第二个是usb模拟串口的驱动目录？我不是很清楚啊。这是度娘告诉我的关于libusb的两篇介绍： http://www.cnblogs.com/image-eye/archive/2011/08/30/2159897.html http://blog.sina.com.cn/s/blog_63447c1f01012rwb.html 第三个是一些程序实例目录。 ok，先装驱动，然后打开Digispark-Arduino，开始软件方面的工作，界面看起来是这样的： 点击Tools -&gt; Board -&gt; Digispark(Tiny Core) 选择Tiny Core为当前开发版核心。 然后选择File -&gt; Example -&gt; Digispark_Example -&gt; Start,选择一个最简单的示例，来验证Arduino IDE驱动AtTiny。装载之后的程序代码如下： 12345678910111213141516// the setup routine runs once when you press reset:void setup() &#123; // initialize the digital pin as an output. pinMode(0, OUTPUT); //LED on Model B pinMode(1, OUTPUT); //LED on Model A &#125;// the loop routine runs over and over again forever:void loop() &#123; digitalWrite(0, HIGH); // turn the LED on (HIGH is the voltage level) digitalWrite(1, HIGH); delay(1000); // wait for a second digitalWrite(0, LOW); // turn the LED off by making the voltage LOW digitalWrite(1, LOW); delay(1000); // wait for a second&#125; 直接点击上传按钮，等到出现如下图示后： 再插入板子，跟普通的Arduino板子是有一点区别的。 然后就会看到AtTiny 85的贴片LED一闪一闪的效果了。 最后得到一个结论是，要驱动AtTiny 85，Arduino IDE加一条USB线就够了，不需要其他的编程器、下载器这些外设了。 如果要烧bootloader，就需要AVRMKII。这个具体还没弄明白，因为我的AtTiny 85已经烧了bootloader。 搞定了这个之后，下面就要学习一下如何点亮LED点阵了","categories":[{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/categories/arduino/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"いのちの記憶(生命的记忆) - 二階堂和美@《辉夜姬物语》主题曲","slug":"reflection-of-life","date":"2014-12-19T09:51:38.000Z","updated":"2023-11-16T06:15:51.673Z","comments":true,"path":"reflection-of-life/","link":"","permalink":"https://lison.cc/reflection-of-life/","excerpt":"","text":"原文歌词： あなたに触(ふ)れたよろこびが深(ふか)く深(ふか)くこのからだの端々(はしばし)にしみ込(こ)んでゆくずっと远(とお)くなにもわからなくなってもたとえこのいのちが终(お)わる时(とき)が来(き)てもいまのすべては过去(かこ)のすべて必(かなら)ずまた会(あ)える懐(なつ)かしい场所(ばしょ)であなたがくれたぬくもりが深(ふか)く深(ふか)く今(いま) 遥(はる)かな时(とき)を越(こ)え充(み)ち渡(わた)ってくじっと心(こころ)に灯(とも)す情热(じょうねつ)の炎(ほのお)もそっと伤(きず)をさする悲(かな)しみの渊(ふち)にもいまのすべては未来(みらい)の希望(きぼう)必(かなら)ず忆(おぼ)えてる懐(なつ)かしい记忆(きおく)でいまのすべては过去(かこ)のすべて必(かなら)ず また会(あ)える懐(なつ)かしい场所(ばしょ)でいまのすべては未来(みらい)の希望(きぼう)必(かなら)ず忆(おぼ)えてるいのちの记忆(きおく)で 罗马音（@剪一湖秋蓝 译） a na ta ni fu re tayo ro ko bi ga fu ka ku fu ka kuko no ka ra da no ha shi ba shi ni shi mi konn de yu kuzsu tto to o ku na ni mo wa ka ra na ku na tte mota to e ko no i no chi ga o wa ru to ki ga ki te moi ma no su be te wa ka kono su be teka na ra zu ma ta a e runa tsu ka shii ba sho dea na ta ga ku re ta nu ku mo ri ga fu ka ku fu ka kui ma ha ru ka na to ki wo ko e mi chi wa ta tte i kuji tto ko ko ro ni to mo su jou ne tsu no ho no o moso tto ki zu wo sa su ruka na shi mi no fu chi ni moi ma no su be te wa mi ra i no ki bouka na ra zu o bo e te ru na tsu ka shii ki o ku dei ma no su be te wa ka kono su be teka na ra zu ma ta a e runa tsu ka shii ba sho dei ma no su be te wa mi ra i no ki bouka na ra zu o bo e te ru i no chi no ki o ku de 中文翻译（@剪一湖秋蓝 译） 轻触到你时 喜悦油然而生深深嵌进身体各处即使，在漫长年月的彼端，一切已然扑朔迷离难知分晓即使，这短暂生命，总有终结之时当下的一切 正是往昔点滴的光辉你我定会在令人怀恋的地方，欣然重逢你曾给的温暖 深远绵长如今 已淌过遥遥岁月 满溢而来静静地 在心头点起的热情之焰轻轻地 安抚你的伤痕以那光明，抵及悲痛的深渊现在的一切 宛如未来希望之伏笔永世不忘 在这眷恋的记忆之岸现在的一切 正是往昔点滴的光辉你我定会在思忆漫长的地方 再度重遇现在的一切 必定化作未来的希望永世不忘 在这生命记忆的一页","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"生命","slug":"生命","permalink":"https://lison.cc/tags/%E7%94%9F%E5%91%BD/"},{"name":"记忆","slug":"记忆","permalink":"https://lison.cc/tags/%E8%AE%B0%E5%BF%86/"}],"author":"Lison"},{"title":"Android自动化测试工具-monkey使用记录","slug":"android-monkey","date":"2014-12-04T09:46:49.000Z","updated":"2023-11-16T06:15:51.362Z","comments":true,"path":"android-monkey/","link":"","permalink":"https://lison.cc/android-monkey/","excerpt":"早上开始写新功能之前，在物理机上测试了一下昨天修改的程序。发现MainActivity加载之后，几个tab选项卡的切换顺序会导致程序崩溃（tab选项卡切换导致viewpager切换不同的fragment），而且不是每次都出现，难道是我手慢了？","text":"早上开始写新功能之前，在物理机上测试了一下昨天修改的程序。发现MainActivity加载之后，几个tab选项卡的切换顺序会导致程序崩溃（tab选项卡切换导致viewpager切换不同的fragment），而且不是每次都出现，难道是我手慢了？ 查看logcat之后发现是有一处空指针异常，Simple&amp;Bold的if null判断之后，好像不崩溃了。 于是来回启动、结束任务、tab来回切换，不崩溃了。 真的不崩溃了？万一出现比我手还快的高人怎么办，哈哈哈。 想起之前网易公开课中看到@Sunday讲师的《Android深入浅出》中介绍的一个自动化测试工具：monkey。貌似是adb自带的，原理好像就是随机取坐标点，然后按下这样的测试方法，名字取得很形象，挺有意思的。 刚好可以拿来用一下，不过adb命令既不清楚了，问了下度娘，做下记录。 通常调试android程序时可能开几个模拟器，不同版本的，不同尺寸的。 于是 1adb devices 会列出当前已经bridged的设备列表，如图： 要与指定设备连接，比如上面那个I699，屌丝气无处不在。。。。 1adb -s I6996s712ffb shell 要与指定设备连接，并且使用monkey调试指定的程序（包） 1adb -s I6996s712ffb shell monkey -p com.tech.impulsefitness -v 1000 然后猴子就开始乱抓了，会抓1000次 部分内容引自：http://blog.csdn.net/lijiecong/article/details/4496938","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://lison.cc/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"author":"Lison"},{"title":"C# FileSystemWatcher 监视磁盘文件变更（原创）","slug":"csharp-filesystem-watcher","date":"2014-11-18T09:23:29.000Z","updated":"2023-11-16T06:15:51.591Z","comments":true,"path":"csharp-filesystem-watcher/","link":"","permalink":"https://lison.cc/csharp-filesystem-watcher/","excerpt":"简化需求有一个简化了的需求是这样的：有一个拍照程序在运行，一旦抓拍之后则将图片文件存储至某目录，然后图片要上传至远程服务器并update数据库。","text":"简化需求有一个简化了的需求是这样的：有一个拍照程序在运行，一旦抓拍之后则将图片文件存储至某目录，然后图片要上传至远程服务器并update数据库。 原需求原先的需求是这样的：有一台PDA扫码枪，一个IP照相机放置在下线区传送带上方。当PDA扫描箱子上的条码，触发相机拍照，将图片流传至远端服务器，找到对应的条码，将图片存储并更新数据库。 然而我不知道PDA扫描的瞬间如何与IP相机通信（蓝牙或WLAN？），其实关键是我不知道怎样使用IP相机的外触发功能，增加蓝牙触发器？也不知道怎样hack或ssh到这个相机（应该是linux的吧），所以只能先使用简化需求的版本。 而简化需求的版本，关键就是监视文件夹内容变化与上传文件流。 昨天问了下度娘，C#中的监视组件名字叫做FileSystemWatcher。 于是写了个demo，可以监视所有逻辑盘或者某个文件夹。 使用方法： 直接打开是监视所有逻辑磁盘文件变化。 或者传递参数，监视某一路径文件变化。如图，监视e盘 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149namespace FileSystemWatcherDemo&#123; class Program &#123; static void Main(string[] args) &#123; //watcher组 FileSystemWatcher[] watchers; //若未传递参数,则监视所有文件系统,包括CD-ROM（不可用）,可移动磁盘（不可用）等 if (args.Length == 0) &#123; string[] drivers = Directory.GetLogicalDrives(); watchers = new FileSystemWatcher[drivers.Length]; for (int i = 0; i &lt; drivers.Length; i++) &#123; try &#123; watchers[i] = new FileSystemWatcher &#123; Path = drivers[i] &#125;; &#125; catch (Exception ex) &#123; Trace.TraceWarning(ex.Message); &#125; &#125; &#125; else &#123; watchers = new FileSystemWatcher[1]; watchers[0] = new FileSystemWatcher &#123; Path = args[0] &#125;; &#125; foreach (FileSystemWatcher w in watchers) &#123; if (w == null) continue; w.Filter = &quot;*&quot;; w.IncludeSubdirectories = true; w.EnableRaisingEvents = true; w.Created += onFileSystem_Changed; w.Deleted += onFileSystem_Changed; w.Changed += onFileSystem_Changed; w.Renamed += watcher_Renamed; &#125; Console.ReadLine(); &#125; #region [ 检测文件是否占用 ] /// &lt;summary&gt; /// 检测文件是否占用 /// &lt;/summary&gt; /// &lt;param name=&quot;filename&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsFileReady(string filename) &#123; var fi = new FileInfo(filename); FileStream fs = null; try &#123; fs = fi.Open(FileMode.Open, FileAccess.Read, FileShare.None); return true; &#125; catch (IOException) &#123; return false; &#125; finally &#123; if (fs != null) fs.Close(); &#125; &#125; #endregion private static volatile object _lock = true; static void onFileSystem_Changed(object sender, FileSystemEventArgs e) &#123; lock (_lock) &#123; Console.ForegroundColor = ConsoleColor.DarkGray; Console.Write(&quot;[&quot;); Console.Write(DateTime.Now.ToString(&quot;HH:mm:ss&quot;)); Console.Write(&quot;] &quot;); switch (e.ChangeType.ToString().ToLower()) &#123; case &quot;created&quot;: //while (!IsFileReady(e.FullPath)) //&#123; // if (!File.Exists(e.FullPath)) // return; // Thread.Sleep(100); //&#125; Console.ForegroundColor = ConsoleColor.Green; Console.Write(e.ChangeType); Console.ForegroundColor = ConsoleColor.White; Console.Write(&quot; &quot;); Console.Write(e.Name); Console.Write(&quot; &quot;); Console.ForegroundColor = ConsoleColor.DarkGray; Console.Write(e.FullPath); break; case &quot;deleted&quot;: Console.ForegroundColor = ConsoleColor.Red; Console.Write(e.ChangeType); Console.ForegroundColor = ConsoleColor.White; Console.Write(&quot; &quot;); Console.Write(e.Name); Console.Write(&quot; &quot;); Console.ForegroundColor = ConsoleColor.DarkGray; Console.Write(e.FullPath); break; case &quot;changed&quot;: Console.ForegroundColor = ConsoleColor.Cyan; Console.Write(e.ChangeType); Console.ForegroundColor = ConsoleColor.White; Console.Write(&quot; &quot;); Console.Write(e.Name); Console.Write(&quot; &quot;); Console.ForegroundColor = ConsoleColor.DarkGray; Console.Write(e.FullPath); break; &#125; Console.Write(&quot;\\r\\n&quot;); &#125; &#125; static void watcher_Renamed(object sender, RenamedEventArgs e) &#123; Console.ForegroundColor = ConsoleColor.Magenta; Console.Write(e.ChangeType); Console.ForegroundColor = ConsoleColor.White; Console.Write(&quot; &quot;); Console.Write(e.OldName); Console.Write(e.OldFullPath); Console.ForegroundColor = ConsoleColor.Yellow; Console.Write(&quot; &quot;); Console.Write(e.Name); Console.Write(e.FullPath); Console.Write(Thread.CurrentThread.Name); Console.Write(&quot;\\r\\n&quot;); &#125; &#125;&#125; 仍有bug，望高手指正。 附上编译好的exe，可以直接运行。 文章最初发表于博客园：http://www.cnblogs.com/LisonLiou/p/filesystemwatcher.html","categories":[{"name":"csharp","slug":"csharp","permalink":"https://lison.cc/categories/csharp/"}],"tags":[{"name":"文件监视器","slug":"文件监视器","permalink":"https://lison.cc/tags/%E6%96%87%E4%BB%B6%E7%9B%91%E8%A7%86%E5%99%A8/"}],"author":"Lison"},{"title":"惊惶 ● 沼泽","slug":"hesitation-marsh","date":"2014-11-06T09:17:47.000Z","updated":"2023-11-16T06:15:51.611Z","comments":true,"path":"hesitation-marsh/","link":"","permalink":"https://lison.cc/hesitation-marsh/","excerpt":"","text":"无论我裹着多少衣裳 也掩藏不住我的惊惶 无论你笑得多么温柔 也抑压不住你的悲伤 可你说前面多少荆棘 也阻挡不住你的勇气 无论我变得多么脆弱 也摧毁不了你的执着 爱会超越 一切藩篱 可我竟怀疑 爱会治愈 一切所有伤痛 我却轻易放弃 爱会超越 一切藩篱 可我竟怀疑 爱会治愈 所有伤痛 我却轻易放弃 woo huh… 爱就是奇迹 你就是希冀 我却没有勇气 Please please please forgive me Oh no Don’t give up 我却没有勇气 《惊慌》—–沼泽 与confess篇出一辙；多感，轻呼唤。愿快些停下所有unreadable的 伤害。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[],"author":"Lison"},{"title":"Apache反向代理Discuz地址有问题的解决方法","slug":"apache-setup-reverse-proxy","date":"2014-11-06T09:14:04.000Z","updated":"2023-11-16T06:15:51.371Z","comments":true,"path":"apache-setup-reverse-proxy/","link":"","permalink":"https://lison.cc/apache-setup-reverse-proxy/","excerpt":"机器A拥有外网ip，机器B处于内网。 机器A运行apache，本地程序，开放80端口，并且作为代理服务器处理外部泛解析域名，例如bbs.lison.com。并且解析到机器B的端口8090。 机器B运行nginx，处理8090端口的web服务。","text":"机器A拥有外网ip，机器B处于内网。 机器A运行apache，本地程序，开放80端口，并且作为代理服务器处理外部泛解析域名，例如bbs.lison.com。并且解析到机器B的端口8090。 机器B运行nginx，处理8090端口的web服务。 部署成功后，出现的问题是：访问bbs.lison.com之后，页面能打开，但是样式无法加载，查看源代码发现，依然是机器B的内网地址端口号。 这个问题困扰了我好几天，直到今天看到大神的文章： Apache反向代理Discuz出现“您的请求来路不正确”解决办法 http://rayyn.net/2010/06/37.html","categories":[{"name":"nginx","slug":"nginx","permalink":"https://lison.cc/categories/nginx/"}],"tags":[{"name":"apache","slug":"apache","permalink":"https://lison.cc/tags/apache/"}],"author":"Lison"},{"title":"android模拟器Genymotion关于Unknown generric error的错误","slug":"solved-genymotion-unkown-generic-error","date":"2014-10-24T09:08:36.000Z","updated":"2023-11-16T06:15:51.685Z","comments":true,"path":"solved-genymotion-unkown-generic-error/","link":"","permalink":"https://lison.cc/solved-genymotion-unkown-generic-error/","excerpt":"app在安卓2.3的机器上运行的好好的，到了4.4模拟器上（卡的要死）就报错误，看来下logCat说是网络错误，ksoap2报的错，百度了下之后找到问题，4.4之后要求将耗时操作脱离UI线程，之前的逻辑写在Runnable里，ok于是new Thread问题解决，不过今天可不是要说这个。","text":"app在安卓2.3的机器上运行的好好的，到了4.4模拟器上（卡的要死）就报错误，看来下logCat说是网络错误，ksoap2报的错，百度了下之后找到问题，4.4之后要求将耗时操作脱离UI线程，之前的逻辑写在Runnable里，ok于是new Thread问题解决，不过今天可不是要说这个。 中间测试用的ADT自带的模拟器，真的是要卡出翔的节奏。模拟器卡连着宿主机也开始卡，之前装过Genymotion，只新建了一个2.3的模拟器，之前有次想创建个4.4的结果登录不上，没管它，心想现在一款机器上搞定再说，于是搞定之后在别的机器上测试出问题，就是上面说的。 所以引出了问题，我要用这个又快又帅的Genymotion中创建其他版本的安卓模拟器。 ok，打开Genymotion，点击添加按钮，提示要登录，那就登录吧，之前已经缓存了我的账号跟密码（免费的），点击登陆之后，弹出错误，如图： ok，一般性错误，怎么个意思，什么是一般性错误，于是查了查，直接说Unknown generic error的好像没有，但是有说云端不能登陆的，ok，这就是我想要的。 云端不能登陆？不就是我被墙了？于是打开自由门，再次登陆还是Unknown generic error。这是怎么回事。 然后在这里找到了答案 http://www.pczhishi.cn/jishu/guzhang/147.html 然后代理哪里找？自由门就是个代理。。。 然后下面就简单了，设置好ip，登录，选择版本，开始下载。。。","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"sqlite错误：no such column named xxx 找不到数据列错误","slug":"sqlite-no-colume-named","date":"2014-10-17T09:02:31.000Z","updated":"2023-11-16T06:15:51.854Z","comments":true,"path":"sqlite-no-colume-named/","link":"","permalink":"https://lison.cc/sqlite-no-colume-named/","excerpt":"报错信息一眼就能看出来，找不到数据列。为什么onCreate中的create表语句明明有这一列啊.schema表结构也明明有啊。","text":"报错信息一眼就能看出来，找不到数据列。为什么onCreate中的create表语句明明有这一列啊.schema表结构也明明有啊。 以下是发表在marschen.com的求助帖： 报的错误信息很简单，找不到名为imageUrl的数据列10-16 16:02:38.659: E/AndroidRuntime(17154): android.database.sqlite.SQLiteException: no such column: imageUrl: , while compiling: SELECT id, imageTitle, imageUrl, imageData, showOrder, createDate, createTime FROM carrousel ORDER BY showOrder asc 但是我用DDMS拿出.db之后查看表结构，没问题啊。及截图： .schema tableName 然后自己回复了主题： 我想我知道了原因。。。数据库表onCreate了之后，如果版本不变化的话，就不会再执行了，无论你怎么在eclipse里修改，所以表结构要变更版本号，并且在onUpdate中做处理，或者Alter表结构，或者Drop旧表，create新表。 附上一张代码截图：后面的盆友，此处有坑，小心呐。。。。。。。。。。。。。及截图： onUpdate更新本地表结构截图","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"sqlite","slug":"sqlite","permalink":"https://lison.cc/tags/sqlite/"}],"author":"Lison"},{"title":"认识java杂记-基础知识（概念）","slug":"java-basic","date":"2014-08-24T08:56:44.000Z","updated":"2023-11-16T06:15:51.625Z","comments":true,"path":"java-basic/","link":"","permalink":"https://lison.cc/java-basic/","excerpt":"","text":"继承关键字使用extends 而.NET中使用冒号 : 抽象类型。使用abstract关键字修饰的class只能new它的衍生类（子类），抽象方法只能在抽象类中创建。继承抽象类后，必须实现抽象方法，或者将方法也修饰为abstract。通过抽象方法，可以将方法置入接口中，而无需编写主体代码。 OOP (Object Oriented Programming) 面向对象编程 上溯造型 UpCasting，原来是装箱的意思；下溯造型DownCasting，原来是拆箱的意思。翻译不同的结果吧。 违例（Exception）；异常。翻译不同的结果。 synchronized 内存锁关键字（多线程），一般修饰对象（方法）；其他类型的锁一般为创建一个对象，用它代表一把锁,所有线程在访问那个资源时都必须检查这把锁。 Servlet &amp; Applet javadoc，注释提取工具（生成html） 关于protected关键字：基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类。 关于public关键字：每个编译单元（文件）都只能有一个public类。这表示，每个编译单元都有单一的公共接口，用public类来实现。public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。 关于this关键字： 1234567891011121314151617181920//: initialization/Leaf.java//Simple use of &quot;this&quot; keywordpublic class Leaf &#123; int i = 0; Leaf increment() &#123; i++; return this; &#125; void print() &#123; System.out.println(&quot;i = &quot; + i); &#125; public static void main(String[] args) &#123; Leaf x=new Leaf(); x.increment().increment().increment().print(); &#125; 由于increment()通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作。","categories":[{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"}],"author":"Lison"},{"title":"Holy Hill","slug":"holy-hill","date":"2014-08-05T08:41:14.000Z","updated":"2023-11-16T06:15:51.615Z","comments":true,"path":"holy-hill/","link":"","permalink":"https://lison.cc/holy-hill/","excerpt":"图自网易LOFTER社区","text":"图自网易LOFTER社区 may be you would say 我的意中人是个盖世英雄，有一天他会踩着七色的云彩来娶我，我猜中了前头，可是我猜不着这结局……","categories":[{"name":"旅行","slug":"旅行","permalink":"https://lison.cc/categories/%E6%97%85%E8%A1%8C/"}],"tags":[{"name":"心灵","slug":"心灵","permalink":"https://lison.cc/tags/%E5%BF%83%E7%81%B5/"}],"author":"Lison"},{"title":"debian安装google-chrome","slug":"install-chrome-on-debian7","date":"2014-07-25T08:36:51.000Z","updated":"2023-11-16T06:15:51.624Z","comments":true,"path":"install-chrome-on-debian7/","link":"","permalink":"https://lison.cc/install-chrome-on-debian7/","excerpt":"还是简单的记录下吧，两天前刚装的今天又忘了。","text":"还是简单的记录下吧，两天前刚装的今天又忘了。 首先得到*.deb的压缩包，无论是从google.com还是google.com.hk。其实比较靠谱的还是： For 32 bit: wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb ​ For 64 bit: wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb #通常，这个地址也能打开：http://www.google.cn/chrome/（手动下载地址） 执行安装命令 sudo dpkg -i ./google-chrome-stable_current_i386.deb 如果有遇到错误提示，直接执行以下命令来安装chrome浏览器需要的类库。 sudo apt-get -f install 文章出自：www.freehao123.com/linux-chrome/ 免费资源部落","categories":[{"name":"linux","slug":"linux","permalink":"https://lison.cc/categories/linux/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"记 · 真机安装Debian7","slug":"how-to-install-debian7-on-physical-computer","date":"2014-07-18T08:32:35.000Z","updated":"2023-11-16T06:15:51.617Z","comments":true,"path":"how-to-install-debian7-on-physical-computer/","link":"","permalink":"https://lison.cc/how-to-install-debian7-on-physical-computer/","excerpt":"有废旧电脑一只，屏幕边上的塑料磕掉了一块，电池再也充不进电，喇叭还呲呲响，不过重要的是：还能用！！！ 方正OEM的外国垃圾（都怪我年幼不懂事）。1G内存，1.几GHz的奔腾CPU，160G硬盘，好像还独立显卡。这个配置运行个Debian7应该木有问题，于是乎，开搞吧。","text":"有废旧电脑一只，屏幕边上的塑料磕掉了一块，电池再也充不进电，喇叭还呲呲响，不过重要的是：还能用！！！ 方正OEM的外国垃圾（都怪我年幼不懂事）。1G内存，1.几GHz的奔腾CPU，160G硬盘，好像还独立显卡。这个配置运行个Debian7应该木有问题，于是乎，开搞吧。 目的旧电脑搞起来，要搞就搞大的，搞起来搞起来~~~。之前一直使用虚拟机下运行eclipse（学点安卓），为什么，因为我喜欢linux。linux+ADT+Git，一切都在学习摸索中前进。 然后就是装系统了，手头上没有空的DVD盘（有也不想刻啦），于是找来U盘开搞，把U盘给引导了，iso文件写进去，用到了这个工具：Universal-USB-Installer，选择要写入镜像的盘符，千万别选错了，后果你知道的，然后选择要写入的iso文件路径，确定之后一切就那么开始了。 其他的不多记录了，windows下的东西用起来都比较方便的。 然后我使用的Debian是这个debian-7.6.0-i386-netinst 安装的过程也比较简单，高人们说安装的时候尽量选英文，不选择更新系统，其他的等装完系统再说。 而我在最后选择服务器类型的时候，选择了webserver和database server之后，告诉我剩余安装时间为1dxxhhxxMM，当时就想哭了。。。没办法只好睡觉时候开着机器，第二天早上起来看看才装完。 最后来张图吧，最近no pic you say ge jb挺火啊。。。","categories":[{"name":"linux","slug":"linux","permalink":"https://lison.cc/categories/linux/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"青","slug":"qing-play","date":"2014-07-18T07:56:38.000Z","updated":"2023-11-16T06:15:51.647Z","comments":true,"path":"qing-play/","link":"","permalink":"https://lison.cc/qing-play/","excerpt":"","text":"你来了，他走了。你走了，他却在原地痴痴地等。这一生中，总会有一个人，老是跟你过不去，而你，却很想跟他过下去。爱情很短，短到只剩下一个擦肩，而痴情却很长，长到我们往往要付出灵魂中的地老天荒。 图自网易摄影，© Insecte venimeux 戲如人生 http://pp.163.com/ivan-z-yeah/pp/4635059.html#22746605","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"生人","slug":"生人","permalink":"https://lison.cc/tags/%E7%94%9F%E4%BA%BA/"}],"author":"Lison"},{"title":"When I hear Green Day on classic rock radio.","slug":"when-i-hear-green-day-on-classic-rock-radio","date":"2014-06-20T07:54:12.000Z","updated":"2023-11-16T06:15:51.868Z","comments":true,"path":"when-i-hear-green-day-on-classic-rock-radio/","link":"","permalink":"https://lison.cc/when-i-hear-green-day-on-classic-rock-radio/","excerpt":"","text":"","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"OLD","slug":"OLD","permalink":"https://lison.cc/tags/OLD/"}],"author":"Lison"},{"title":"缘来里linux中的环境变量中间用的是冒号:不是分号啊尼玛","slug":"linux-get-env-ready","date":"2014-06-11T07:49:47.000Z","updated":"2023-11-16T06:15:51.633Z","comments":true,"path":"linux-get-env-ready/","link":"","permalink":"https://lison.cc/linux-get-env-ready/","excerpt":"","text":"我次奥你爱改 1./etc/profile你就改profile啊 2.~/.bashrc 3.~/.bash_profile 4./etc/.bashrc 我也不知道是哪个啊，我只知道要把这个加进去啊： export PATH=”$PATH:/usr/software/xxxxx” 一定看清中间用的是**:**而不是;尼玛瘟到死才用;啊，次奥搞了我半晚上啊。","categories":[{"name":"linux","slug":"linux","permalink":"https://lison.cc/categories/linux/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"}],"author":"Lison"},{"title":"Android异步机制与消息传递的学习笔记","slug":"android-send-message-async","date":"2014-06-05T07:45:15.000Z","updated":"2023-11-16T06:15:51.365Z","comments":true,"path":"android-send-message-async/","link":"","permalink":"https://lison.cc/android-send-message-async/","excerpt":"什么是异步?异步就是不同步,同步是什么?同步比如排队上厕所,前面的没执行完,后边的就别想执行,不执行怎么办,快憋死了(窗体假死了),哈哈哈. 异步是什么,异步好比发短信,短信发出去了,我就不管了,至于你收没收到看没看到反应如何,我不需要等待,我只是发完短信然后干别的事了,不阻塞.","text":"什么是异步?异步就是不同步,同步是什么?同步比如排队上厕所,前面的没执行完,后边的就别想执行,不执行怎么办,快憋死了(窗体假死了),哈哈哈. 异步是什么,异步好比发短信,短信发出去了,我就不管了,至于你收没收到看没看到反应如何,我不需要等待,我只是发完短信然后干别的事了,不阻塞. 很多程序都是单线程,事件顺序执行,因为事件或者交互每次的处理时间很短,不会给用户造成阻塞或者反应迟钝的错觉,比如点击了一下按钮,都是很短的时间. 但是有些处理是比较耗时的,比如我打开了一个app,app去检测服务器有没有新版本,这时我应该是继续在操作的.写过网络检测的盆友都知道,检测新版本之前首先检测网络是否连通,而检测网络状况就是一个比较耗时的操作,不能让用户等待,所以多数程序选择在夜(后)里(台)悄悄的检测版本更新,下载新版本,下次运行app的时候提示安装新版本,我想这大概就是异步了吧. 我要做什么:模拟一个耗时操作并且用户可以继续与当前的UI产生交互. 我到底要做什么:我有一个ProgressBar,它正在运行,我来继续操作UI(或者程序继续操作) 再明确一点:ProgressBar进度在增长,另有TextView值变化,两个互不影响. 涉及到的Android对象： 1. Handler 2. Message 3. Runnable","categories":[{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"}],"author":"Lison"},{"title":"If i lay here, if i just lay here. Would you lay with me just forget the world","slug":"if-i-lay-here","date":"2014-05-27T07:41:36.000Z","updated":"2023-11-16T06:15:51.624Z","comments":true,"path":"if-i-lay-here/","link":"","permalink":"https://lison.cc/if-i-lay-here/","excerpt":"","text":"We’ll do it allEverythingOn our own We don’t needAnythingOr anyone If I lay hereIf I just lay hereWould you lie with me and just forget the world? I don’t quite knowHow to sayHow I feel Those three wordsAre said too muchThey’re not enough If I lay hereIf I just lay hereWould you lie with me and just forget the world? Forget what we’re toldBefore we get too oldShow me a garden that’s bursting into life Let’s waste timeChasing carsAround our heads I need your graceTo remind meTo find my own If I lay hereIf I just lay hereWould you lie with me and just forget the world? Forget what we’re toldBefore we get too oldShow me a garden that’s bursting into life All that I amAll that I ever wasIs here in your perfect eyes, they’re all I can see I don’t know whereConfused about how as wellJust know that these things will never change for us at all If I lay hereIf I just lay hereWould you lie with me and just forget the world? ————–《Chasing Cars》————– SNOW PATROL","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"melody","slug":"melody","permalink":"https://lison.cc/tags/melody/"}],"author":"Lison"},{"title":"Raspberry Pi 树莓派GPIO学习 – 控制家用电灯","slug":"raspberry-pi-control-bulb","date":"2014-04-28T07:26:23.000Z","updated":"2023-11-16T06:15:51.665Z","comments":true,"path":"raspberry-pi-control-bulb/","link":"","permalink":"https://lison.cc/raspberry-pi-control-bulb/","excerpt":"如果不是那天偶然看到有位盆友在炫耀他的新技能：用树莓派通过Java实现远程控制电灯，上次购置折腾系列配件的时候也不会多买一个继电器，ok，既然买了，就把他折腾起来。","text":"如果不是那天偶然看到有位盆友在炫耀他的新技能：用树莓派通过Java实现远程控制电灯，上次购置折腾系列配件的时候也不会多买一个继电器，ok，既然买了，就把他折腾起来。 目的用程序控制家用灯泡，好像很酷的样子。 准备材料 树莓派一只 5V低电平继电器扩展版 家用灯泡一只 公对母杜邦线三根 面包板一块（可无） 普通电线一段，用于连接灯泡 先来张图 原理图是很简单的，继电器扩展版上低电端有三个引脚，分别是VCC、GND、IN，名词解释为：电源，接地，输入引脚。 简单的连线图（Fritzing还不会用）： 所用继电器扩展版 VCC接树莓派5V针脚（红色）GND 接树莓派GND针脚（棕色）IN接树莓派GPIO25，或者其他的GPIO也可以，只要与程序控制的pin脚是一致的（橙色） ** 红色、棕色、橙色的杜邦线接法与下图“面包板接线图”是一致的 ** 接好之后继电器扩展版的电源灯是亮的（红色LED） 这是继电器的玉照，有必要说明一下三个端点，常开、公共、常闭。 常开，正常状态为开路（开路即断开的），通电后关闭（连通）公共端，顾名思义常闭，正常状态为闭合（连通状态），通电后断开（开路） 因此，继电器是没有正负极之分，正负极可以任意接在常开或常闭，是否有电流通过取决于当前低电端给予的电平情况。 PS：接入家用电之后，强电端与继电器扩展版底部都是有电的，需谨慎操作，不幸的我就被电过一次，所以折腾的时候请小心。 再来张面包板的接线图： 很简单，没什么多说的，关于上图中针脚p*与GPIO对应关系，参考这里的关系图：http://lison.cc/raspberry-pi-control-led/ 最终要实现的开关效果并不是带有ON/OFF的那种，往上按开，往下按关，而是类似电脑的开机键，按一下开，再按一下关。（有谁知道这种开关专业名称叫什么，老师说过，不过我忘了） 具体实现原理是读取GPIO针脚的电平状态，如果高电，说明已经打开，此时需关闭；如果低电，说明已经关闭，此时需打开。 程序中没有用到循环，而是执行一次开，再执行一次关。 还是直接贴代码： 唯一注意一点是为GPIO口设置高低电平时需先设置pin的模式，INPUT/OUTPUT。wiringPi的官方资料还是要仔细看看的。 演示视频 后记视频最后没有录制完，最后使用手机安装ConnectBot，可以远程用putty连接树莓派，并执行sudo ./light，从而以另一种欺骗的方式实现手机远程智能家居，以后研究一下android做个app控制家用电器。 参考文章：http://wiringpi.com/reference/core-functions/http://cafe.miwor.com/SAH/12.html 树莓派编号引脚说明：http://blog.csdn.net/jcdjx/article/details/41866219","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"如果在赌气的生活工作，我是不是会输掉一些事，一些时间","slug":"piqued-life","date":"2014-04-27T07:22:13.000Z","updated":"2023-11-16T06:15:51.642Z","comments":true,"path":"piqued-life/","link":"","permalink":"https://lison.cc/piqued-life/","excerpt":"","text":"热狗说，当兴趣不再是兴趣，或许变成一种谋生的工具，我该怎么看我自己。 一路向前，从来没有回头看过走过的路，脚下的印记也不知是深是浅，这一路，是否踏实，我不清楚。 一直有两种处事心态在挣扎，perfect和得过且过。英雄是不问出处，但是成为英雄的路，没有人会问起。 或许该放下互相攀比的心态，人各有志，人各有名。放下计较，做简单的我，三亩良田，我可以过的不错，过的对得起。 烦乱的思绪太多，何时会有结果，我该做考虑。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"生活作业","slug":"生活作业","permalink":"https://lison.cc/tags/%E7%94%9F%E6%B4%BB%E4%BD%9C%E4%B8%9A/"}],"author":"Lison"},{"title":"树莓派获取主板温度并采用图标显示","slug":"raspberry-pi-get-temp-board","date":"2014-04-26T07:09:50.000Z","updated":"2023-11-16T06:15:51.672Z","comments":true,"path":"raspberry-pi-get-temp-board/","link":"","permalink":"https://lison.cc/raspberry-pi-get-temp-board/","excerpt":"记录今天在淅淅沥沥的小雨下宅了一天的，算是收获吧。 之前就看到有文章写道利用树莓派系统内置命令获取主板温度的方法，由于处于学习阶段，只是尝试了一下获取温度重定向到另外的输出文件就停止了，今天没事做，于是就戳了一下相关的功能。","text":"记录今天在淅淅沥沥的小雨下宅了一天的，算是收获吧。 之前就看到有文章写道利用树莓派系统内置命令获取主板温度的方法，由于处于学习阶段，只是尝试了一下获取温度重定向到另外的输出文件就停止了，今天没事做，于是就戳了一下相关的功能。 目的获取树莓派主板的温度，并在页面上以图标的方式展现出来。 涉及知识（都是入门级的）linux进程与系统调用linux下文件操作**文件描述表**进程标准输入、输出、重定向jQuery+HighCharts图表插件 直接贴代码吧，搞完了剪头去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//默认执行的秒数#define TIMES 60//默认输出的文件路径#define LOGFILE &quot;temperature.log&quot;//第一个参数为执行的秒数//第二个参数为重定向到新文件的路径（名称）int main(int argc,char *argv[]) &#123; int times=TIMES; FILE *f_log; //初始化执行的次数 if(argv[1]!=NULL) times=atoi(argv[1]); //打开文件指针 if(argv[2]!=NULL) f_log=fopen(argv[2],&quot;a+&quot;); else f_log=fopen(LOGFILE,&quot;a+&quot;); //将默认输出管道重定向至文件指针，f_temp dup2(fileno(f_log),1); while(times&gt;0) &#123; //system调用系统文件，默认输出将重定向至文件指针指向的文件 //获取主板温度 system(&quot;/opt/vc/bin/vcgencmd measure_temp&quot;); //获取系统时间 system(&quot;date&quot;); printf(&quot;%d\\n&quot;,times); times--; sleep(1); &#125; //关闭文件指针 fclose(f_log); return 0;&#125; 编译与调用：make pi_temp &amp;&amp; ./pi_temp 60 temperature2.log 参数解释：60表示会执行60次，也就是60秒 temperature2.log 获取主板温度之后的数据将输出到此文件中 等待60秒之后，*.log中的内容看起来是这样的：（请自动忽略时间部分） **temp=45.5’C** Sat Apr 26 15:31:26 HKT 2014temp=44.9’CSat Apr 26 15:31:27 HKT 2014temp=45.5’CSat Apr 26 15:31:28 HKT 2014temp=44.9’CSat Apr 26 15:31:29 HKT 2014temp=44.9’CSat Apr 26 15:31:30 HKT 2014temp=44.9’CSat Apr 26 15:31:31 HKT 2014 把这些内容复制到：http://lison.cc/pi_temp/temp.html 这个页面的文本框中，点击提交按钮，图标会根据数据展示特定时间内的温度变化曲线，如图： 后续1.既然能够获取主板温度，是不是也可以获取CPU温度等其他温度，如果可以的话，可以获取内容在同一图表进行展现。 2.既然能够获取这些温度，就可以外接风扇，监控温度，若超过设定值，自动开启风扇进行散热了，有时间再戳吧。 代码格式有点乱，直接来个图吧： 改进版的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;//默认执行的秒数#define TIMES 60//默认输出的文件路径#define LOGFILE “temperature.log”//循环条件，传入-1将无限循环#define LOOPCONDITION(x)(x==-1?1:x)//显示错误信息并退出程序void error(char *msg) &#123; puts(msg); exit(1);&#125;/** argc 执行的秒数（次数）* argv 重定向到新文件的路径（名称）*/int main(int argc,char *argv[]) int times; FILE *f_log; if(argc==1) times=TIMES; f_log=fopen(LOGFILE,”a+”); &#125; else if(argc==2) &#123; //初始化执行的次数 if(atoi(argv[1])) times=atoi(argv[1]); else fopen(argv[1],”a+”); &#125; else if(argc==3) if(atoi(argv[1])) times=atoi(argv[1]); else error(“Invalid times formate”); f_log=fopen(argv[2],”a+”); &#125; else error(“Unkow argument format”); //克隆当前进程，产生子进程 pid_t pid=fork(); if(pid==-1) error(“Cannot fork process”); //创建父子进程连接管道 int fd[2]; if(pipe(fd)==-1) error(“Cannot create pipe”); //子进程 if(!pid) //关闭子进程的输入管道 close(fd[0]); //将子进程的输出管道重定向到f_log的输入管道 dup2(fileno(f_log),1);&#125; int status; while(LOOPCONDITION(times)) //system调用系统文件，默认输出将重定向至文件指针指向的文件 //获取主板温度 system(“/opt/vc/bin/vcgencmd measure_temp”); //获取系统时间 system(“date”); times–; sleep(1); &#125; //关闭文件指针 fclose(f_log); return 0;&#125;","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"安乐死","slug":"i-cant-stay","date":"2014-04-22T07:03:12.000Z","updated":"2023-11-16T06:15:51.621Z","comments":true,"path":"i-cant-stay/","link":"","permalink":"https://lison.cc/i-cant-stay/","excerpt":"","text":"今，沉溺于此，享安逸，受怠慢，忍傻子，混日子。明，沉闷，迂腐，势力，胆怯，混沌，空洞，市井，失明。","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"生活作业","slug":"生活作业","permalink":"https://lison.cc/tags/%E7%94%9F%E6%B4%BB%E4%BD%9C%E4%B8%9A/"}],"author":"Lison"},{"title":"Raspberry Pi 树莓派GPIO学习 - wiringPi控制LED灯闪烁","slug":"raspberry-pi-control-led","date":"2014-04-15T09:47:58.000Z","updated":"2023-11-16T06:15:51.667Z","comments":true,"path":"raspberry-pi-control-led/","link":"","permalink":"https://lison.cc/raspberry-pi-control-led/","excerpt":"","text":"目的用树莓派点亮LED，并控制LED灯的亮与灭。准备材料硬件LED灯一只220欧姆电阻一只树莓派一只母对母杜邦线三根 软件 wiringPi，开源树莓派GPIO操作库，C语言版，安装方法：http://blog.csdn.net/xukai871105/article/details/17737005 今晚是第二次折腾树莓派的GPIO口，昨晚没搞定，因为完全没有仔细看wiringPi与GPIO对应图： 举个栗子3.3v是树莓派26个针脚的第一个，6是GND口，1口+6口接通LED灯是亮的，这是普通的电流回路，但是无法通过高低电平控制，也就无法通过程序控制。可以看到上图中3.3v对应wiringPi Pin中都是“—“，姑且理解为不使用吧。而wiringPi的pin是从GPIO1开始的，上图中的第六行第五列，wiringPi是1，这个1就是程序可以控制高低电平的。这就是树莓派的GPIO与wiringPi的对应关系。 程序代码：[ 编译运行，引用wiringPi库，位于/usr/local/lib：gcc blink.c -o blink -lwiringPisudo ./blink 演示视频 结论昨晚x宝来货，于是开始戳树莓派的GPIO口，正极接了3.3V，负极接了GND，灯亮了，很开心。但是wiringPi控制的digitalWrite却始终没反应，终了，搞不定，不能睡太晚，还要赶班车，于是便睡下了。[ 是的，走马观花注定一事无成。]","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lison.cc/tags/linux/"}],"author":"Lison"},{"title":"恳願我們相互體諒和相互原諒一切","slug":"forgive-you-forgive-me","date":"2014-04-13T09:43:10.000Z","updated":"2023-11-16T06:15:51.606Z","comments":true,"path":"forgive-you-forgive-me/","link":"","permalink":"https://lison.cc/forgive-you-forgive-me/","excerpt":"杜夢,豆瓣小站","text":"杜夢,豆瓣小站","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"},{"name":"melody","slug":"melody","permalink":"https://lison.cc/tags/melody/"}],"author":"Lison"},{"title":"为你的树莓派设置静态ip","slug":"raspberry-pi-config-static-ip","date":"2014-04-10T09:39:33.000Z","updated":"2023-11-16T06:15:51.661Z","comments":true,"path":"raspberry-pi-config-static-ip/","link":"","permalink":"https://lison.cc/raspberry-pi-config-static-ip/","excerpt":"所以说，不管做什么都不要粗心大意，那些误删文件找不回来挖个洞躲着哭的，那些设置树莓派静态ip漏删了一句话导致pi吃了半个月灰的（冏）。。。","text":"所以说，不管做什么都不要粗心大意，那些误删文件找不回来挖个洞躲着哭的，那些设置树莓派静态ip漏删了一句话导致pi吃了半个月灰的（冏）。。。 自从上次设置树莓派静态ip漏删了一个地方，不能连接树莓派，吃灰了接近两个周，手头又没有显示器，usb转com口折腾来折腾去都是unknow device以来（这句话好长啊），今天上班时发现pi又连不上了，难道是昨天电信给我发了条短信说要维护升级随机重置wlan密码？不对，回来之后发现各种网站还是能上的（除了GF干掉的那些，例如：http://www.google.com/analytics），这是怎么一个回事。 情况是这样的电信疯了我的80端口（草泥煤），遂在路由上做了8000端口转发到192.168.1.104的8000端口（树莓派的ip地址，dhcp的）。 其他端口例如putty的， vnc的也相应都做了转发。 但是我发现情况是这样的光纤猫，路由都正常，唯独树莓派的ip从192.168..1.104变成了192.168.1.100，为什么？不解，难道是路由太寂寞自己重启了导致树莓派dhcp到了新地址？随便了，要不是这个事儿，我还是不会去问度娘：“树莓派静态ip”。 正文終于來了（轉載内容，但根據自身情況修改了一些）1. #vim打開網絡配置的文件 sudo vim /etc/network/interfaces 2. #將其中的文件修改爲**auto lo** iface lo inet loopbackiface eth0 inet static#iface eth0 inet dhcp address 192.168.1.104netmask 255.255.255.0gateway 192.168.1.1 allow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa_supplicant.conf 3. #重啓服務sudo service networking restart 到這裡就搞定，若用putty連接的話，過一會兒會提示連接不上，有可能還要重啓一下pi。 原文地址：http://blog.csdn.net/cxhome213/article/details/8983247","categories":[],"tags":[],"author":"Lison"},{"title":"为树莓派创建内存盘，减少对SD卡寿命的消耗","slug":"raspberry-pi-create-flash-disk","date":"2014-03-10T09:35:25.000Z","updated":"2023-11-16T06:15:51.667Z","comments":true,"path":"raspberry-pi-create-flash-disk/","link":"","permalink":"https://lison.cc/raspberry-pi-create-flash-disk/","excerpt":"看到标题的时候我以为要加个硬件？长的跟小霸王游戏卡似的那种？或者跟windows似的加个U盘、硬盘转换为内存扩展盘？Oh no，我想多了。原来只有一块光棍板的我也可以为SD卡多考虑一下人生后面的事。","text":"看到标题的时候我以为要加个硬件？长的跟小霸王游戏卡似的那种？或者跟windows似的加个U盘、硬盘转换为内存扩展盘？Oh no，我想多了。原来只有一块光棍板的我也可以为SD卡多考虑一下人生后面的事。 mkdir /rammount -t tmpfs -o size=10m,mode=0777 tmpfs /ram 根目录下创建ram目录 挂载ram目录。mount没有用过，只知道这是个挂载命令，挂光驱、挂U盘、挂移动硬盘，有时间再戳它。 以上命令是创建10兆内存盘。根据自己的需求进行调整。 ok, 这篇文章是抄的，原文链接：http://shumeipai.nxez.com/2013/10/04/raspberry-pi-come-in-to-create-a-memory-disk.html 极客范也有： http://www.geekfan.net/6283/","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"为wordpress配置发送邮件功能","slug":"wordpress-config-send-email","date":"2014-03-04T09:25:04.000Z","updated":"2023-11-16T06:15:51.873Z","comments":true,"path":"wordpress-config-send-email/","link":"","permalink":"https://lison.cc/wordpress-config-send-email/","excerpt":"树莓派上搞定wordpress之后，设置了两个强密码，mysql的，pi登录的（为什么是强密码？你懂的），结果登录wordpress后台的时候发现管理员密码忘了，如何办？找回密码吧，于是点击找回密码，填入邮箱之后系统提示我：","text":"树莓派上搞定wordpress之后，设置了两个强密码，mysql的，pi登录的（为什么是强密码？你懂的），结果登录wordpress后台的时候发现管理员密码忘了，如何办？找回密码吧，于是点击找回密码，填入邮箱之后系统提示我： 无法发送电子邮件。可能原因：您的主机禁用了mail()函数。 我次奥，这可如何是好，刚装完而已，当然什么都没配置，什么都没有了，完全一光腚。于是问完度娘问谷歌，做法是直接update数据库表，因为密码是普通的md5加密。。。可我觉得这个方法不大好，于是我想了想，又想起来了。。。 于是我的需求来了：邮件发送功能。 在我忘记密码的时候它，可以发送重置密码邮件到我的秘密邮箱。 在我回复用户的评论的时候用户可以从它的秘密邮箱收到，并且有链接，他可以点击回到网站，增加用户粘性，SEO bla bla bla。。。 需求实现： 度娘跟谷歌很多帖子都说使用插件来搞定： wp-mail-smtp.zip，发邮件的 comment reply notification.zip，评论回复通知的 但这不是我想要的，因为我不是租的空间，我tm有自己的服务器（虽然是小pi），还是电信（你妈逼）专线接入入入入入，我想要的是启用linux（Raspbian）的mail函数数数数数数。。。（突然间爽了） 于是我看了一遍phpinfo(); 发现好像该启的都启了，但是我敲入sendmail却提示我：command not found。这个sendmail字面看来好像就是我要的东西，于是又问度娘，度娘说：看（引用地址）====&gt;http://www.sjyhome.com/wordpress/wp-cant-email.html 原来这厮是要装的啊，原来raspbian里没预置这货啊，那个yum怎么用啊，我这不是cent os啊，debian下用什么命令啊。 ok，raspbian是debian的什么什么儿子，于是问度娘就直接说：debian sendmail（其实我是想知道debian的安装命令是什么，yum不会用啊，我到底要菜刀什么时候啊）。 于是度娘教会我： 部分内容引自：http://www.sjyhome.com/wordpress/wp-cant-email.html（WordPress不能发送邮件，折腾的心酸史） 1. sudo apt-get install sendmail（其实我会用apt-get，不过想不起来了） 2. 重启php-fpm：sudo service /etc/init.d/php5-fpm restart （我的是php5-fpm，跟上面教程的不是很一样，可能版本问题） 3. 查看sendmail是否安装成功：/etc/init.d/sendmail status（没有加sudo），用putty运行的命令，过了很久都没有回应。我没有按Ctrl+C，而是选择了Duplicate Session，登录之后查看了一下/etc/init.d文件夹，发现sendmail安静的躺在那里，我没有作声。心里想，次奥，这到底是成没成功，于是又回到http://lison.cc/wp-login.php，点击了找回密码，又做了一遍最开始的动作，结果在我点击获取新密码按钮火狐的当前标签页转了几秒钟后告诉我： 504 Gateway Time-out nginx/1.2.1 4.于是我又了想起来：wp的后台设置（撰写）邮件服务器的地方还空着，空着。。。一切仿佛又回到了最开始，那天下午。。。 5.后来我设置好了邮件服务器（我确定用户名密码是对的），然后又重复了刚才的找回密码动作：结果还是提示我： 504 Gateway Time-out nginx/1.2.1 我的设置看起来是这样的： 邮件服务器：smtp.qq.com 端口号：110 用户名：&#108;&#105;&#x73;&#111;&#x6e;&#x2e;&#108;&#105;&#111;&#117;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109; 密码：\\********* 难道默认的110端口不行？但是我这里没法启用SSL啊（或者目前我不想启用） 。。。。。。我又走入了误区，全因我不能全神贯注的脑，和走马观花的眼。上面那个第四条对应的功能的是：快速发布，通过邮件发布文章配置的地方，也就是说，我走错门了，不好意思打扰了。 ”那我装完了sendmail（执行sendmail status还是没有反应）要哪里做配置啊“，我是这么问度娘的（保存一下，抽根烟先） 找到教程：http://www.server110.com/sendmail/201308/385.html 原来要加入host：sudo vim /etc/hostname 使其快速生效：sudo hostname -F /etc/hostname 查看是否生效：hostname（没有生效，为什么，不管了） 后面要配置mx转向，我的域名是oray免费赠我的，于是我添加mx纪录：lisonliou.gicp.net:8000，提示我不正确的域名，我早知道免费域名不能那么多功能了，到这里算是真的卡住我了。 哎，还是老老实实的用wp插件吧，一切又回到最开始。。。 PS： 自己的三分小地上做点写点还是挺有意思的","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://lison.cc/categories/wordpress/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"what happen to my hostname (raspberry pi)","slug":"raspberry-pi-hostname","date":"2014-03-03T09:30:14.000Z","updated":"2023-11-16T06:15:51.672Z","comments":true,"path":"raspberry-pi-hostname/","link":"","permalink":"https://lison.cc/raspberry-pi-hostname/","excerpt":"事由：昨日，因故poweroff了pi（正常的），然后又poweron了，结果putty能连上，vncviewer打不开了。于是putty连上pi，执行vncserver，提示我：Syntax error：”(“。。。，具体的错误记不清了，有个fontpath之类的字眼。 WHY：没有修改vnc的什么配置，就是第一次安装的时候设置了密码，后来也没动它，至于是不是开启自启的也更不用管了。后来问了度娘很多次，终于在谷歌上找到了答案（具体链接地址找不着了）：","text":"事由：昨日，因故poweroff了pi（正常的），然后又poweron了，结果putty能连上，vncviewer打不开了。于是putty连上pi，执行vncserver，提示我：Syntax error：”(“。。。，具体的错误记不清了，有个fontpath之类的字眼。 WHY：没有修改vnc的什么配置，就是第一次安装的时候设置了密码，后来也没动它，至于是不是开启自启的也更不用管了。后来问了度娘很多次，终于在谷歌上找到了答案（具体链接地址找不着了）： 正常情况下命令提示符是这样的：pi@raspberry ~ $ 而当时我的命令提示符是这样的：pi@(none) ~ $ 因此，可以敲入hostname查看当前的hostname到底是什么，如果有不对，可以执行 sudo vim /etc/hostname，当时可能是戳nginx的时候多加入了一行：lisonliou.gicp.net:8000，不好用之后也忘了去掉，结果导致今天这么多的问题：哎，我还要菜刀什么时候~~~","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"raspberry pi","slug":"raspberry-pi","permalink":"https://lison.cc/tags/raspberry-pi/"}],"author":"Lison"},{"title":"SOMEWHERE ONLY WE KNOW","slug":"somewhere-only-we-know","date":"2014-03-03T09:16:31.000Z","updated":"2023-11-16T06:15:51.686Z","comments":true,"path":"somewhere-only-we-know/","link":"","permalink":"https://lison.cc/somewhere-only-we-know/","excerpt":"","text":"douban上听到这首歌，内容比较不错。 I walked across the empty landI knew the pathway like the back of my handI felt the earth beneath my feetSat by the river and it made me completeOh simple thing where have you goneI’m getting old and i need someone to rely onSo tell me when you gonna let me inI’m getting tired and i need somewhere to beginI came across a fallen treeI felt the branches of it looking at meIs this the place we used to loveIs this the place that i’ve been dreaming ofOh simple thing where have you goneI’m getthing old and i need something to rely onSo tell me when you’re gonna let me inI’m getting tired and i need somewhere to beginAnd if you have a minute why don’t we goTalk about it somewhere only we knowThis could be the end of everythingSo why don’t we go…Somewhere only we know SOME WHERE ONLY WE KNOW - KEANE","categories":[{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"}],"tags":[{"name":"melody","slug":"melody","permalink":"https://lison.cc/tags/melody/"}],"author":"Lison"},{"title":"linux chmod 菜鸟命令改变文件夹权限","slug":"linux-chmod","date":"2014-03-03T09:06:13.000Z","updated":"2023-11-16T06:15:51.631Z","comments":true,"path":"linux-chmod/","link":"","permalink":"https://lison.cc/linux-chmod/","excerpt":"关于linux chmod修改文件/夹权限命令使用方式的简单记录。","text":"关于linux chmod修改文件/夹权限命令使用方式的简单记录。 sudo chmod -cR 777 /srv/www/wordpress/public_html 选项： -c 若已更改，显示变更记录，从xxx（权限码）变更到xxx（权限码） R递归改写权限 完成之后可以使用：sudo ls -l /srv/www/wordpress/public_html查看修改情况。 刚才wordpress上传控件时提示没有权限，想只把pi用户增加写权限，结果搞得全站403 Forbidden，要不就File not found，所以暂时干脆来个777，关于权限的码目前还不是很清楚，chmod还没怎么用过，这里先记一下。","categories":[],"tags":[],"author":"Lison"},{"title":"wordpress站点修改域名端口号（默认端口号修改）","slug":"wordpress-config-port","date":"2014-03-03T08:56:21.000Z","updated":"2023-11-16T06:15:51.872Z","comments":true,"path":"wordpress-config-port/","link":"","permalink":"https://lison.cc/wordpress-config-port/","excerpt":"OK，小打小闹，在Pi上部署了wordpress，成功。无奈电信疯掉了我的80端口，所以需要修改为别的端口，于是使用8000，据说8080也被疯掉了。","text":"OK，小打小闹，在Pi上部署了wordpress，成功。无奈电信疯掉了我的80端口，所以需要修改为别的端口，于是使用8000，据说8080也被疯掉了。 OK，小打小闹，在Pi上部署了wordpress，成功。无奈电信疯掉了我的80端口，所以需要修改为别的端口，于是使用8000，据说8080也被疯掉了。 于是乎： 路由上做端口映射，8000映射到我的pi 修改nginx相关文件：/etc/nginx/sites-enabled/wordpress与/etc/nginx/sites-available/wordpress，将其中的默认端口号80修改为8000. 重启nginx：sudo nginx -s reload，重启php5-fpm：sudo service php5-fpm reload，成功。 浏览器敲入地址：http://lison.cc。。。。不行，打不开。 什么原因： 数据库连不上？root和wordpress用户使用命令方式登录 mysql -u root -p 加密码都能进入，新建test.php，输入：，也能正常打开。新建一个连接数据库的页面，也TMD能连上。所以这个排除掉。 8000端口没映射成功？外部网络输入命令：telnet lisonliou.gicp.net 8000，直接进入，说明已成功。Ctrl+C之后提示400（这是为什么，不知道）。 其他的想不到了。 后来各种谷歌度娘问：nginx 怎么修改端口？因为以前windows下部署ngxin可以直接修改目录下的nginx.conf的listen节点，现在nginx.conf中没有这个选项，于是，修改了上述/etc/nginx/sites-available(enabled)/wordpress这两个文件。怎么改也不行，难道是我重启nginx，php-fpm的方式不对？难道是我打开的方式不对？难道是。。。bla bla bla。 上面绿色的第一项倒腾了好久，进入了误区，又是wp-config.php开启debug，开启表修复什么的。而且始终在以域名+端口方式访问，并没有加入具体的文件名，后来加入文件名访问（http://lison.cc/wp-login.php）发现php没问题，mysql也能连上，但是css没有加载上，于是查看源代码，发现css的连接地址都没有加入端口号，ok，这下问度娘就有方向了：”wordpress修改端口”，于是，找到了下面文章的内容，以下是内容片段： wordpress关于端口的不在配置文件里，而在数据表wp_options中的siteurl和home两个变量mysql&gt; update wp_options set option_value = ‘http://sas.123.com:8001’ where option_id = 1;mysql&gt; update wp_options set option_value = ‘http://sas.123.com:8001’ where option_id = 37; 原有文章中如果有插图，则插图的URL地址要更新mysql&gt; UPDATE wp_posts SET post_content = REPLACE( post_content, “http://sas.123.com“, “http://sas.123.com:8001” ) where post_date &lt; “2011-09-15”; ** 遗留的问题：** 1. 现在正在编辑的文章不知道能不能提交成功。 2. 直接敲入域名http://lison.cc还是打不开 ** http://lison.cc/index.php也打不开。而且自动导向到了：http://lison.cc，火狐给出的提示是：服务器响应时间过长。** 这是为什么，先不管了，反正端口号已经修改成功了，先Ctrl+C一下，面的提交保存不了。 解决遗留的问题： 1.看来是已经发布成功了。 2.在wordpress的wp_opitons表中还有一项需要update： update wp_options set option_value=’http://lison.cc’ where option_id=36; 这个36是干什么的？不知道，这个wp_options表是干什么的，是wp系统配置表？不知道。","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://lison.cc/categories/wordpress/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}],"author":"Lison"},{"title":"wordpress加入百度统计代码（转载）","slug":"wordpress-baidu-tongji","date":"2014-02-27T08:41:43.000Z","updated":"2023-11-16T06:15:51.872Z","comments":true,"path":"wordpress-baidu-tongji/","link":"","permalink":"https://lison.cc/wordpress-baidu-tongji/","excerpt":"wordpress加入百度统计代码具体实现方法记录一下。","text":"wordpress加入百度统计代码具体实现方法记录一下。 wordpress使用经验不多，之前以为wordpress有插件之类的东西可以一键搞定，结果还是手动添加代码的方式。如下： 找到footer.php文件，在wp-content/themes/xx/目录下(xx是主题文件)，把生成的统计代码放到 前面。 生成的代码： 1&lt;script type=”text/javascript”&gt;var _bdhmProtocol = ((“https:” == document.location.protocol) ? ” https://” : ” http://”);document.write(unescape(“%3Cscript src=&#x27;” + _bdhmProtocol + “hm.baidu.com/h.js%3F0ad8a80adfac4d244e679f2c011b45bf’ type=’text/javascript’%3E%3C/script%3E”));&lt;/script&gt; 修改后更新文件，到统计后台检查代码安装情况，系统会告诉是否安装成功。 原文地址：http://www.wellbegin.com/wordpress-how-to-join-baidu-statistics/","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://lison.cc/categories/wordpress/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"}]},{"title":"树莓派（Raspberry Pi）托管wordpress – php5+mysql5+nginx","slug":"php5-mysql5-nginx","date":"2014-02-27T07:26:15.000Z","updated":"2023-11-16T06:15:51.640Z","comments":true,"path":"php5-mysql5-nginx/","link":"","permalink":"https://lison.cc/php5-mysql5-nginx/","excerpt":"这是一篇转载文，记录了我的pi正在运行的wordpress，转载的应该是一篇翻译的文章，照着它，实现了linux下wordpress站点的部署，即php运行环境的搭建。","text":"这是一篇转载文，记录了我的pi正在运行的wordpress，转载的应该是一篇翻译的文章，照着它，实现了linux下wordpress站点的部署，即php运行环境的搭建。 这是一篇转载文，记录了我的pi正在运行的wordpress，转载的应该是一篇翻译的文章，照着它，实现了linux下wordpress站点的部署，即php运行环境的搭建。以下为原文内容：部分修改有备注。 Raspberry Pi到手一周了，搭了个服务器，因为Raspberry Pi硬件配置不高，所有选择的是nginx+mysql+php，基本是按照如下参考网站弄的，但网站上的步骤有点问题，做了一些修改。如果你觉得自己搭服务器麻烦，也可以下载如下网站已经做好的固件，刷如sd卡，开机启动后找到树莓派的ip就可以了。 参考网站：http://www.cnx-software.com/2012/08/03/wordpress-for-raspberry-pi-using-nginx-and-mysql/ Raspberry Pi的固件有很多，我安装的是官方的Raspbian，具体安装设置方法请参考 树莓派RASPBERRY PI上手报告| 雷锋网 一切准备就绪后就可以开机了，开机后启动终端，输入如下代码，建议使用root权限 **sudo apt-get updatesudo apt-get install nginx php5-fpm php5-cli php5-curl php5-gd php5-mcrypt php5-mysql php5-cgi mysql-server ** 期间会提示设置mysql密码，下载安装好nginx和mysql后在/etc/nginx/sites-available/目录下创建文件wordpress写入如下代码并保存。 Upstream to abstract backend connection(s) for php1234567891011121314151617181920212223242526272829303132333435363738394041424344upstream php &#123; server unix:/var/run/php5-fpm.sock;&#125;server &#123; ## Your only path reference. root /srv/www/wordpress/public_html; listen 80; ## Your website name goes here. Change to domain.ltd in VPS server_name _; access_log /srv/www/wordpress/logs/access.log; error_log /srv/www/wordpress/logs/error.log; ## This should be in your http block and if it is, it’s not needed here. index index.php; location = /favicon.ico &#123; log_not_found off; access_log off; &#125; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; location / &#123; # This is cool because no php is touched for static contenttry_files $uri $uri/ /index.php; &#125; location ~ \\.php$ &#123; #NOTE: You should have “cgi.fix_pathinfo = 0;” in php.ini include fastcgi_params; fastcgi_intercept_errors on; fastcgi_pass php; &#125; location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ &#123; expires max; log_not_found off; &#125;&#125; 然后将此文件复制到**/etc/nginx/sites-sites-enabled/**目录下，分别删除两个文件夹中的default文件。 上述粗体路径应该是：/etc/nginx/sites-enabled/然后是下载和解压wordpress（代码已修改为下载最新中文版wordpress） sudo mkdir -p /srv/www/wordpress/logs/sudo mkdir -p /srv/www/wordpress/public_htmlcd /srv/www/wordpress/public_htmlsudo wget http://cn.wordpress.org/latest.tar.gzsudo tar xzvf latest.tar.gzsudo mv wordpress/* . 上述红字部分应为为：sudo wget http://cn.wordpress.org/wordpress-3.8.1-zh_CN.tar.gz 设置mysql数据库（其中的raspi为wordpress数据库的密码） 12345678910111213141516171819$ mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 5340 to server version: 3.23.54Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the buffer.mysql&gt; CREATE DATABASE wordpress;Query OK, 1 row affected (0.00 sec)mysql&gt; GRANT ALL PRIVILEGES ON wordpress.* TO “wordpress”@”localhost”IDENTIFIED BY “raspi”;Query OK, 0 rows affected (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.01 sec)mysql&gt; EXITBye$ 将/srv/www/wordpress/public_html目录下的wp-config-sample.php文件名改为wp-config.php然后打开修改其中的以下几行 define(‘DB_NAME’, ‘wordpress’); define(‘DB_USER’, ‘wordpress’); define(‘DB_PASSWORD’, ‘raspi’); 重启 nginx 和 php5-fpm sudo cp wp-config-sample.php wp-config.phpsudo edit wp-config.php 在浏览器中输入http://你的树莓派ip/wp-admin/install.php，就可以安装wordpress啦！ 我使用的是网通的1M ADSL，动态域名解析用的是花生壳和它提供的免费二级域名 最后欢迎大家访问我托管在树莓派上的博客：xgmlab.oicp.net(速度可能会有点慢！) 注 nginx的启动与重启 sudo nginx -s stop &amp;&amp; nginx 通过上述配置，已经成功实现了在我的pi上运行wordpress，不过速度确实比较慢，内网就已感觉出来了，不知道外网会如何。 目前就使用这个免费的三级域名吧，以后的关于pi与linux的东西会记录在这个博客上，慢慢积累点东西。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"},{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]}],"categories":[{"name":"Qt","slug":"Qt","permalink":"https://lison.cc/categories/Qt/"},{"name":"人性","slug":"人性","permalink":"https://lison.cc/categories/%E4%BA%BA%E6%80%A7/"},{"name":"AOSP","slug":"AOSP","permalink":"https://lison.cc/categories/AOSP/"},{"name":"Linux","slug":"Linux","permalink":"https://lison.cc/categories/Linux/"},{"name":"Linux Shell","slug":"Linux-Shell","permalink":"https://lison.cc/categories/Linux-Shell/"},{"name":"linux操作系统编译移植","slug":"linux操作系统编译移植","permalink":"https://lison.cc/categories/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/"},{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/categories/arduino/"},{"name":"loT","slug":"loT","permalink":"https://lison.cc/categories/loT/"},{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"QT","slug":"QT","permalink":"https://lison.cc/categories/QT/"},{"name":"plc","slug":"plc","permalink":"https://lison.cc/categories/plc/"},{"name":"qt","slug":"qt","permalink":"https://lison.cc/categories/qt/"},{"name":"PLC","slug":"PLC","permalink":"https://lison.cc/categories/PLC/"},{"name":"航海日记","slug":"航海日记","permalink":"https://lison.cc/categories/%E8%88%AA%E6%B5%B7%E6%97%A5%E8%AE%B0/"},{"name":"CPP","slug":"CPP","permalink":"https://lison.cc/categories/CPP/"},{"name":"csharp","slug":"csharp","permalink":"https://lison.cc/categories/csharp/"},{"name":"c#","slug":"c","permalink":"https://lison.cc/categories/c/"},{"name":"java","slug":"java","permalink":"https://lison.cc/categories/java/"},{"name":"安卓面试","slug":"安卓面试","permalink":"https://lison.cc/categories/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95/"},{"name":"Android","slug":"Android","permalink":"https://lison.cc/categories/Android/"},{"name":"android","slug":"android","permalink":"https://lison.cc/categories/android/"},{"name":"autojs","slug":"autojs","permalink":"https://lison.cc/categories/autojs/"},{"name":"php","slug":"php","permalink":"https://lison.cc/categories/php/"},{"name":"linux","slug":"linux","permalink":"https://lison.cc/categories/linux/"},{"name":"water under the bridge","slug":"water-under-the-bridge","permalink":"https://lison.cc/categories/water-under-the-bridge/"},{"name":"刷机","slug":"刷机","permalink":"https://lison.cc/categories/%E5%88%B7%E6%9C%BA/"},{"name":"前端","slug":"前端","permalink":"https://lison.cc/categories/%E5%89%8D%E7%AB%AF/"},{"name":"kotlin","slug":"kotlin","permalink":"https://lison.cc/categories/kotlin/"},{"name":"Literature Library","slug":"Literature-Library","permalink":"https://lison.cc/categories/Literature-Library/"},{"name":"英语","slug":"英语","permalink":"https://lison.cc/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"c","slug":"c","permalink":"https://lison.cc/categories/c/"},{"name":"山口山","slug":"山口山","permalink":"https://lison.cc/categories/%E5%B1%B1%E5%8F%A3%E5%B1%B1/"},{"name":"在世","slug":"在世","permalink":"https://lison.cc/categories/%E5%9C%A8%E4%B8%96/"},{"name":"上班","slug":"上班","permalink":"https://lison.cc/categories/%E4%B8%8A%E7%8F%AD/"},{"name":"vpn","slug":"vpn","permalink":"https://lison.cc/categories/vpn/"},{"name":"云","slug":"云","permalink":"https://lison.cc/categories/%E4%BA%91/"},{"name":"分布式","slug":"分布式","permalink":"https://lison.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"apache","slug":"apache","permalink":"https://lison.cc/categories/apache/"},{"name":"javascript","slug":"javascript","permalink":"https://lison.cc/categories/javascript/"},{"name":"生人","slug":"生人","permalink":"https://lison.cc/categories/%E7%94%9F%E4%BA%BA/"},{"name":"raspberry pi","slug":"raspberry-pi","permalink":"https://lison.cc/categories/raspberry-pi/"},{"name":"python","slug":"python","permalink":"https://lison.cc/categories/python/"},{"name":"radio","slug":"radio","permalink":"https://lison.cc/categories/radio/"},{"name":"t-sql","slug":"t-sql","permalink":"https://lison.cc/categories/t-sql/"},{"name":"reading","slug":"reading","permalink":"https://lison.cc/categories/reading/"},{"name":"人生","slug":"人生","permalink":"https://lison.cc/categories/%E4%BA%BA%E7%94%9F/"},{"name":"记忆","slug":"记忆","permalink":"https://lison.cc/categories/%E8%AE%B0%E5%BF%86/"},{"name":"修行","slug":"修行","permalink":"https://lison.cc/categories/%E4%BF%AE%E8%A1%8C/"},{"name":"生活作业","slug":"生活作业","permalink":"https://lison.cc/categories/%E7%94%9F%E6%B4%BB%E4%BD%9C%E4%B8%9A/"},{"name":"nginx","slug":"nginx","permalink":"https://lison.cc/categories/nginx/"},{"name":"旅行","slug":"旅行","permalink":"https://lison.cc/categories/%E6%97%85%E8%A1%8C/"},{"name":"wordpress","slug":"wordpress","permalink":"https://lison.cc/categories/wordpress/"}],"tags":[{"name":"自私","slug":"自私","permalink":"https://lison.cc/tags/%E8%87%AA%E7%A7%81/"},{"name":"虚荣","slug":"虚荣","permalink":"https://lison.cc/tags/%E8%99%9A%E8%8D%A3/"},{"name":"AOSP","slug":"AOSP","permalink":"https://lison.cc/tags/AOSP/"},{"name":"虚拟内存","slug":"虚拟内存","permalink":"https://lison.cc/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"name":"bash","slug":"bash","permalink":"https://lison.cc/tags/bash/"},{"name":"回顾","slug":"回顾","permalink":"https://lison.cc/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"linux kernel 编译","slug":"linux-kernel-编译","permalink":"https://lison.cc/tags/linux-kernel-%E7%BC%96%E8%AF%91/"},{"name":"鸿蒙系统移植","slug":"鸿蒙系统移植","permalink":"https://lison.cc/tags/%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"},{"name":"arduino","slug":"arduino","permalink":"https://lison.cc/tags/arduino/"},{"name":"RPi","slug":"RPi","permalink":"https://lison.cc/tags/RPi/"},{"name":"物联网","slug":"物联网","permalink":"https://lison.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"LCD 1602a","slug":"LCD-1602a","permalink":"https://lison.cc/tags/LCD-1602a/"},{"name":"16进制","slug":"16进制","permalink":"https://lison.cc/tags/16%E8%BF%9B%E5%88%B6/"},{"name":"容器类","slug":"容器类","permalink":"https://lison.cc/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"},{"name":"CPU","slug":"CPU","permalink":"https://lison.cc/tags/CPU/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lison.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"IPC","slug":"IPC","permalink":"https://lison.cc/tags/IPC/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"https://lison.cc/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"动态库dll","slug":"动态库dll","permalink":"https://lison.cc/tags/%E5%8A%A8%E6%80%81%E5%BA%93dll/"},{"name":"Log4Qt","slug":"Log4Qt","permalink":"https://lison.cc/tags/Log4Qt/"},{"name":"自定义控件","slug":"自定义控件","permalink":"https://lison.cc/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"},{"name":"json","slug":"json","permalink":"https://lison.cc/tags/json/"},{"name":"java强软弱虚四大引用","slug":"java强软弱虚四大引用","permalink":"https://lison.cc/tags/java%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/"},{"name":"安卓架构师面试题","slug":"安卓架构师面试题","permalink":"https://lison.cc/tags/%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Android ANR","slug":"Android-ANR","permalink":"https://lison.cc/tags/Android-ANR/"},{"name":"autojs pro","slug":"autojs-pro","permalink":"https://lison.cc/tags/autojs-pro/"},{"name":"php","slug":"php","permalink":"https://lison.cc/tags/php/"},{"name":"nginx","slug":"nginx","permalink":"https://lison.cc/tags/nginx/"},{"name":"debian","slug":"debian","permalink":"https://lison.cc/tags/debian/"},{"name":"fiddler","slug":"fiddler","permalink":"https://lison.cc/tags/fiddler/"},{"name":"多线程","slug":"多线程","permalink":"https://lison.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"root","slug":"root","permalink":"https://lison.cc/tags/root/"},{"name":"okhttp","slug":"okhttp","permalink":"https://lison.cc/tags/okhttp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lison.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"折腾","slug":"折腾","permalink":"https://lison.cc/tags/%E6%8A%98%E8%85%BE/"},{"name":"poem","slug":"poem","permalink":"https://lison.cc/tags/poem/"},{"name":"算法","slug":"算法","permalink":"https://lison.cc/tags/%E7%AE%97%E6%B3%95/"},{"name":"科学上网","slug":"科学上网","permalink":"https://lison.cc/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"ipfs","slug":"ipfs","permalink":"https://lison.cc/tags/ipfs/"},{"name":"图片压缩","slug":"图片压缩","permalink":"https://lison.cc/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://lison.cc/tags/bootstrap/"},{"name":"seo","slug":"seo","permalink":"https://lison.cc/tags/seo/"},{"name":"aci","slug":"aci","permalink":"https://lison.cc/tags/aci/"},{"name":"旧事重提","slug":"旧事重提","permalink":"https://lison.cc/tags/%E6%97%A7%E4%BA%8B%E9%87%8D%E6%8F%90/"},{"name":"生人","slug":"生人","permalink":"https://lison.cc/tags/%E7%94%9F%E4%BA%BA/"},{"name":"netty","slug":"netty","permalink":"https://lison.cc/tags/netty/"},{"name":"旅行","slug":"旅行","permalink":"https://lison.cc/tags/%E6%97%85%E8%A1%8C/"},{"name":"读沈从文《边城》","slug":"读沈从文《边城》","permalink":"https://lison.cc/tags/%E8%AF%BB%E6%B2%88%E4%BB%8E%E6%96%87%E3%80%8A%E8%BE%B9%E5%9F%8E%E3%80%8B/"},{"name":"无线电频率","slug":"无线电频率","permalink":"https://lison.cc/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E9%A2%91%E7%8E%87/"},{"name":"职业规划","slug":"职业规划","permalink":"https://lison.cc/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"},{"name":"android camera","slug":"android-camera","permalink":"https://lison.cc/tags/android-camera/"},{"name":"未完待续","slug":"未完待续","permalink":"https://lison.cc/tags/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"},{"name":"不列大标题","slug":"不列大标题","permalink":"https://lison.cc/tags/%E4%B8%8D%E5%88%97%E5%A4%A7%E6%A0%87%E9%A2%98/"},{"name":"匆忙","slug":"匆忙","permalink":"https://lison.cc/tags/%E5%8C%86%E5%BF%99/"},{"name":"maven","slug":"maven","permalink":"https://lison.cc/tags/maven/"},{"name":"zhi","slug":"zhi","permalink":"https://lison.cc/tags/zhi/"},{"name":"看黑板","slug":"看黑板","permalink":"https://lison.cc/tags/%E7%9C%8B%E9%BB%91%E6%9D%BF/"},{"name":"给自己","slug":"给自己","permalink":"https://lison.cc/tags/%E7%BB%99%E8%87%AA%E5%B7%B1/"},{"name":"android","slug":"android","permalink":"https://lison.cc/tags/android/"},{"name":"melody","slug":"melody","permalink":"https://lison.cc/tags/melody/"},{"name":"OLD","slug":"OLD","permalink":"https://lison.cc/tags/OLD/"},{"name":"老喽","slug":"老喽","permalink":"https://lison.cc/tags/%E8%80%81%E5%96%BD/"},{"name":"生命","slug":"生命","permalink":"https://lison.cc/tags/%E7%94%9F%E5%91%BD/"},{"name":"记忆","slug":"记忆","permalink":"https://lison.cc/tags/%E8%AE%B0%E5%BF%86/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://lison.cc/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"文件监视器","slug":"文件监视器","permalink":"https://lison.cc/tags/%E6%96%87%E4%BB%B6%E7%9B%91%E8%A7%86%E5%99%A8/"},{"name":"apache","slug":"apache","permalink":"https://lison.cc/tags/apache/"},{"name":"作业","slug":"作业","permalink":"https://lison.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"sqlite","slug":"sqlite","permalink":"https://lison.cc/tags/sqlite/"},{"name":"心灵","slug":"心灵","permalink":"https://lison.cc/tags/%E5%BF%83%E7%81%B5/"},{"name":"生活作业","slug":"生活作业","permalink":"https://lison.cc/tags/%E7%94%9F%E6%B4%BB%E4%BD%9C%E4%B8%9A/"},{"name":"linux","slug":"linux","permalink":"https://lison.cc/tags/linux/"},{"name":"raspberry pi","slug":"raspberry-pi","permalink":"https://lison.cc/tags/raspberry-pi/"},{"name":"树莓派","slug":"树莓派","permalink":"https://lison.cc/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]}